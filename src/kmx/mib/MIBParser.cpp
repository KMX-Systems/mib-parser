
// Generated from MIB.g4 by ANTLR 4.13.2


#include "MIBListener.h"

#include "MIBParser.h"


using namespace antlrcpp;
using namespace kmx::mib;

using namespace antlr4;

namespace {

struct MIBParserStaticData final {
  MIBParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  MIBParserStaticData(const MIBParserStaticData&) = delete;
  MIBParserStaticData(MIBParserStaticData&&) = delete;
  MIBParserStaticData& operator=(const MIBParserStaticData&) = delete;
  MIBParserStaticData& operator=(MIBParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag mibParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<MIBParserStaticData> mibParserStaticData = nullptr;

void mibParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (mibParserStaticData != nullptr) {
    return;
  }
#else
  assert(mibParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<MIBParserStaticData>(
    std::vector<std::string>{
      "data", "moduleDefinition", "moduleIdentifier", "moduleReference", 
      "tagDefault", "moduleBody", "exportList", "importList", "symbolsFromModule", 
      "symbolList", "symbolListBraced", "symbol", "assignmentList", "assignment", 
      "macroDefinition", "macroReference", "macroBody", "macroBodyElement", 
      "typeAssignment", "type", "definedType", "builtinType", "nullType", 
      "booleanType", "realType", "accessLevel", "integerType", "objectIdentifierType", 
      "stringType", "bitStringType", "bitsType", "sequenceContent", "sequenceType", 
      "sequenceOfType", "setType", "setOfType", "choiceType", "enumeratedType", 
      "selectionType", "taggedType", "tag", "class_", "explicitOrImplicitTag", 
      "anyType", "elementTypeList", "elementType", "optionalOrDefaultElement", 
      "valueOrConstraintList", "namedNumberList", "namedNumber", "number", 
      "constraintList", "constraint", "valueConstraintList", "valueConstraint", 
      "valueRange", "lowerEndPoint", "upperEndPoint", "sizeConstraint", 
      "alphabetConstraint", "containedTypeConstraint", "innerTypeConstraint", 
      "componentsList", "componentsListTail", "componentConstraint", "componentValuePresence", 
      "componentPresence", "valueAssignment", "value", "definedValue", "builtinValue", 
      "nullValue", "booleanValue", "specialRealValue", "numberValue", "binaryValue", 
      "hexadecimalValue", "stringValue", "bitOrObjectIdentifierValue", "bitValue", 
      "objectIdentifierValue", "nameValueList", "nameValueComponent", "nameOrNumber", 
      "nameAndNumber", "definedMacroType", "definedMacroName", "snmpStatusDescrReferPart", 
      "snmpObjectStatusDescrReferPart", "snmpModuleIdentityMacroType", "snmpObjectIdentityMacroType", 
      "snmpObjectTypeMacroType", "snmpNotificationTypeMacroType", "snmpTrapTypeMacroType", 
      "snmpTextualConventionMacroType", "snmpObjectGroupMacroType", "snmpNotificationGroupMacroType", 
      "snmpModuleComplianceMacroType", "snmpAgentCapabilitiesMacroType", 
      "snmpSupportPart", "snmpInclusionPart", "snmpVariationPart", "snmpGroupPart", 
      "snmpAccessPart", "snmpContactPart", "snmpDefValPart", "snmpDescrPart", 
      "snmpDisplayPart", "snmpEnterprisePart", "snmpIndexPart", "snmpMaxAccessPart", 
      "snmpMandatoryGroupsPart", "snmpMibGroupsPart", "snmpMibCompliancePart", 
      "snmpModulesPart", "snmpNotificationPart", "snmpObjectsPart", "snmpOrganizationPart", 
      "snmpProductPart", "snmpReferPart", "snmpRevisionPart", "snmpStatusPart", 
      "snmpSyntaxPart", "snmpUnitsPart", "snmpUpdatePart", "snmpVarPart", 
      "snmpWritePart"
    },
    std::vector<std::string>{
      "", "','", "'::='", "'.'", "'..'", "'{'", "'['", "'('", "'<'", "'-'", 
      "'}'", "']'", "')'", "';'", "'...'", "'|'", "'ABSENT'", "'accessible-for-notify'", 
      "'ACCESS'", "'AGENT-CAPABILITIES'", "'ANY'", "'APPLICATION'", "'BEGIN'", 
      "'BIT'", "'BITS'", "'BOOLEAN'", "'BY'", "'CHOICE'", "'COMPONENT'", 
      "'COMPONENTS'", "'CONTACT-INFO'", "'DEFAULT'", "'DEFINED'", "'DEFINITIONS'", 
      "'DEFVAL'", "'DESCRIPTION'", "'DISPLAY-HINT'", "'END'", "'ENTERPRISE'", 
      "'ENUMERATED'", "'EXPLICIT'", "'EXPORTS'", "'FALSE'", "'FROM'", "'GROUP'", 
      "'IDENTIFIER'", "'IMPLICIT'", "'IMPORTS'", "'INCLUDES'", "'INDEX'", 
      "'INTEGER'", "'LAST-UPDATED'", "'MANDATORY-GROUPS'", "'MACRO'", "'MAX'", 
      "'MAX-ACCESS'", "'MIN'", "'MINUS-INFINITY'", "'MODULE'", "'MODULES'", 
      "'MODULE-COMPLIANCE'", "'MODULE-IDENTITY'", "'not-accessible'", "'NOTIFICATION-GROUP'", 
      "'NOTIFICATION-TYPE'", "'NOTIFICATIONS'", "'NULL'", "'OBJECT'", "'OBJECT-GROUP'", 
      "'OBJECT-IDENTITY'", "'OBJECT-TYPE'", "'OBJECTS'", "'OCTET'", "'OF'", 
      "'OPTIONAL'", "'ORGANIZATION'", "'PLUS-INFINITY'", "'PRESENT'", "'PRIVATE'", 
      "'PRODUCT-RELEASE'", "'read-create'", "'read-only'", "'read-write'", 
      "'REAL'", "'REFERENCE'", "'REVISION'", "'SEQUENCE'", "'SET'", "'SIZE'", 
      "'STATUS'", "'STRING'", "'SUPPORTS'", "'SYNTAX'", "'TAGS'", "'TEXTUAL-CONVENTION'", 
      "'TRAP-TYPE'", "'TRUE'", "'UNITS'", "'UNIVERSAL'", "'VARIABLES'", 
      "'VARIATION'", "'WITH'", "'WRITE-SYNTAX'"
    },
    std::vector<std::string>{
      "", "COMMA", "DEFINITION", "DOT", "DOUBLE_DOT", "LEFT_BRACE", "LEFT_BRACKET", 
      "LEFT_PAREN", "LESS_THAN", "MINUS", "RIGHT_BRACE", "RIGHT_BRACKET", 
      "RIGHT_PAREN", "SEMI_COLON", "TRIPLE_DOT", "VERTICAL_BAR", "ABSENT", 
      "ACCESSIBLE_FOR_NOTIFY", "ACCESS", "AGENT_CAPABILITIES", "ANY", "APPLICATION", 
      "BEGIN", "BIT", "BITS", "BOOLEAN", "BY", "CHOICE", "COMPONENT", "COMPONENTS", 
      "CONTACT_INFO", "DEFAULT", "DEFINED", "DEFINITIONS", "DEFVAL", "DESCRIPTION", 
      "DISPLAY_HINT", "END", "ENTERPRISE", "ENUMERATED", "EXPLICIT", "EXPORTS", 
      "FALSE", "FROM", "GROUP", "IDENTIFIER", "IMPLICIT", "IMPORTS", "INCLUDES", 
      "INDEX", "INTEGER", "LAST_UPDATED", "MANDATORY_GROUPS", "MACRO", "MAX", 
      "MAX_ACCESS", "MIN", "MINUS_INFINITY", "MODULE", "MODULES", "MODULE_COMPLIANCE", 
      "MODULE_IDENTITY", "NOT_ACCESSIBLE", "NOTIFICATION_GROUP", "NOTIFICATION_TYPE", 
      "NOTIFICATIONS", "NULL", "OBJECT", "OBJECT_GROUP", "OBJECT_IDENTITY", 
      "OBJECT_TYPE", "OBJECTS", "OCTET", "OF", "OPTIONAL", "ORGANIZATION", 
      "PLUS_INFINITY", "PRESENT", "PRIVATE", "PRODUCT_RELEASE", "READ_CREATE", 
      "READ_ONLY", "READ_WRITE", "REAL", "REFERENCE", "REVISION", "SEQUENCE", 
      "SET", "SIZE", "STATUS", "STRING", "SUPPORTS", "SYNTAX", "TAGS", "TEXTUAL_CONVENTION", 
      "TRAP_TYPE", "TRUE", "UNITS", "UNIVERSAL", "VARIABLES", "VARIATION", 
      "WITH", "WRITE_SYNTAX", "BINARY_STRING", "HEXADECIMAL_STRING", "QUOTED_STRING", 
      "IDENTIFIER_STRING", "INTEGER_STRING", "NUMBER_STRING", "WHITESPACE", 
      "COMMENT"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,110,957,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
  	63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,
  	70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,
  	77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,
  	84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
  	91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,7,
  	98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,7,
  	104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,1,0,4,0,256,8,0,
  	11,0,12,0,257,1,1,1,1,1,1,3,1,263,8,1,1,1,1,1,1,1,3,1,268,8,1,1,1,1,1,
  	1,2,1,2,3,2,274,8,2,1,3,1,3,1,4,1,4,1,4,1,4,3,4,282,8,4,1,5,3,5,285,8,
  	5,1,5,3,5,288,8,5,1,5,1,5,1,6,1,6,3,6,294,8,6,1,6,1,6,1,7,1,7,5,7,300,
  	8,7,10,7,12,7,303,9,7,1,7,1,7,1,8,1,8,1,8,1,8,1,9,1,9,1,9,5,9,314,8,9,
  	10,9,12,9,317,9,9,1,10,1,10,1,10,1,10,1,11,1,11,3,11,325,8,11,1,12,4,
  	12,328,8,12,11,12,12,12,329,1,13,1,13,1,13,3,13,335,8,13,1,13,3,13,338,
  	8,13,1,14,1,14,1,14,1,14,1,14,1,15,1,15,3,15,347,8,15,1,16,1,16,5,16,
  	351,8,16,10,16,12,16,354,9,16,1,16,1,16,1,16,1,16,3,16,360,8,16,1,17,
  	1,17,1,18,1,18,1,18,1,18,1,19,1,19,1,19,3,19,371,8,19,1,20,3,20,374,8,
  	20,1,20,1,20,3,20,378,8,20,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,
  	21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,397,8,21,1,22,1,22,1,
  	23,1,23,1,24,1,24,1,25,1,25,1,26,1,26,3,26,409,8,26,1,27,1,27,1,27,1,
  	28,1,28,1,28,3,28,417,8,28,1,29,1,29,1,29,3,29,422,8,29,1,30,1,30,3,30,
  	426,8,30,1,31,1,31,3,31,430,8,31,1,31,1,31,1,32,1,32,1,32,1,33,1,33,3,
  	33,439,8,33,1,33,1,33,1,33,1,34,1,34,1,34,3,34,447,8,34,1,34,1,34,1,35,
  	1,35,3,35,453,8,35,1,35,1,35,1,35,1,36,1,36,1,36,1,36,1,36,1,37,1,37,
  	1,37,1,38,1,38,1,38,1,38,1,39,1,39,1,39,1,39,1,40,1,40,3,40,476,8,40,
  	1,40,1,40,1,40,1,41,1,41,1,42,1,42,1,43,1,43,1,43,1,43,3,43,489,8,43,
  	1,44,1,44,1,44,5,44,494,8,44,10,44,12,44,497,9,44,1,45,3,45,500,8,45,
  	1,45,1,45,3,45,504,8,45,1,45,3,45,507,8,45,1,45,1,45,1,45,3,45,512,8,
  	45,1,46,1,46,1,46,3,46,517,8,46,1,46,3,46,520,8,46,1,47,1,47,3,47,524,
  	8,47,1,48,1,48,1,48,1,48,5,48,530,8,48,10,48,12,48,533,9,48,1,48,1,48,
  	1,49,1,49,1,49,1,49,1,49,1,50,1,50,1,50,1,50,3,50,546,8,50,1,51,1,51,
  	1,51,1,51,5,51,552,8,51,10,51,12,51,555,9,51,1,51,1,51,1,52,1,52,1,52,
  	1,52,1,52,3,52,564,8,52,1,53,1,53,1,53,1,53,5,53,570,8,53,10,53,12,53,
  	573,9,53,1,53,1,53,1,54,1,54,3,54,579,8,54,1,55,3,55,582,8,55,1,55,1,
  	55,3,55,586,8,55,1,55,1,55,1,56,1,56,3,56,592,8,56,1,57,1,57,3,57,596,
  	8,57,1,58,1,58,1,58,1,59,1,59,1,59,1,60,1,60,1,60,1,61,1,61,1,61,1,61,
  	1,61,1,61,3,61,613,8,61,1,62,1,62,1,62,5,62,618,8,62,10,62,12,62,621,
  	9,62,1,62,1,62,4,62,625,8,62,11,62,12,62,626,3,62,629,8,62,1,62,1,62,
  	1,63,1,63,3,63,635,8,63,1,64,1,64,3,64,639,8,64,1,64,3,64,642,8,64,1,
  	65,1,65,3,65,646,8,65,1,65,3,65,649,8,65,1,66,1,66,1,67,1,67,1,67,1,67,
  	1,67,1,68,1,68,3,68,660,8,68,1,69,1,69,1,69,1,69,3,69,666,8,69,1,69,3,
  	69,669,8,69,1,70,1,70,1,70,1,70,1,70,1,70,1,70,1,70,3,70,679,8,70,1,71,
  	1,71,1,72,1,72,1,73,1,73,1,74,3,74,688,8,74,1,74,1,74,1,75,1,75,1,76,
  	1,76,1,77,1,77,1,78,1,78,1,79,1,79,1,80,1,80,1,81,1,81,5,81,706,8,81,
  	10,81,12,81,709,9,81,1,81,1,81,1,82,3,82,714,8,82,1,82,1,82,1,83,1,83,
  	1,83,3,83,721,8,83,1,84,1,84,1,84,1,84,3,84,727,8,84,1,84,1,84,1,85,1,
  	85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,1,85,3,85,741,8,85,1,86,1,86,1,
  	87,1,87,1,87,3,87,748,8,87,1,88,1,88,1,88,1,89,1,89,1,89,1,89,1,89,1,
  	89,5,89,759,8,89,10,89,12,89,762,9,89,1,90,1,90,1,90,1,91,1,91,1,91,3,
  	91,770,8,91,1,91,3,91,773,8,91,1,91,1,91,1,91,1,91,3,91,779,8,91,1,91,
  	3,91,782,8,91,1,92,1,92,1,92,1,93,1,93,1,93,3,93,790,8,93,1,93,1,93,3,
  	93,794,8,93,1,94,1,94,1,94,1,94,1,95,1,95,1,95,1,96,1,96,1,96,3,96,806,
  	8,96,1,96,3,96,809,8,96,1,96,1,96,1,96,1,97,1,97,1,97,5,97,817,8,97,10,
  	97,12,97,820,9,97,1,97,1,97,1,97,3,97,825,8,97,1,98,1,98,1,98,1,98,5,
  	98,831,8,98,10,98,12,98,834,9,98,1,99,1,99,1,99,1,99,3,99,840,8,99,1,
  	100,1,100,1,100,1,101,1,101,1,101,1,101,3,101,849,8,101,1,101,1,101,3,
  	101,853,8,101,3,101,855,8,101,1,102,1,102,1,102,1,102,3,102,861,8,102,
  	1,103,1,103,1,103,1,104,1,104,1,104,1,105,1,105,1,105,1,105,1,105,1,106,
  	1,106,1,106,1,107,1,107,1,107,1,108,1,108,1,108,1,109,1,109,1,109,3,109,
  	886,8,109,1,110,1,110,1,110,1,111,1,111,1,111,1,111,1,111,1,112,1,112,
  	1,112,1,112,1,113,1,113,1,113,1,114,1,114,1,114,1,114,1,114,5,114,908,
  	8,114,10,114,12,114,911,9,114,1,114,1,114,1,115,1,115,1,115,1,115,1,115,
  	1,116,1,116,1,116,1,116,1,116,1,117,1,117,1,117,1,118,1,118,1,118,1,119,
  	1,119,1,119,1,120,1,120,1,120,1,120,1,120,1,121,1,121,1,121,1,122,1,122,
  	1,122,1,123,1,123,1,123,1,124,1,124,1,124,1,125,1,125,1,125,1,126,1,126,
  	1,126,1,126,0,0,127,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,
  	36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,
  	82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,
  	122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,
  	158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,
  	194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,
  	230,232,234,236,238,240,242,244,246,248,250,252,0,8,13,0,2,2,7,7,12,12,
  	15,15,23,23,25,25,45,45,50,50,66,67,72,72,83,83,90,90,105,106,3,0,17,
  	17,62,62,80,82,3,0,21,21,78,78,98,98,2,0,40,40,46,46,3,0,16,16,74,74,
  	77,77,2,0,42,42,96,96,2,0,57,57,76,76,5,0,19,19,60,61,63,64,68,70,94,
  	95,956,0,255,1,0,0,0,2,259,1,0,0,0,4,271,1,0,0,0,6,275,1,0,0,0,8,281,
  	1,0,0,0,10,284,1,0,0,0,12,291,1,0,0,0,14,297,1,0,0,0,16,306,1,0,0,0,18,
  	310,1,0,0,0,20,318,1,0,0,0,22,324,1,0,0,0,24,327,1,0,0,0,26,334,1,0,0,
  	0,28,339,1,0,0,0,30,346,1,0,0,0,32,359,1,0,0,0,34,361,1,0,0,0,36,363,
  	1,0,0,0,38,370,1,0,0,0,40,373,1,0,0,0,42,396,1,0,0,0,44,398,1,0,0,0,46,
  	400,1,0,0,0,48,402,1,0,0,0,50,404,1,0,0,0,52,406,1,0,0,0,54,410,1,0,0,
  	0,56,413,1,0,0,0,58,418,1,0,0,0,60,423,1,0,0,0,62,427,1,0,0,0,64,433,
  	1,0,0,0,66,436,1,0,0,0,68,443,1,0,0,0,70,450,1,0,0,0,72,457,1,0,0,0,74,
  	462,1,0,0,0,76,465,1,0,0,0,78,469,1,0,0,0,80,473,1,0,0,0,82,480,1,0,0,
  	0,84,482,1,0,0,0,86,484,1,0,0,0,88,490,1,0,0,0,90,511,1,0,0,0,92,519,
  	1,0,0,0,94,523,1,0,0,0,96,525,1,0,0,0,98,536,1,0,0,0,100,545,1,0,0,0,
  	102,547,1,0,0,0,104,563,1,0,0,0,106,565,1,0,0,0,108,576,1,0,0,0,110,581,
  	1,0,0,0,112,591,1,0,0,0,114,595,1,0,0,0,116,597,1,0,0,0,118,600,1,0,0,
  	0,120,603,1,0,0,0,122,612,1,0,0,0,124,614,1,0,0,0,126,632,1,0,0,0,128,
  	641,1,0,0,0,130,648,1,0,0,0,132,650,1,0,0,0,134,652,1,0,0,0,136,659,1,
  	0,0,0,138,668,1,0,0,0,140,678,1,0,0,0,142,680,1,0,0,0,144,682,1,0,0,0,
  	146,684,1,0,0,0,148,687,1,0,0,0,150,691,1,0,0,0,152,693,1,0,0,0,154,695,
  	1,0,0,0,156,697,1,0,0,0,158,699,1,0,0,0,160,701,1,0,0,0,162,703,1,0,0,
  	0,164,713,1,0,0,0,166,720,1,0,0,0,168,722,1,0,0,0,170,740,1,0,0,0,172,
  	742,1,0,0,0,174,744,1,0,0,0,176,749,1,0,0,0,178,752,1,0,0,0,180,763,1,
  	0,0,0,182,766,1,0,0,0,184,783,1,0,0,0,186,786,1,0,0,0,188,795,1,0,0,0,
  	190,799,1,0,0,0,192,802,1,0,0,0,194,813,1,0,0,0,196,826,1,0,0,0,198,835,
  	1,0,0,0,200,841,1,0,0,0,202,844,1,0,0,0,204,856,1,0,0,0,206,862,1,0,0,
  	0,208,865,1,0,0,0,210,868,1,0,0,0,212,873,1,0,0,0,214,876,1,0,0,0,216,
  	879,1,0,0,0,218,885,1,0,0,0,220,887,1,0,0,0,222,890,1,0,0,0,224,895,1,
  	0,0,0,226,899,1,0,0,0,228,902,1,0,0,0,230,914,1,0,0,0,232,919,1,0,0,0,
  	234,924,1,0,0,0,236,927,1,0,0,0,238,930,1,0,0,0,240,933,1,0,0,0,242,938,
  	1,0,0,0,244,941,1,0,0,0,246,944,1,0,0,0,248,947,1,0,0,0,250,950,1,0,0,
  	0,252,953,1,0,0,0,254,256,3,2,1,0,255,254,1,0,0,0,256,257,1,0,0,0,257,
  	255,1,0,0,0,257,258,1,0,0,0,258,1,1,0,0,0,259,260,3,4,2,0,260,262,5,33,
  	0,0,261,263,3,8,4,0,262,261,1,0,0,0,262,263,1,0,0,0,263,264,1,0,0,0,264,
  	265,5,2,0,0,265,267,5,22,0,0,266,268,3,10,5,0,267,266,1,0,0,0,267,268,
  	1,0,0,0,268,269,1,0,0,0,269,270,5,37,0,0,270,3,1,0,0,0,271,273,5,106,
  	0,0,272,274,3,160,80,0,273,272,1,0,0,0,273,274,1,0,0,0,274,5,1,0,0,0,
  	275,276,5,106,0,0,276,7,1,0,0,0,277,278,5,40,0,0,278,282,5,93,0,0,279,
  	280,5,46,0,0,280,282,5,93,0,0,281,277,1,0,0,0,281,279,1,0,0,0,282,9,1,
  	0,0,0,283,285,3,12,6,0,284,283,1,0,0,0,284,285,1,0,0,0,285,287,1,0,0,
  	0,286,288,3,14,7,0,287,286,1,0,0,0,287,288,1,0,0,0,288,289,1,0,0,0,289,
  	290,3,24,12,0,290,11,1,0,0,0,291,293,5,41,0,0,292,294,3,18,9,0,293,292,
  	1,0,0,0,293,294,1,0,0,0,294,295,1,0,0,0,295,296,5,13,0,0,296,13,1,0,0,
  	0,297,301,5,47,0,0,298,300,3,16,8,0,299,298,1,0,0,0,300,303,1,0,0,0,301,
  	299,1,0,0,0,301,302,1,0,0,0,302,304,1,0,0,0,303,301,1,0,0,0,304,305,5,
  	13,0,0,305,15,1,0,0,0,306,307,3,18,9,0,307,308,5,43,0,0,308,309,3,4,2,
  	0,309,17,1,0,0,0,310,315,3,22,11,0,311,312,5,1,0,0,312,314,3,22,11,0,
  	313,311,1,0,0,0,314,317,1,0,0,0,315,313,1,0,0,0,315,316,1,0,0,0,316,19,
  	1,0,0,0,317,315,1,0,0,0,318,319,5,5,0,0,319,320,3,18,9,0,320,321,5,10,
  	0,0,321,21,1,0,0,0,322,325,5,106,0,0,323,325,3,172,86,0,324,322,1,0,0,
  	0,324,323,1,0,0,0,325,23,1,0,0,0,326,328,3,26,13,0,327,326,1,0,0,0,328,
  	329,1,0,0,0,329,327,1,0,0,0,329,330,1,0,0,0,330,25,1,0,0,0,331,335,3,
  	28,14,0,332,335,3,36,18,0,333,335,3,134,67,0,334,331,1,0,0,0,334,332,
  	1,0,0,0,334,333,1,0,0,0,335,337,1,0,0,0,336,338,5,13,0,0,337,336,1,0,
  	0,0,337,338,1,0,0,0,338,27,1,0,0,0,339,340,3,30,15,0,340,341,5,53,0,0,
  	341,342,5,2,0,0,342,343,3,32,16,0,343,29,1,0,0,0,344,347,5,106,0,0,345,
  	347,3,172,86,0,346,344,1,0,0,0,346,345,1,0,0,0,347,31,1,0,0,0,348,352,
  	5,22,0,0,349,351,3,34,17,0,350,349,1,0,0,0,351,354,1,0,0,0,352,350,1,
  	0,0,0,352,353,1,0,0,0,353,355,1,0,0,0,354,352,1,0,0,0,355,360,5,37,0,
  	0,356,357,3,6,3,0,357,358,3,30,15,0,358,360,1,0,0,0,359,348,1,0,0,0,359,
  	356,1,0,0,0,360,33,1,0,0,0,361,362,7,0,0,0,362,35,1,0,0,0,363,364,5,106,
  	0,0,364,365,5,2,0,0,365,366,3,38,19,0,366,37,1,0,0,0,367,371,3,42,21,
  	0,368,371,3,40,20,0,369,371,3,170,85,0,370,367,1,0,0,0,370,368,1,0,0,
  	0,370,369,1,0,0,0,371,39,1,0,0,0,372,374,3,6,3,0,373,372,1,0,0,0,373,
  	374,1,0,0,0,374,375,1,0,0,0,375,377,5,106,0,0,376,378,3,94,47,0,377,376,
  	1,0,0,0,377,378,1,0,0,0,378,41,1,0,0,0,379,397,3,44,22,0,380,397,3,46,
  	23,0,381,397,3,48,24,0,382,397,3,52,26,0,383,397,3,54,27,0,384,397,3,
  	56,28,0,385,397,3,58,29,0,386,397,3,60,30,0,387,397,3,64,32,0,388,397,
  	3,66,33,0,389,397,3,68,34,0,390,397,3,70,35,0,391,397,3,72,36,0,392,397,
  	3,74,37,0,393,397,3,76,38,0,394,397,3,78,39,0,395,397,3,86,43,0,396,379,
  	1,0,0,0,396,380,1,0,0,0,396,381,1,0,0,0,396,382,1,0,0,0,396,383,1,0,0,
  	0,396,384,1,0,0,0,396,385,1,0,0,0,396,386,1,0,0,0,396,387,1,0,0,0,396,
  	388,1,0,0,0,396,389,1,0,0,0,396,390,1,0,0,0,396,391,1,0,0,0,396,392,1,
  	0,0,0,396,393,1,0,0,0,396,394,1,0,0,0,396,395,1,0,0,0,397,43,1,0,0,0,
  	398,399,5,66,0,0,399,45,1,0,0,0,400,401,5,25,0,0,401,47,1,0,0,0,402,403,
  	5,83,0,0,403,49,1,0,0,0,404,405,7,1,0,0,405,51,1,0,0,0,406,408,5,50,0,
  	0,407,409,3,94,47,0,408,407,1,0,0,0,408,409,1,0,0,0,409,53,1,0,0,0,410,
  	411,5,67,0,0,411,412,5,45,0,0,412,55,1,0,0,0,413,414,5,72,0,0,414,416,
  	5,90,0,0,415,417,3,102,51,0,416,415,1,0,0,0,416,417,1,0,0,0,417,57,1,
  	0,0,0,418,419,5,23,0,0,419,421,5,90,0,0,420,422,3,94,47,0,421,420,1,0,
  	0,0,421,422,1,0,0,0,422,59,1,0,0,0,423,425,5,24,0,0,424,426,3,94,47,0,
  	425,424,1,0,0,0,425,426,1,0,0,0,426,61,1,0,0,0,427,429,5,5,0,0,428,430,
  	3,88,44,0,429,428,1,0,0,0,429,430,1,0,0,0,430,431,1,0,0,0,431,432,5,10,
  	0,0,432,63,1,0,0,0,433,434,5,86,0,0,434,435,3,62,31,0,435,65,1,0,0,0,
  	436,438,5,86,0,0,437,439,3,102,51,0,438,437,1,0,0,0,438,439,1,0,0,0,439,
  	440,1,0,0,0,440,441,5,73,0,0,441,442,3,38,19,0,442,67,1,0,0,0,443,444,
  	5,87,0,0,444,446,5,5,0,0,445,447,3,88,44,0,446,445,1,0,0,0,446,447,1,
  	0,0,0,447,448,1,0,0,0,448,449,5,10,0,0,449,69,1,0,0,0,450,452,5,87,0,
  	0,451,453,3,116,58,0,452,451,1,0,0,0,452,453,1,0,0,0,453,454,1,0,0,0,
  	454,455,5,73,0,0,455,456,3,38,19,0,456,71,1,0,0,0,457,458,5,27,0,0,458,
  	459,5,5,0,0,459,460,3,88,44,0,460,461,5,10,0,0,461,73,1,0,0,0,462,463,
  	5,39,0,0,463,464,3,96,48,0,464,75,1,0,0,0,465,466,5,106,0,0,466,467,5,
  	8,0,0,467,468,3,38,19,0,468,77,1,0,0,0,469,470,3,80,40,0,470,471,3,84,
  	42,0,471,472,3,38,19,0,472,79,1,0,0,0,473,475,5,6,0,0,474,476,3,82,41,
  	0,475,474,1,0,0,0,475,476,1,0,0,0,476,477,1,0,0,0,477,478,5,108,0,0,478,
  	479,5,11,0,0,479,81,1,0,0,0,480,481,7,2,0,0,481,83,1,0,0,0,482,483,7,
  	3,0,0,483,85,1,0,0,0,484,488,5,20,0,0,485,486,5,32,0,0,486,487,5,26,0,
  	0,487,489,5,106,0,0,488,485,1,0,0,0,488,489,1,0,0,0,489,87,1,0,0,0,490,
  	495,3,90,45,0,491,492,5,1,0,0,492,494,3,90,45,0,493,491,1,0,0,0,494,497,
  	1,0,0,0,495,493,1,0,0,0,495,496,1,0,0,0,496,89,1,0,0,0,497,495,1,0,0,
  	0,498,500,5,106,0,0,499,498,1,0,0,0,499,500,1,0,0,0,500,501,1,0,0,0,501,
  	503,3,38,19,0,502,504,3,92,46,0,503,502,1,0,0,0,503,504,1,0,0,0,504,512,
  	1,0,0,0,505,507,5,106,0,0,506,505,1,0,0,0,506,507,1,0,0,0,507,508,1,0,
  	0,0,508,509,5,29,0,0,509,510,5,73,0,0,510,512,3,38,19,0,511,499,1,0,0,
  	0,511,506,1,0,0,0,512,91,1,0,0,0,513,520,5,74,0,0,514,516,5,31,0,0,515,
  	517,5,106,0,0,516,515,1,0,0,0,516,517,1,0,0,0,517,518,1,0,0,0,518,520,
  	3,136,68,0,519,513,1,0,0,0,519,514,1,0,0,0,520,93,1,0,0,0,521,524,3,96,
  	48,0,522,524,3,102,51,0,523,521,1,0,0,0,523,522,1,0,0,0,524,95,1,0,0,
  	0,525,526,5,5,0,0,526,531,3,98,49,0,527,528,5,1,0,0,528,530,3,98,49,0,
  	529,527,1,0,0,0,530,533,1,0,0,0,531,529,1,0,0,0,531,532,1,0,0,0,532,534,
  	1,0,0,0,533,531,1,0,0,0,534,535,5,10,0,0,535,97,1,0,0,0,536,537,5,106,
  	0,0,537,538,5,7,0,0,538,539,3,100,50,0,539,540,5,12,0,0,540,99,1,0,0,
  	0,541,546,5,108,0,0,542,546,3,150,75,0,543,546,3,152,76,0,544,546,3,138,
  	69,0,545,541,1,0,0,0,545,542,1,0,0,0,545,543,1,0,0,0,545,544,1,0,0,0,
  	546,101,1,0,0,0,547,548,5,7,0,0,548,553,3,104,52,0,549,550,5,15,0,0,550,
  	552,3,104,52,0,551,549,1,0,0,0,552,555,1,0,0,0,553,551,1,0,0,0,553,554,
  	1,0,0,0,554,556,1,0,0,0,555,553,1,0,0,0,556,557,5,12,0,0,557,103,1,0,
  	0,0,558,564,3,108,54,0,559,564,3,116,58,0,560,564,3,118,59,0,561,564,
  	3,120,60,0,562,564,3,122,61,0,563,558,1,0,0,0,563,559,1,0,0,0,563,560,
  	1,0,0,0,563,561,1,0,0,0,563,562,1,0,0,0,564,105,1,0,0,0,565,566,5,7,0,
  	0,566,571,3,108,54,0,567,568,5,15,0,0,568,570,3,108,54,0,569,567,1,0,
  	0,0,570,573,1,0,0,0,571,569,1,0,0,0,571,572,1,0,0,0,572,574,1,0,0,0,573,
  	571,1,0,0,0,574,575,5,12,0,0,575,107,1,0,0,0,576,578,3,112,56,0,577,579,
  	3,110,55,0,578,577,1,0,0,0,578,579,1,0,0,0,579,109,1,0,0,0,580,582,5,
  	8,0,0,581,580,1,0,0,0,581,582,1,0,0,0,582,583,1,0,0,0,583,585,5,4,0,0,
  	584,586,5,8,0,0,585,584,1,0,0,0,585,586,1,0,0,0,586,587,1,0,0,0,587,588,
  	3,114,57,0,588,111,1,0,0,0,589,592,3,136,68,0,590,592,5,56,0,0,591,589,
  	1,0,0,0,591,590,1,0,0,0,592,113,1,0,0,0,593,596,3,136,68,0,594,596,5,
  	54,0,0,595,593,1,0,0,0,595,594,1,0,0,0,596,115,1,0,0,0,597,598,5,88,0,
  	0,598,599,3,106,53,0,599,117,1,0,0,0,600,601,5,43,0,0,601,602,3,106,53,
  	0,602,119,1,0,0,0,603,604,5,48,0,0,604,605,3,38,19,0,605,121,1,0,0,0,
  	606,607,5,101,0,0,607,608,5,28,0,0,608,613,3,94,47,0,609,610,5,101,0,
  	0,610,611,5,29,0,0,611,613,3,124,62,0,612,606,1,0,0,0,612,609,1,0,0,0,
  	613,123,1,0,0,0,614,628,5,5,0,0,615,619,3,128,64,0,616,618,3,126,63,0,
  	617,616,1,0,0,0,618,621,1,0,0,0,619,617,1,0,0,0,619,620,1,0,0,0,620,629,
  	1,0,0,0,621,619,1,0,0,0,622,624,5,14,0,0,623,625,3,126,63,0,624,623,1,
  	0,0,0,625,626,1,0,0,0,626,624,1,0,0,0,626,627,1,0,0,0,627,629,1,0,0,0,
  	628,615,1,0,0,0,628,622,1,0,0,0,629,630,1,0,0,0,630,631,5,10,0,0,631,
  	125,1,0,0,0,632,634,5,1,0,0,633,635,3,128,64,0,634,633,1,0,0,0,634,635,
  	1,0,0,0,635,127,1,0,0,0,636,638,5,106,0,0,637,639,3,130,65,0,638,637,
  	1,0,0,0,638,639,1,0,0,0,639,642,1,0,0,0,640,642,3,130,65,0,641,636,1,
  	0,0,0,641,640,1,0,0,0,642,129,1,0,0,0,643,645,3,94,47,0,644,646,3,132,
  	66,0,645,644,1,0,0,0,645,646,1,0,0,0,646,649,1,0,0,0,647,649,3,132,66,
  	0,648,643,1,0,0,0,648,647,1,0,0,0,649,131,1,0,0,0,650,651,7,4,0,0,651,
  	133,1,0,0,0,652,653,5,106,0,0,653,654,3,38,19,0,654,655,5,2,0,0,655,656,
  	3,136,68,0,656,135,1,0,0,0,657,660,3,140,70,0,658,660,3,138,69,0,659,
  	657,1,0,0,0,659,658,1,0,0,0,660,137,1,0,0,0,661,669,5,107,0,0,662,669,
  	5,103,0,0,663,669,5,104,0,0,664,666,3,6,3,0,665,664,1,0,0,0,665,666,1,
  	0,0,0,666,667,1,0,0,0,667,669,5,106,0,0,668,661,1,0,0,0,668,662,1,0,0,
  	0,668,663,1,0,0,0,668,665,1,0,0,0,669,139,1,0,0,0,670,679,3,142,71,0,
  	671,679,3,144,72,0,672,679,3,146,73,0,673,679,3,148,74,0,674,679,3,150,
  	75,0,675,679,3,152,76,0,676,679,3,154,77,0,677,679,3,156,78,0,678,670,
  	1,0,0,0,678,671,1,0,0,0,678,672,1,0,0,0,678,673,1,0,0,0,678,674,1,0,0,
  	0,678,675,1,0,0,0,678,676,1,0,0,0,678,677,1,0,0,0,679,141,1,0,0,0,680,
  	681,5,66,0,0,681,143,1,0,0,0,682,683,7,5,0,0,683,145,1,0,0,0,684,685,
  	7,6,0,0,685,147,1,0,0,0,686,688,5,9,0,0,687,686,1,0,0,0,687,688,1,0,0,
  	0,688,689,1,0,0,0,689,690,5,108,0,0,690,149,1,0,0,0,691,692,5,103,0,0,
  	692,151,1,0,0,0,693,694,5,104,0,0,694,153,1,0,0,0,695,696,5,105,0,0,696,
  	155,1,0,0,0,697,698,3,162,81,0,698,157,1,0,0,0,699,700,3,162,81,0,700,
  	159,1,0,0,0,701,702,3,162,81,0,702,161,1,0,0,0,703,707,5,5,0,0,704,706,
  	3,164,82,0,705,704,1,0,0,0,706,709,1,0,0,0,707,705,1,0,0,0,707,708,1,
  	0,0,0,708,710,1,0,0,0,709,707,1,0,0,0,710,711,5,10,0,0,711,163,1,0,0,
  	0,712,714,5,1,0,0,713,712,1,0,0,0,713,714,1,0,0,0,714,715,1,0,0,0,715,
  	716,3,166,83,0,716,165,1,0,0,0,717,721,5,108,0,0,718,721,5,106,0,0,719,
  	721,3,168,84,0,720,717,1,0,0,0,720,718,1,0,0,0,720,719,1,0,0,0,721,167,
  	1,0,0,0,722,723,5,106,0,0,723,726,5,7,0,0,724,727,5,108,0,0,725,727,3,
  	138,69,0,726,724,1,0,0,0,726,725,1,0,0,0,727,728,1,0,0,0,728,729,5,12,
  	0,0,729,169,1,0,0,0,730,741,3,178,89,0,731,741,3,180,90,0,732,741,3,182,
  	91,0,733,741,3,184,92,0,734,741,3,186,93,0,735,741,3,188,94,0,736,741,
  	3,190,95,0,737,741,3,192,96,0,738,741,3,194,97,0,739,741,3,196,98,0,740,
  	730,1,0,0,0,740,731,1,0,0,0,740,732,1,0,0,0,740,733,1,0,0,0,740,734,1,
  	0,0,0,740,735,1,0,0,0,740,736,1,0,0,0,740,737,1,0,0,0,740,738,1,0,0,0,
  	740,739,1,0,0,0,741,171,1,0,0,0,742,743,7,7,0,0,743,173,1,0,0,0,744,745,
  	3,242,121,0,745,747,3,212,106,0,746,748,3,238,119,0,747,746,1,0,0,0,747,
  	748,1,0,0,0,748,175,1,0,0,0,749,750,3,232,116,0,750,751,3,174,87,0,751,
  	177,1,0,0,0,752,753,5,61,0,0,753,754,3,248,124,0,754,755,3,234,117,0,
  	755,756,3,208,104,0,756,760,3,212,106,0,757,759,3,240,120,0,758,757,1,
  	0,0,0,759,762,1,0,0,0,760,758,1,0,0,0,760,761,1,0,0,0,761,179,1,0,0,0,
  	762,760,1,0,0,0,763,764,5,69,0,0,764,765,3,174,87,0,765,181,1,0,0,0,766,
  	767,5,70,0,0,767,769,3,244,122,0,768,770,3,246,123,0,769,768,1,0,0,0,
  	769,770,1,0,0,0,770,772,1,0,0,0,771,773,3,206,103,0,772,771,1,0,0,0,772,
  	773,1,0,0,0,773,774,1,0,0,0,774,775,3,220,110,0,775,776,3,242,121,0,776,
  	778,3,212,106,0,777,779,3,218,109,0,778,777,1,0,0,0,778,779,1,0,0,0,779,
  	781,1,0,0,0,780,782,3,210,105,0,781,780,1,0,0,0,781,782,1,0,0,0,782,183,
  	1,0,0,0,783,784,5,64,0,0,784,785,3,176,88,0,785,185,1,0,0,0,786,787,5,
  	95,0,0,787,789,3,216,108,0,788,790,3,250,125,0,789,788,1,0,0,0,789,790,
  	1,0,0,0,790,791,1,0,0,0,791,793,3,212,106,0,792,794,3,238,119,0,793,792,
  	1,0,0,0,793,794,1,0,0,0,794,187,1,0,0,0,795,796,5,94,0,0,796,797,3,174,
  	87,0,797,798,3,244,122,0,798,189,1,0,0,0,799,800,5,68,0,0,800,801,3,176,
  	88,0,801,191,1,0,0,0,802,803,5,63,0,0,803,805,3,230,115,0,804,806,3,244,
  	122,0,805,804,1,0,0,0,805,806,1,0,0,0,806,808,1,0,0,0,807,809,3,220,110,
  	0,808,807,1,0,0,0,808,809,1,0,0,0,809,810,1,0,0,0,810,811,3,242,121,0,
  	811,812,3,212,106,0,812,193,1,0,0,0,813,814,5,60,0,0,814,818,3,174,87,
  	0,815,817,3,204,102,0,816,815,1,0,0,0,817,820,1,0,0,0,818,816,1,0,0,0,
  	818,819,1,0,0,0,819,824,1,0,0,0,820,818,1,0,0,0,821,822,5,58,0,0,822,
  	825,3,222,111,0,823,825,3,228,114,0,824,821,1,0,0,0,824,823,1,0,0,0,825,
  	195,1,0,0,0,826,827,5,19,0,0,827,828,3,236,118,0,828,832,3,174,87,0,829,
  	831,3,198,99,0,830,829,1,0,0,0,831,834,1,0,0,0,832,830,1,0,0,0,832,833,
  	1,0,0,0,833,197,1,0,0,0,834,832,1,0,0,0,835,836,5,91,0,0,836,837,3,4,
  	2,0,837,839,3,200,100,0,838,840,3,202,101,0,839,838,1,0,0,0,839,840,1,
  	0,0,0,840,199,1,0,0,0,841,842,5,48,0,0,842,843,3,18,9,0,843,201,1,0,0,
  	0,844,845,5,100,0,0,845,854,5,106,0,0,846,855,3,244,122,0,847,849,3,252,
  	126,0,848,847,1,0,0,0,848,849,1,0,0,0,849,850,1,0,0,0,850,852,3,206,103,
  	0,851,853,3,210,105,0,852,851,1,0,0,0,852,853,1,0,0,0,853,855,1,0,0,0,
  	854,846,1,0,0,0,854,848,1,0,0,0,855,203,1,0,0,0,856,857,5,44,0,0,857,
  	858,5,106,0,0,858,860,3,212,106,0,859,861,3,238,119,0,860,859,1,0,0,0,
  	860,861,1,0,0,0,861,205,1,0,0,0,862,863,5,18,0,0,863,864,5,106,0,0,864,
  	207,1,0,0,0,865,866,5,30,0,0,866,867,5,105,0,0,867,209,1,0,0,0,868,869,
  	5,34,0,0,869,870,5,5,0,0,870,871,3,136,68,0,871,872,5,10,0,0,872,211,
  	1,0,0,0,873,874,5,35,0,0,874,875,5,105,0,0,875,213,1,0,0,0,876,877,5,
  	36,0,0,877,878,5,105,0,0,878,215,1,0,0,0,879,880,5,38,0,0,880,881,3,88,
  	44,0,881,217,1,0,0,0,882,883,5,49,0,0,883,886,3,62,31,0,884,886,3,88,
  	44,0,885,882,1,0,0,0,885,884,1,0,0,0,886,219,1,0,0,0,887,888,5,55,0,0,
  	888,889,3,50,25,0,889,221,1,0,0,0,890,891,5,52,0,0,891,892,5,5,0,0,892,
  	893,3,18,9,0,893,894,5,10,0,0,894,223,1,0,0,0,895,896,5,5,0,0,896,897,
  	3,18,9,0,897,898,5,10,0,0,898,225,1,0,0,0,899,900,3,6,3,0,900,901,3,224,
  	112,0,901,227,1,0,0,0,902,903,5,59,0,0,903,904,5,5,0,0,904,909,3,226,
  	113,0,905,906,5,1,0,0,906,908,3,226,113,0,907,905,1,0,0,0,908,911,1,0,
  	0,0,909,907,1,0,0,0,909,910,1,0,0,0,910,912,1,0,0,0,911,909,1,0,0,0,912,
  	913,5,10,0,0,913,229,1,0,0,0,914,915,5,65,0,0,915,916,5,5,0,0,916,917,
  	3,18,9,0,917,918,5,10,0,0,918,231,1,0,0,0,919,920,5,71,0,0,920,921,5,
  	5,0,0,921,922,3,18,9,0,922,923,5,10,0,0,923,233,1,0,0,0,924,925,5,75,
  	0,0,925,926,5,105,0,0,926,235,1,0,0,0,927,928,5,79,0,0,928,929,5,105,
  	0,0,929,237,1,0,0,0,930,931,5,84,0,0,931,932,5,105,0,0,932,239,1,0,0,
  	0,933,934,5,85,0,0,934,935,5,105,0,0,935,936,5,35,0,0,936,937,5,105,0,
  	0,937,241,1,0,0,0,938,939,5,89,0,0,939,940,5,106,0,0,940,243,1,0,0,0,
  	941,942,5,92,0,0,942,943,3,38,19,0,943,245,1,0,0,0,944,945,5,97,0,0,945,
  	946,5,105,0,0,946,247,1,0,0,0,947,948,5,51,0,0,948,949,5,105,0,0,949,
  	249,1,0,0,0,950,951,5,99,0,0,951,952,3,88,44,0,952,251,1,0,0,0,953,954,
  	5,102,0,0,954,955,3,38,19,0,955,253,1,0,0,0,88,257,262,267,273,281,284,
  	287,293,301,315,324,329,334,337,346,352,359,370,373,377,396,408,416,421,
  	425,429,438,446,452,475,488,495,499,503,506,511,516,519,523,531,545,553,
  	563,571,578,581,585,591,595,612,619,626,628,634,638,641,645,648,659,665,
  	668,678,687,707,713,720,726,740,747,760,769,772,778,781,789,793,805,808,
  	818,824,832,839,848,852,854,860,885,909
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  mibParserStaticData = std::move(staticData);
}

}

MIBParser::MIBParser(TokenStream *input) : MIBParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

MIBParser::MIBParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  MIBParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *mibParserStaticData->atn, mibParserStaticData->decisionToDFA, mibParserStaticData->sharedContextCache, options);
}

MIBParser::~MIBParser() {
  delete _interpreter;
}

const atn::ATN& MIBParser::getATN() const {
  return *mibParserStaticData->atn;
}

std::string MIBParser::getGrammarFileName() const {
  return "MIB.g4";
}

const std::vector<std::string>& MIBParser::getRuleNames() const {
  return mibParserStaticData->ruleNames;
}

const dfa::Vocabulary& MIBParser::getVocabulary() const {
  return mibParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView MIBParser::getSerializedATN() const {
  return mibParserStaticData->serializedATN;
}


//----------------- DataContext ------------------------------------------------------------------

MIBParser::DataContext::DataContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MIBParser::ModuleDefinitionContext *> MIBParser::DataContext::moduleDefinition() {
  return getRuleContexts<MIBParser::ModuleDefinitionContext>();
}

MIBParser::ModuleDefinitionContext* MIBParser::DataContext::moduleDefinition(size_t i) {
  return getRuleContext<MIBParser::ModuleDefinitionContext>(i);
}


size_t MIBParser::DataContext::getRuleIndex() const {
  return MIBParser::RuleData;
}

void MIBParser::DataContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterData(this);
}

void MIBParser::DataContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitData(this);
}

MIBParser::DataContext* MIBParser::data() {
  DataContext *_localctx = _tracker.createInstance<DataContext>(_ctx, getState());
  enterRule(_localctx, 0, MIBParser::RuleData);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(255); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(254);
      moduleDefinition();
      setState(257); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MIBParser::IDENTIFIER_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleDefinitionContext ------------------------------------------------------------------

MIBParser::ModuleDefinitionContext::ModuleDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::ModuleIdentifierContext* MIBParser::ModuleDefinitionContext::moduleIdentifier() {
  return getRuleContext<MIBParser::ModuleIdentifierContext>(0);
}

tree::TerminalNode* MIBParser::ModuleDefinitionContext::DEFINITIONS() {
  return getToken(MIBParser::DEFINITIONS, 0);
}

tree::TerminalNode* MIBParser::ModuleDefinitionContext::DEFINITION() {
  return getToken(MIBParser::DEFINITION, 0);
}

tree::TerminalNode* MIBParser::ModuleDefinitionContext::BEGIN() {
  return getToken(MIBParser::BEGIN, 0);
}

tree::TerminalNode* MIBParser::ModuleDefinitionContext::END() {
  return getToken(MIBParser::END, 0);
}

MIBParser::TagDefaultContext* MIBParser::ModuleDefinitionContext::tagDefault() {
  return getRuleContext<MIBParser::TagDefaultContext>(0);
}

MIBParser::ModuleBodyContext* MIBParser::ModuleDefinitionContext::moduleBody() {
  return getRuleContext<MIBParser::ModuleBodyContext>(0);
}


size_t MIBParser::ModuleDefinitionContext::getRuleIndex() const {
  return MIBParser::RuleModuleDefinition;
}

void MIBParser::ModuleDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleDefinition(this);
}

void MIBParser::ModuleDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleDefinition(this);
}

MIBParser::ModuleDefinitionContext* MIBParser::moduleDefinition() {
  ModuleDefinitionContext *_localctx = _tracker.createInstance<ModuleDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 2, MIBParser::RuleModuleDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(259);
    moduleIdentifier();
    setState(260);
    match(MIBParser::DEFINITIONS);
    setState(262);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::EXPLICIT

    || _la == MIBParser::IMPLICIT) {
      setState(261);
      tagDefault();
    }
    setState(264);
    match(MIBParser::DEFINITION);
    setState(265);
    match(MIBParser::BEGIN);
    setState(267);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -5764464586522099712) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 4401267736689) != 0)) {
      setState(266);
      moduleBody();
    }
    setState(269);
    match(MIBParser::END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleIdentifierContext ------------------------------------------------------------------

MIBParser::ModuleIdentifierContext::ModuleIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ModuleIdentifierContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::ObjectIdentifierValueContext* MIBParser::ModuleIdentifierContext::objectIdentifierValue() {
  return getRuleContext<MIBParser::ObjectIdentifierValueContext>(0);
}


size_t MIBParser::ModuleIdentifierContext::getRuleIndex() const {
  return MIBParser::RuleModuleIdentifier;
}

void MIBParser::ModuleIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleIdentifier(this);
}

void MIBParser::ModuleIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleIdentifier(this);
}

MIBParser::ModuleIdentifierContext* MIBParser::moduleIdentifier() {
  ModuleIdentifierContext *_localctx = _tracker.createInstance<ModuleIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 4, MIBParser::RuleModuleIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(271);
    match(MIBParser::IDENTIFIER_STRING);
    setState(273);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LEFT_BRACE) {
      setState(272);
      objectIdentifierValue();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleReferenceContext ------------------------------------------------------------------

MIBParser::ModuleReferenceContext::ModuleReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ModuleReferenceContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}


size_t MIBParser::ModuleReferenceContext::getRuleIndex() const {
  return MIBParser::RuleModuleReference;
}

void MIBParser::ModuleReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleReference(this);
}

void MIBParser::ModuleReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleReference(this);
}

MIBParser::ModuleReferenceContext* MIBParser::moduleReference() {
  ModuleReferenceContext *_localctx = _tracker.createInstance<ModuleReferenceContext>(_ctx, getState());
  enterRule(_localctx, 6, MIBParser::RuleModuleReference);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(275);
    match(MIBParser::IDENTIFIER_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TagDefaultContext ------------------------------------------------------------------

MIBParser::TagDefaultContext::TagDefaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::TagDefaultContext::EXPLICIT() {
  return getToken(MIBParser::EXPLICIT, 0);
}

tree::TerminalNode* MIBParser::TagDefaultContext::TAGS() {
  return getToken(MIBParser::TAGS, 0);
}

tree::TerminalNode* MIBParser::TagDefaultContext::IMPLICIT() {
  return getToken(MIBParser::IMPLICIT, 0);
}


size_t MIBParser::TagDefaultContext::getRuleIndex() const {
  return MIBParser::RuleTagDefault;
}

void MIBParser::TagDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTagDefault(this);
}

void MIBParser::TagDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTagDefault(this);
}

MIBParser::TagDefaultContext* MIBParser::tagDefault() {
  TagDefaultContext *_localctx = _tracker.createInstance<TagDefaultContext>(_ctx, getState());
  enterRule(_localctx, 8, MIBParser::RuleTagDefault);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(281);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::EXPLICIT: {
        enterOuterAlt(_localctx, 1);
        setState(277);
        match(MIBParser::EXPLICIT);
        setState(278);
        match(MIBParser::TAGS);
        break;
      }

      case MIBParser::IMPLICIT: {
        enterOuterAlt(_localctx, 2);
        setState(279);
        match(MIBParser::IMPLICIT);
        setState(280);
        match(MIBParser::TAGS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleBodyContext ------------------------------------------------------------------

MIBParser::ModuleBodyContext::ModuleBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::AssignmentListContext* MIBParser::ModuleBodyContext::assignmentList() {
  return getRuleContext<MIBParser::AssignmentListContext>(0);
}

MIBParser::ExportListContext* MIBParser::ModuleBodyContext::exportList() {
  return getRuleContext<MIBParser::ExportListContext>(0);
}

MIBParser::ImportListContext* MIBParser::ModuleBodyContext::importList() {
  return getRuleContext<MIBParser::ImportListContext>(0);
}


size_t MIBParser::ModuleBodyContext::getRuleIndex() const {
  return MIBParser::RuleModuleBody;
}

void MIBParser::ModuleBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleBody(this);
}

void MIBParser::ModuleBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleBody(this);
}

MIBParser::ModuleBodyContext* MIBParser::moduleBody() {
  ModuleBodyContext *_localctx = _tracker.createInstance<ModuleBodyContext>(_ctx, getState());
  enterRule(_localctx, 10, MIBParser::RuleModuleBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(284);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::EXPORTS) {
      setState(283);
      exportList();
    }
    setState(287);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::IMPORTS) {
      setState(286);
      importList();
    }
    setState(289);
    assignmentList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportListContext ------------------------------------------------------------------

MIBParser::ExportListContext::ExportListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ExportListContext::EXPORTS() {
  return getToken(MIBParser::EXPORTS, 0);
}

tree::TerminalNode* MIBParser::ExportListContext::SEMI_COLON() {
  return getToken(MIBParser::SEMI_COLON, 0);
}

MIBParser::SymbolListContext* MIBParser::ExportListContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}


size_t MIBParser::ExportListContext::getRuleIndex() const {
  return MIBParser::RuleExportList;
}

void MIBParser::ExportListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExportList(this);
}

void MIBParser::ExportListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExportList(this);
}

MIBParser::ExportListContext* MIBParser::exportList() {
  ExportListContext *_localctx = _tracker.createInstance<ExportListContext>(_ctx, getState());
  enterRule(_localctx, 12, MIBParser::RuleExportList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(291);
    match(MIBParser::EXPORTS);
    setState(293);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -5764607523033710592) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 4401267736689) != 0)) {
      setState(292);
      symbolList();
    }
    setState(295);
    match(MIBParser::SEMI_COLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportListContext ------------------------------------------------------------------

MIBParser::ImportListContext::ImportListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ImportListContext::IMPORTS() {
  return getToken(MIBParser::IMPORTS, 0);
}

tree::TerminalNode* MIBParser::ImportListContext::SEMI_COLON() {
  return getToken(MIBParser::SEMI_COLON, 0);
}

std::vector<MIBParser::SymbolsFromModuleContext *> MIBParser::ImportListContext::symbolsFromModule() {
  return getRuleContexts<MIBParser::SymbolsFromModuleContext>();
}

MIBParser::SymbolsFromModuleContext* MIBParser::ImportListContext::symbolsFromModule(size_t i) {
  return getRuleContext<MIBParser::SymbolsFromModuleContext>(i);
}


size_t MIBParser::ImportListContext::getRuleIndex() const {
  return MIBParser::RuleImportList;
}

void MIBParser::ImportListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportList(this);
}

void MIBParser::ImportListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportList(this);
}

MIBParser::ImportListContext* MIBParser::importList() {
  ImportListContext *_localctx = _tracker.createInstance<ImportListContext>(_ctx, getState());
  enterRule(_localctx, 14, MIBParser::RuleImportList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(297);
    match(MIBParser::IMPORTS);
    setState(301);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -5764607523033710592) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 4401267736689) != 0)) {
      setState(298);
      symbolsFromModule();
      setState(303);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(304);
    match(MIBParser::SEMI_COLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolsFromModuleContext ------------------------------------------------------------------

MIBParser::SymbolsFromModuleContext::SymbolsFromModuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::SymbolListContext* MIBParser::SymbolsFromModuleContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}

tree::TerminalNode* MIBParser::SymbolsFromModuleContext::FROM() {
  return getToken(MIBParser::FROM, 0);
}

MIBParser::ModuleIdentifierContext* MIBParser::SymbolsFromModuleContext::moduleIdentifier() {
  return getRuleContext<MIBParser::ModuleIdentifierContext>(0);
}


size_t MIBParser::SymbolsFromModuleContext::getRuleIndex() const {
  return MIBParser::RuleSymbolsFromModule;
}

void MIBParser::SymbolsFromModuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbolsFromModule(this);
}

void MIBParser::SymbolsFromModuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbolsFromModule(this);
}

MIBParser::SymbolsFromModuleContext* MIBParser::symbolsFromModule() {
  SymbolsFromModuleContext *_localctx = _tracker.createInstance<SymbolsFromModuleContext>(_ctx, getState());
  enterRule(_localctx, 16, MIBParser::RuleSymbolsFromModule);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(306);
    symbolList();
    setState(307);
    match(MIBParser::FROM);
    setState(308);
    moduleIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolListContext ------------------------------------------------------------------

MIBParser::SymbolListContext::SymbolListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MIBParser::SymbolContext *> MIBParser::SymbolListContext::symbol() {
  return getRuleContexts<MIBParser::SymbolContext>();
}

MIBParser::SymbolContext* MIBParser::SymbolListContext::symbol(size_t i) {
  return getRuleContext<MIBParser::SymbolContext>(i);
}

std::vector<tree::TerminalNode *> MIBParser::SymbolListContext::COMMA() {
  return getTokens(MIBParser::COMMA);
}

tree::TerminalNode* MIBParser::SymbolListContext::COMMA(size_t i) {
  return getToken(MIBParser::COMMA, i);
}


size_t MIBParser::SymbolListContext::getRuleIndex() const {
  return MIBParser::RuleSymbolList;
}

void MIBParser::SymbolListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbolList(this);
}

void MIBParser::SymbolListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbolList(this);
}

MIBParser::SymbolListContext* MIBParser::symbolList() {
  SymbolListContext *_localctx = _tracker.createInstance<SymbolListContext>(_ctx, getState());
  enterRule(_localctx, 18, MIBParser::RuleSymbolList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(310);
    symbol();
    setState(315);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(311);
        match(MIBParser::COMMA);
        setState(312);
        symbol(); 
      }
      setState(317);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolListBracedContext ------------------------------------------------------------------

MIBParser::SymbolListBracedContext::SymbolListBracedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SymbolListBracedContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

MIBParser::SymbolListContext* MIBParser::SymbolListBracedContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}

tree::TerminalNode* MIBParser::SymbolListBracedContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}


size_t MIBParser::SymbolListBracedContext::getRuleIndex() const {
  return MIBParser::RuleSymbolListBraced;
}

void MIBParser::SymbolListBracedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbolListBraced(this);
}

void MIBParser::SymbolListBracedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbolListBraced(this);
}

MIBParser::SymbolListBracedContext* MIBParser::symbolListBraced() {
  SymbolListBracedContext *_localctx = _tracker.createInstance<SymbolListBracedContext>(_ctx, getState());
  enterRule(_localctx, 20, MIBParser::RuleSymbolListBraced);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(318);
    match(MIBParser::LEFT_BRACE);
    setState(319);
    symbolList();
    setState(320);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolContext ------------------------------------------------------------------

MIBParser::SymbolContext::SymbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SymbolContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::DefinedMacroNameContext* MIBParser::SymbolContext::definedMacroName() {
  return getRuleContext<MIBParser::DefinedMacroNameContext>(0);
}


size_t MIBParser::SymbolContext::getRuleIndex() const {
  return MIBParser::RuleSymbol;
}

void MIBParser::SymbolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbol(this);
}

void MIBParser::SymbolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbol(this);
}

MIBParser::SymbolContext* MIBParser::symbol() {
  SymbolContext *_localctx = _tracker.createInstance<SymbolContext>(_ctx, getState());
  enterRule(_localctx, 22, MIBParser::RuleSymbol);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(324);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::IDENTIFIER_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(322);
        match(MIBParser::IDENTIFIER_STRING);
        break;
      }

      case MIBParser::AGENT_CAPABILITIES:
      case MIBParser::MODULE_COMPLIANCE:
      case MIBParser::MODULE_IDENTITY:
      case MIBParser::NOTIFICATION_GROUP:
      case MIBParser::NOTIFICATION_TYPE:
      case MIBParser::OBJECT_GROUP:
      case MIBParser::OBJECT_IDENTITY:
      case MIBParser::OBJECT_TYPE:
      case MIBParser::TEXTUAL_CONVENTION:
      case MIBParser::TRAP_TYPE: {
        enterOuterAlt(_localctx, 2);
        setState(323);
        definedMacroName();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentListContext ------------------------------------------------------------------

MIBParser::AssignmentListContext::AssignmentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MIBParser::AssignmentContext *> MIBParser::AssignmentListContext::assignment() {
  return getRuleContexts<MIBParser::AssignmentContext>();
}

MIBParser::AssignmentContext* MIBParser::AssignmentListContext::assignment(size_t i) {
  return getRuleContext<MIBParser::AssignmentContext>(i);
}


size_t MIBParser::AssignmentListContext::getRuleIndex() const {
  return MIBParser::RuleAssignmentList;
}

void MIBParser::AssignmentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentList(this);
}

void MIBParser::AssignmentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentList(this);
}

MIBParser::AssignmentListContext* MIBParser::assignmentList() {
  AssignmentListContext *_localctx = _tracker.createInstance<AssignmentListContext>(_ctx, getState());
  enterRule(_localctx, 24, MIBParser::RuleAssignmentList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(327); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(326);
      assignment();
      setState(329); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -5764607523033710592) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 4401267736689) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentContext ------------------------------------------------------------------

MIBParser::AssignmentContext::AssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::MacroDefinitionContext* MIBParser::AssignmentContext::macroDefinition() {
  return getRuleContext<MIBParser::MacroDefinitionContext>(0);
}

MIBParser::TypeAssignmentContext* MIBParser::AssignmentContext::typeAssignment() {
  return getRuleContext<MIBParser::TypeAssignmentContext>(0);
}

MIBParser::ValueAssignmentContext* MIBParser::AssignmentContext::valueAssignment() {
  return getRuleContext<MIBParser::ValueAssignmentContext>(0);
}

tree::TerminalNode* MIBParser::AssignmentContext::SEMI_COLON() {
  return getToken(MIBParser::SEMI_COLON, 0);
}


size_t MIBParser::AssignmentContext::getRuleIndex() const {
  return MIBParser::RuleAssignment;
}

void MIBParser::AssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment(this);
}

void MIBParser::AssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment(this);
}

MIBParser::AssignmentContext* MIBParser::assignment() {
  AssignmentContext *_localctx = _tracker.createInstance<AssignmentContext>(_ctx, getState());
  enterRule(_localctx, 26, MIBParser::RuleAssignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(334);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
    case 1: {
      setState(331);
      macroDefinition();
      break;
    }

    case 2: {
      setState(332);
      typeAssignment();
      break;
    }

    case 3: {
      setState(333);
      valueAssignment();
      break;
    }

    default:
      break;
    }
    setState(337);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::SEMI_COLON) {
      setState(336);
      match(MIBParser::SEMI_COLON);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroDefinitionContext ------------------------------------------------------------------

MIBParser::MacroDefinitionContext::MacroDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::MacroReferenceContext* MIBParser::MacroDefinitionContext::macroReference() {
  return getRuleContext<MIBParser::MacroReferenceContext>(0);
}

tree::TerminalNode* MIBParser::MacroDefinitionContext::MACRO() {
  return getToken(MIBParser::MACRO, 0);
}

tree::TerminalNode* MIBParser::MacroDefinitionContext::DEFINITION() {
  return getToken(MIBParser::DEFINITION, 0);
}

MIBParser::MacroBodyContext* MIBParser::MacroDefinitionContext::macroBody() {
  return getRuleContext<MIBParser::MacroBodyContext>(0);
}


size_t MIBParser::MacroDefinitionContext::getRuleIndex() const {
  return MIBParser::RuleMacroDefinition;
}

void MIBParser::MacroDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroDefinition(this);
}

void MIBParser::MacroDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroDefinition(this);
}

MIBParser::MacroDefinitionContext* MIBParser::macroDefinition() {
  MacroDefinitionContext *_localctx = _tracker.createInstance<MacroDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 28, MIBParser::RuleMacroDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(339);
    macroReference();
    setState(340);
    match(MIBParser::MACRO);
    setState(341);
    match(MIBParser::DEFINITION);
    setState(342);
    macroBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroReferenceContext ------------------------------------------------------------------

MIBParser::MacroReferenceContext::MacroReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::MacroReferenceContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::DefinedMacroNameContext* MIBParser::MacroReferenceContext::definedMacroName() {
  return getRuleContext<MIBParser::DefinedMacroNameContext>(0);
}


size_t MIBParser::MacroReferenceContext::getRuleIndex() const {
  return MIBParser::RuleMacroReference;
}

void MIBParser::MacroReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroReference(this);
}

void MIBParser::MacroReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroReference(this);
}

MIBParser::MacroReferenceContext* MIBParser::macroReference() {
  MacroReferenceContext *_localctx = _tracker.createInstance<MacroReferenceContext>(_ctx, getState());
  enterRule(_localctx, 30, MIBParser::RuleMacroReference);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(346);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::IDENTIFIER_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(344);
        match(MIBParser::IDENTIFIER_STRING);
        break;
      }

      case MIBParser::AGENT_CAPABILITIES:
      case MIBParser::MODULE_COMPLIANCE:
      case MIBParser::MODULE_IDENTITY:
      case MIBParser::NOTIFICATION_GROUP:
      case MIBParser::NOTIFICATION_TYPE:
      case MIBParser::OBJECT_GROUP:
      case MIBParser::OBJECT_IDENTITY:
      case MIBParser::OBJECT_TYPE:
      case MIBParser::TEXTUAL_CONVENTION:
      case MIBParser::TRAP_TYPE: {
        enterOuterAlt(_localctx, 2);
        setState(345);
        definedMacroName();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroBodyContext ------------------------------------------------------------------

MIBParser::MacroBodyContext::MacroBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::MacroBodyContext::BEGIN() {
  return getToken(MIBParser::BEGIN, 0);
}

tree::TerminalNode* MIBParser::MacroBodyContext::END() {
  return getToken(MIBParser::END, 0);
}

std::vector<MIBParser::MacroBodyElementContext *> MIBParser::MacroBodyContext::macroBodyElement() {
  return getRuleContexts<MIBParser::MacroBodyElementContext>();
}

MIBParser::MacroBodyElementContext* MIBParser::MacroBodyContext::macroBodyElement(size_t i) {
  return getRuleContext<MIBParser::MacroBodyElementContext>(i);
}

MIBParser::ModuleReferenceContext* MIBParser::MacroBodyContext::moduleReference() {
  return getRuleContext<MIBParser::ModuleReferenceContext>(0);
}

MIBParser::MacroReferenceContext* MIBParser::MacroBodyContext::macroReference() {
  return getRuleContext<MIBParser::MacroReferenceContext>(0);
}


size_t MIBParser::MacroBodyContext::getRuleIndex() const {
  return MIBParser::RuleMacroBody;
}

void MIBParser::MacroBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroBody(this);
}

void MIBParser::MacroBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroBody(this);
}

MIBParser::MacroBodyContext* MIBParser::macroBody() {
  MacroBodyContext *_localctx = _tracker.createInstance<MacroBodyContext>(_ctx, getState());
  enterRule(_localctx, 32, MIBParser::RuleMacroBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(359);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::BEGIN: {
        enterOuterAlt(_localctx, 1);
        setState(348);
        match(MIBParser::BEGIN);
        setState(352);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 1161084320911492) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 66)) & 1649284350019) != 0)) {
          setState(349);
          macroBodyElement();
          setState(354);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(355);
        match(MIBParser::END);
        break;
      }

      case MIBParser::IDENTIFIER_STRING: {
        enterOuterAlt(_localctx, 2);
        setState(356);
        moduleReference();
        setState(357);
        macroReference();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroBodyElementContext ------------------------------------------------------------------

MIBParser::MacroBodyElementContext::MacroBodyElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::LEFT_PAREN() {
  return getToken(MIBParser::LEFT_PAREN, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::RIGHT_PAREN() {
  return getToken(MIBParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::VERTICAL_BAR() {
  return getToken(MIBParser::VERTICAL_BAR, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::DEFINITION() {
  return getToken(MIBParser::DEFINITION, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::INTEGER() {
  return getToken(MIBParser::INTEGER, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::REAL() {
  return getToken(MIBParser::REAL, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::BOOLEAN() {
  return getToken(MIBParser::BOOLEAN, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::NULL_() {
  return getToken(MIBParser::NULL_, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::BIT() {
  return getToken(MIBParser::BIT, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::OCTET() {
  return getToken(MIBParser::OCTET, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::STRING() {
  return getToken(MIBParser::STRING, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::OBJECT() {
  return getToken(MIBParser::OBJECT, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::IDENTIFIER() {
  return getToken(MIBParser::IDENTIFIER, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::MacroBodyElementContext::getRuleIndex() const {
  return MIBParser::RuleMacroBodyElement;
}

void MIBParser::MacroBodyElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroBodyElement(this);
}

void MIBParser::MacroBodyElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroBodyElement(this);
}

MIBParser::MacroBodyElementContext* MIBParser::macroBodyElement() {
  MacroBodyElementContext *_localctx = _tracker.createInstance<MacroBodyElementContext>(_ctx, getState());
  enterRule(_localctx, 34, MIBParser::RuleMacroBodyElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(361);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1161084320911492) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & 1649284350019) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeAssignmentContext ------------------------------------------------------------------

MIBParser::TypeAssignmentContext::TypeAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::TypeAssignmentContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

tree::TerminalNode* MIBParser::TypeAssignmentContext::DEFINITION() {
  return getToken(MIBParser::DEFINITION, 0);
}

MIBParser::TypeContext* MIBParser::TypeAssignmentContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}


size_t MIBParser::TypeAssignmentContext::getRuleIndex() const {
  return MIBParser::RuleTypeAssignment;
}

void MIBParser::TypeAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeAssignment(this);
}

void MIBParser::TypeAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeAssignment(this);
}

MIBParser::TypeAssignmentContext* MIBParser::typeAssignment() {
  TypeAssignmentContext *_localctx = _tracker.createInstance<TypeAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 36, MIBParser::RuleTypeAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(363);
    match(MIBParser::IDENTIFIER_STRING);
    setState(364);
    match(MIBParser::DEFINITION);
    setState(365);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeContext ------------------------------------------------------------------

MIBParser::TypeContext::TypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::BuiltinTypeContext* MIBParser::TypeContext::builtinType() {
  return getRuleContext<MIBParser::BuiltinTypeContext>(0);
}

MIBParser::DefinedTypeContext* MIBParser::TypeContext::definedType() {
  return getRuleContext<MIBParser::DefinedTypeContext>(0);
}

MIBParser::DefinedMacroTypeContext* MIBParser::TypeContext::definedMacroType() {
  return getRuleContext<MIBParser::DefinedMacroTypeContext>(0);
}


size_t MIBParser::TypeContext::getRuleIndex() const {
  return MIBParser::RuleType;
}

void MIBParser::TypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType(this);
}

void MIBParser::TypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType(this);
}

MIBParser::TypeContext* MIBParser::type() {
  TypeContext *_localctx = _tracker.createInstance<TypeContext>(_ctx, getState());
  enterRule(_localctx, 38, MIBParser::RuleType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(370);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(367);
      builtinType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(368);
      definedType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(369);
      definedMacroType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefinedTypeContext ------------------------------------------------------------------

MIBParser::DefinedTypeContext::DefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::DefinedTypeContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::ModuleReferenceContext* MIBParser::DefinedTypeContext::moduleReference() {
  return getRuleContext<MIBParser::ModuleReferenceContext>(0);
}

MIBParser::ValueOrConstraintListContext* MIBParser::DefinedTypeContext::valueOrConstraintList() {
  return getRuleContext<MIBParser::ValueOrConstraintListContext>(0);
}


size_t MIBParser::DefinedTypeContext::getRuleIndex() const {
  return MIBParser::RuleDefinedType;
}

void MIBParser::DefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefinedType(this);
}

void MIBParser::DefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefinedType(this);
}

MIBParser::DefinedTypeContext* MIBParser::definedType() {
  DefinedTypeContext *_localctx = _tracker.createInstance<DefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 40, MIBParser::RuleDefinedType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(373);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      setState(372);
      moduleReference();
      break;
    }

    default:
      break;
    }
    setState(375);
    match(MIBParser::IDENTIFIER_STRING);
    setState(377);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LEFT_BRACE

    || _la == MIBParser::LEFT_PAREN) {
      setState(376);
      valueOrConstraintList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BuiltinTypeContext ------------------------------------------------------------------

MIBParser::BuiltinTypeContext::BuiltinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::NullTypeContext* MIBParser::BuiltinTypeContext::nullType() {
  return getRuleContext<MIBParser::NullTypeContext>(0);
}

MIBParser::BooleanTypeContext* MIBParser::BuiltinTypeContext::booleanType() {
  return getRuleContext<MIBParser::BooleanTypeContext>(0);
}

MIBParser::RealTypeContext* MIBParser::BuiltinTypeContext::realType() {
  return getRuleContext<MIBParser::RealTypeContext>(0);
}

MIBParser::IntegerTypeContext* MIBParser::BuiltinTypeContext::integerType() {
  return getRuleContext<MIBParser::IntegerTypeContext>(0);
}

MIBParser::ObjectIdentifierTypeContext* MIBParser::BuiltinTypeContext::objectIdentifierType() {
  return getRuleContext<MIBParser::ObjectIdentifierTypeContext>(0);
}

MIBParser::StringTypeContext* MIBParser::BuiltinTypeContext::stringType() {
  return getRuleContext<MIBParser::StringTypeContext>(0);
}

MIBParser::BitStringTypeContext* MIBParser::BuiltinTypeContext::bitStringType() {
  return getRuleContext<MIBParser::BitStringTypeContext>(0);
}

MIBParser::BitsTypeContext* MIBParser::BuiltinTypeContext::bitsType() {
  return getRuleContext<MIBParser::BitsTypeContext>(0);
}

MIBParser::SequenceTypeContext* MIBParser::BuiltinTypeContext::sequenceType() {
  return getRuleContext<MIBParser::SequenceTypeContext>(0);
}

MIBParser::SequenceOfTypeContext* MIBParser::BuiltinTypeContext::sequenceOfType() {
  return getRuleContext<MIBParser::SequenceOfTypeContext>(0);
}

MIBParser::SetTypeContext* MIBParser::BuiltinTypeContext::setType() {
  return getRuleContext<MIBParser::SetTypeContext>(0);
}

MIBParser::SetOfTypeContext* MIBParser::BuiltinTypeContext::setOfType() {
  return getRuleContext<MIBParser::SetOfTypeContext>(0);
}

MIBParser::ChoiceTypeContext* MIBParser::BuiltinTypeContext::choiceType() {
  return getRuleContext<MIBParser::ChoiceTypeContext>(0);
}

MIBParser::EnumeratedTypeContext* MIBParser::BuiltinTypeContext::enumeratedType() {
  return getRuleContext<MIBParser::EnumeratedTypeContext>(0);
}

MIBParser::SelectionTypeContext* MIBParser::BuiltinTypeContext::selectionType() {
  return getRuleContext<MIBParser::SelectionTypeContext>(0);
}

MIBParser::TaggedTypeContext* MIBParser::BuiltinTypeContext::taggedType() {
  return getRuleContext<MIBParser::TaggedTypeContext>(0);
}

MIBParser::AnyTypeContext* MIBParser::BuiltinTypeContext::anyType() {
  return getRuleContext<MIBParser::AnyTypeContext>(0);
}


size_t MIBParser::BuiltinTypeContext::getRuleIndex() const {
  return MIBParser::RuleBuiltinType;
}

void MIBParser::BuiltinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBuiltinType(this);
}

void MIBParser::BuiltinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBuiltinType(this);
}

MIBParser::BuiltinTypeContext* MIBParser::builtinType() {
  BuiltinTypeContext *_localctx = _tracker.createInstance<BuiltinTypeContext>(_ctx, getState());
  enterRule(_localctx, 42, MIBParser::RuleBuiltinType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(396);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(379);
      nullType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(380);
      booleanType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(381);
      realType();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(382);
      integerType();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(383);
      objectIdentifierType();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(384);
      stringType();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(385);
      bitStringType();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(386);
      bitsType();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(387);
      sequenceType();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(388);
      sequenceOfType();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(389);
      setType();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(390);
      setOfType();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(391);
      choiceType();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(392);
      enumeratedType();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(393);
      selectionType();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(394);
      taggedType();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(395);
      anyType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullTypeContext ------------------------------------------------------------------

MIBParser::NullTypeContext::NullTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NullTypeContext::NULL_() {
  return getToken(MIBParser::NULL_, 0);
}


size_t MIBParser::NullTypeContext::getRuleIndex() const {
  return MIBParser::RuleNullType;
}

void MIBParser::NullTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullType(this);
}

void MIBParser::NullTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullType(this);
}

MIBParser::NullTypeContext* MIBParser::nullType() {
  NullTypeContext *_localctx = _tracker.createInstance<NullTypeContext>(_ctx, getState());
  enterRule(_localctx, 44, MIBParser::RuleNullType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(398);
    match(MIBParser::NULL_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanTypeContext ------------------------------------------------------------------

MIBParser::BooleanTypeContext::BooleanTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::BooleanTypeContext::BOOLEAN() {
  return getToken(MIBParser::BOOLEAN, 0);
}


size_t MIBParser::BooleanTypeContext::getRuleIndex() const {
  return MIBParser::RuleBooleanType;
}

void MIBParser::BooleanTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanType(this);
}

void MIBParser::BooleanTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanType(this);
}

MIBParser::BooleanTypeContext* MIBParser::booleanType() {
  BooleanTypeContext *_localctx = _tracker.createInstance<BooleanTypeContext>(_ctx, getState());
  enterRule(_localctx, 46, MIBParser::RuleBooleanType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(400);
    match(MIBParser::BOOLEAN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RealTypeContext ------------------------------------------------------------------

MIBParser::RealTypeContext::RealTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::RealTypeContext::REAL() {
  return getToken(MIBParser::REAL, 0);
}


size_t MIBParser::RealTypeContext::getRuleIndex() const {
  return MIBParser::RuleRealType;
}

void MIBParser::RealTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRealType(this);
}

void MIBParser::RealTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRealType(this);
}

MIBParser::RealTypeContext* MIBParser::realType() {
  RealTypeContext *_localctx = _tracker.createInstance<RealTypeContext>(_ctx, getState());
  enterRule(_localctx, 48, MIBParser::RuleRealType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(402);
    match(MIBParser::REAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccessLevelContext ------------------------------------------------------------------

MIBParser::AccessLevelContext::AccessLevelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::AccessLevelContext::READ_ONLY() {
  return getToken(MIBParser::READ_ONLY, 0);
}

tree::TerminalNode* MIBParser::AccessLevelContext::READ_WRITE() {
  return getToken(MIBParser::READ_WRITE, 0);
}

tree::TerminalNode* MIBParser::AccessLevelContext::READ_CREATE() {
  return getToken(MIBParser::READ_CREATE, 0);
}

tree::TerminalNode* MIBParser::AccessLevelContext::NOT_ACCESSIBLE() {
  return getToken(MIBParser::NOT_ACCESSIBLE, 0);
}

tree::TerminalNode* MIBParser::AccessLevelContext::ACCESSIBLE_FOR_NOTIFY() {
  return getToken(MIBParser::ACCESSIBLE_FOR_NOTIFY, 0);
}


size_t MIBParser::AccessLevelContext::getRuleIndex() const {
  return MIBParser::RuleAccessLevel;
}

void MIBParser::AccessLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccessLevel(this);
}

void MIBParser::AccessLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccessLevel(this);
}

MIBParser::AccessLevelContext* MIBParser::accessLevel() {
  AccessLevelContext *_localctx = _tracker.createInstance<AccessLevelContext>(_ctx, getState());
  enterRule(_localctx, 50, MIBParser::RuleAccessLevel);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(404);
    _la = _input->LA(1);
    if (!(_la == MIBParser::ACCESSIBLE_FOR_NOTIFY

    || _la == MIBParser::NOT_ACCESSIBLE || ((((_la - 80) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 80)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntegerTypeContext ------------------------------------------------------------------

MIBParser::IntegerTypeContext::IntegerTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::IntegerTypeContext::INTEGER() {
  return getToken(MIBParser::INTEGER, 0);
}

MIBParser::ValueOrConstraintListContext* MIBParser::IntegerTypeContext::valueOrConstraintList() {
  return getRuleContext<MIBParser::ValueOrConstraintListContext>(0);
}


size_t MIBParser::IntegerTypeContext::getRuleIndex() const {
  return MIBParser::RuleIntegerType;
}

void MIBParser::IntegerTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntegerType(this);
}

void MIBParser::IntegerTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntegerType(this);
}

MIBParser::IntegerTypeContext* MIBParser::integerType() {
  IntegerTypeContext *_localctx = _tracker.createInstance<IntegerTypeContext>(_ctx, getState());
  enterRule(_localctx, 52, MIBParser::RuleIntegerType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(406);
    match(MIBParser::INTEGER);
    setState(408);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LEFT_BRACE

    || _la == MIBParser::LEFT_PAREN) {
      setState(407);
      valueOrConstraintList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectIdentifierTypeContext ------------------------------------------------------------------

MIBParser::ObjectIdentifierTypeContext::ObjectIdentifierTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ObjectIdentifierTypeContext::OBJECT() {
  return getToken(MIBParser::OBJECT, 0);
}

tree::TerminalNode* MIBParser::ObjectIdentifierTypeContext::IDENTIFIER() {
  return getToken(MIBParser::IDENTIFIER, 0);
}


size_t MIBParser::ObjectIdentifierTypeContext::getRuleIndex() const {
  return MIBParser::RuleObjectIdentifierType;
}

void MIBParser::ObjectIdentifierTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectIdentifierType(this);
}

void MIBParser::ObjectIdentifierTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectIdentifierType(this);
}

MIBParser::ObjectIdentifierTypeContext* MIBParser::objectIdentifierType() {
  ObjectIdentifierTypeContext *_localctx = _tracker.createInstance<ObjectIdentifierTypeContext>(_ctx, getState());
  enterRule(_localctx, 54, MIBParser::RuleObjectIdentifierType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(410);
    match(MIBParser::OBJECT);
    setState(411);
    match(MIBParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringTypeContext ------------------------------------------------------------------

MIBParser::StringTypeContext::StringTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::StringTypeContext::OCTET() {
  return getToken(MIBParser::OCTET, 0);
}

tree::TerminalNode* MIBParser::StringTypeContext::STRING() {
  return getToken(MIBParser::STRING, 0);
}

MIBParser::ConstraintListContext* MIBParser::StringTypeContext::constraintList() {
  return getRuleContext<MIBParser::ConstraintListContext>(0);
}


size_t MIBParser::StringTypeContext::getRuleIndex() const {
  return MIBParser::RuleStringType;
}

void MIBParser::StringTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringType(this);
}

void MIBParser::StringTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringType(this);
}

MIBParser::StringTypeContext* MIBParser::stringType() {
  StringTypeContext *_localctx = _tracker.createInstance<StringTypeContext>(_ctx, getState());
  enterRule(_localctx, 56, MIBParser::RuleStringType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(413);
    match(MIBParser::OCTET);
    setState(414);
    match(MIBParser::STRING);
    setState(416);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LEFT_PAREN) {
      setState(415);
      constraintList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitStringTypeContext ------------------------------------------------------------------

MIBParser::BitStringTypeContext::BitStringTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::BitStringTypeContext::BIT() {
  return getToken(MIBParser::BIT, 0);
}

tree::TerminalNode* MIBParser::BitStringTypeContext::STRING() {
  return getToken(MIBParser::STRING, 0);
}

MIBParser::ValueOrConstraintListContext* MIBParser::BitStringTypeContext::valueOrConstraintList() {
  return getRuleContext<MIBParser::ValueOrConstraintListContext>(0);
}


size_t MIBParser::BitStringTypeContext::getRuleIndex() const {
  return MIBParser::RuleBitStringType;
}

void MIBParser::BitStringTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitStringType(this);
}

void MIBParser::BitStringTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitStringType(this);
}

MIBParser::BitStringTypeContext* MIBParser::bitStringType() {
  BitStringTypeContext *_localctx = _tracker.createInstance<BitStringTypeContext>(_ctx, getState());
  enterRule(_localctx, 58, MIBParser::RuleBitStringType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(418);
    match(MIBParser::BIT);
    setState(419);
    match(MIBParser::STRING);
    setState(421);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LEFT_BRACE

    || _la == MIBParser::LEFT_PAREN) {
      setState(420);
      valueOrConstraintList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitsTypeContext ------------------------------------------------------------------

MIBParser::BitsTypeContext::BitsTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::BitsTypeContext::BITS() {
  return getToken(MIBParser::BITS, 0);
}

MIBParser::ValueOrConstraintListContext* MIBParser::BitsTypeContext::valueOrConstraintList() {
  return getRuleContext<MIBParser::ValueOrConstraintListContext>(0);
}


size_t MIBParser::BitsTypeContext::getRuleIndex() const {
  return MIBParser::RuleBitsType;
}

void MIBParser::BitsTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitsType(this);
}

void MIBParser::BitsTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitsType(this);
}

MIBParser::BitsTypeContext* MIBParser::bitsType() {
  BitsTypeContext *_localctx = _tracker.createInstance<BitsTypeContext>(_ctx, getState());
  enterRule(_localctx, 60, MIBParser::RuleBitsType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(423);
    match(MIBParser::BITS);
    setState(425);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LEFT_BRACE

    || _la == MIBParser::LEFT_PAREN) {
      setState(424);
      valueOrConstraintList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SequenceContentContext ------------------------------------------------------------------

MIBParser::SequenceContentContext::SequenceContentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SequenceContentContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

tree::TerminalNode* MIBParser::SequenceContentContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}

MIBParser::ElementTypeListContext* MIBParser::SequenceContentContext::elementTypeList() {
  return getRuleContext<MIBParser::ElementTypeListContext>(0);
}


size_t MIBParser::SequenceContentContext::getRuleIndex() const {
  return MIBParser::RuleSequenceContent;
}

void MIBParser::SequenceContentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequenceContent(this);
}

void MIBParser::SequenceContentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequenceContent(this);
}

MIBParser::SequenceContentContext* MIBParser::sequenceContent() {
  SequenceContentContext *_localctx = _tracker.createInstance<SequenceContentContext>(_ctx, getState());
  enterRule(_localctx, 62, MIBParser::RuleSequenceContent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(427);
    match(MIBParser::LEFT_BRACE);
    setState(429);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -5763481072640196544) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 4401280844157) != 0)) {
      setState(428);
      elementTypeList();
    }
    setState(431);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SequenceTypeContext ------------------------------------------------------------------

MIBParser::SequenceTypeContext::SequenceTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SequenceTypeContext::SEQUENCE() {
  return getToken(MIBParser::SEQUENCE, 0);
}

MIBParser::SequenceContentContext* MIBParser::SequenceTypeContext::sequenceContent() {
  return getRuleContext<MIBParser::SequenceContentContext>(0);
}


size_t MIBParser::SequenceTypeContext::getRuleIndex() const {
  return MIBParser::RuleSequenceType;
}

void MIBParser::SequenceTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequenceType(this);
}

void MIBParser::SequenceTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequenceType(this);
}

MIBParser::SequenceTypeContext* MIBParser::sequenceType() {
  SequenceTypeContext *_localctx = _tracker.createInstance<SequenceTypeContext>(_ctx, getState());
  enterRule(_localctx, 64, MIBParser::RuleSequenceType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(433);
    match(MIBParser::SEQUENCE);
    setState(434);
    sequenceContent();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SequenceOfTypeContext ------------------------------------------------------------------

MIBParser::SequenceOfTypeContext::SequenceOfTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SequenceOfTypeContext::SEQUENCE() {
  return getToken(MIBParser::SEQUENCE, 0);
}

tree::TerminalNode* MIBParser::SequenceOfTypeContext::OF() {
  return getToken(MIBParser::OF, 0);
}

MIBParser::TypeContext* MIBParser::SequenceOfTypeContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}

MIBParser::ConstraintListContext* MIBParser::SequenceOfTypeContext::constraintList() {
  return getRuleContext<MIBParser::ConstraintListContext>(0);
}


size_t MIBParser::SequenceOfTypeContext::getRuleIndex() const {
  return MIBParser::RuleSequenceOfType;
}

void MIBParser::SequenceOfTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequenceOfType(this);
}

void MIBParser::SequenceOfTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequenceOfType(this);
}

MIBParser::SequenceOfTypeContext* MIBParser::sequenceOfType() {
  SequenceOfTypeContext *_localctx = _tracker.createInstance<SequenceOfTypeContext>(_ctx, getState());
  enterRule(_localctx, 66, MIBParser::RuleSequenceOfType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(436);
    match(MIBParser::SEQUENCE);
    setState(438);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LEFT_PAREN) {
      setState(437);
      constraintList();
    }
    setState(440);
    match(MIBParser::OF);
    setState(441);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetTypeContext ------------------------------------------------------------------

MIBParser::SetTypeContext::SetTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SetTypeContext::SET() {
  return getToken(MIBParser::SET, 0);
}

tree::TerminalNode* MIBParser::SetTypeContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

tree::TerminalNode* MIBParser::SetTypeContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}

MIBParser::ElementTypeListContext* MIBParser::SetTypeContext::elementTypeList() {
  return getRuleContext<MIBParser::ElementTypeListContext>(0);
}


size_t MIBParser::SetTypeContext::getRuleIndex() const {
  return MIBParser::RuleSetType;
}

void MIBParser::SetTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetType(this);
}

void MIBParser::SetTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetType(this);
}

MIBParser::SetTypeContext* MIBParser::setType() {
  SetTypeContext *_localctx = _tracker.createInstance<SetTypeContext>(_ctx, getState());
  enterRule(_localctx, 68, MIBParser::RuleSetType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(443);
    match(MIBParser::SET);
    setState(444);
    match(MIBParser::LEFT_BRACE);
    setState(446);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -5763481072640196544) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 4401280844157) != 0)) {
      setState(445);
      elementTypeList();
    }
    setState(448);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetOfTypeContext ------------------------------------------------------------------

MIBParser::SetOfTypeContext::SetOfTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SetOfTypeContext::SET() {
  return getToken(MIBParser::SET, 0);
}

tree::TerminalNode* MIBParser::SetOfTypeContext::OF() {
  return getToken(MIBParser::OF, 0);
}

MIBParser::TypeContext* MIBParser::SetOfTypeContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}

MIBParser::SizeConstraintContext* MIBParser::SetOfTypeContext::sizeConstraint() {
  return getRuleContext<MIBParser::SizeConstraintContext>(0);
}


size_t MIBParser::SetOfTypeContext::getRuleIndex() const {
  return MIBParser::RuleSetOfType;
}

void MIBParser::SetOfTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetOfType(this);
}

void MIBParser::SetOfTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetOfType(this);
}

MIBParser::SetOfTypeContext* MIBParser::setOfType() {
  SetOfTypeContext *_localctx = _tracker.createInstance<SetOfTypeContext>(_ctx, getState());
  enterRule(_localctx, 70, MIBParser::RuleSetOfType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(450);
    match(MIBParser::SET);
    setState(452);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::SIZE) {
      setState(451);
      sizeConstraint();
    }
    setState(454);
    match(MIBParser::OF);
    setState(455);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChoiceTypeContext ------------------------------------------------------------------

MIBParser::ChoiceTypeContext::ChoiceTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ChoiceTypeContext::CHOICE() {
  return getToken(MIBParser::CHOICE, 0);
}

tree::TerminalNode* MIBParser::ChoiceTypeContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

MIBParser::ElementTypeListContext* MIBParser::ChoiceTypeContext::elementTypeList() {
  return getRuleContext<MIBParser::ElementTypeListContext>(0);
}

tree::TerminalNode* MIBParser::ChoiceTypeContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}


size_t MIBParser::ChoiceTypeContext::getRuleIndex() const {
  return MIBParser::RuleChoiceType;
}

void MIBParser::ChoiceTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChoiceType(this);
}

void MIBParser::ChoiceTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChoiceType(this);
}

MIBParser::ChoiceTypeContext* MIBParser::choiceType() {
  ChoiceTypeContext *_localctx = _tracker.createInstance<ChoiceTypeContext>(_ctx, getState());
  enterRule(_localctx, 72, MIBParser::RuleChoiceType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(457);
    match(MIBParser::CHOICE);
    setState(458);
    match(MIBParser::LEFT_BRACE);
    setState(459);
    elementTypeList();
    setState(460);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumeratedTypeContext ------------------------------------------------------------------

MIBParser::EnumeratedTypeContext::EnumeratedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::EnumeratedTypeContext::ENUMERATED() {
  return getToken(MIBParser::ENUMERATED, 0);
}

MIBParser::NamedNumberListContext* MIBParser::EnumeratedTypeContext::namedNumberList() {
  return getRuleContext<MIBParser::NamedNumberListContext>(0);
}


size_t MIBParser::EnumeratedTypeContext::getRuleIndex() const {
  return MIBParser::RuleEnumeratedType;
}

void MIBParser::EnumeratedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumeratedType(this);
}

void MIBParser::EnumeratedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumeratedType(this);
}

MIBParser::EnumeratedTypeContext* MIBParser::enumeratedType() {
  EnumeratedTypeContext *_localctx = _tracker.createInstance<EnumeratedTypeContext>(_ctx, getState());
  enterRule(_localctx, 74, MIBParser::RuleEnumeratedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(462);
    match(MIBParser::ENUMERATED);
    setState(463);
    namedNumberList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectionTypeContext ------------------------------------------------------------------

MIBParser::SelectionTypeContext::SelectionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SelectionTypeContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

tree::TerminalNode* MIBParser::SelectionTypeContext::LESS_THAN() {
  return getToken(MIBParser::LESS_THAN, 0);
}

MIBParser::TypeContext* MIBParser::SelectionTypeContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}


size_t MIBParser::SelectionTypeContext::getRuleIndex() const {
  return MIBParser::RuleSelectionType;
}

void MIBParser::SelectionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectionType(this);
}

void MIBParser::SelectionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectionType(this);
}

MIBParser::SelectionTypeContext* MIBParser::selectionType() {
  SelectionTypeContext *_localctx = _tracker.createInstance<SelectionTypeContext>(_ctx, getState());
  enterRule(_localctx, 76, MIBParser::RuleSelectionType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(465);
    match(MIBParser::IDENTIFIER_STRING);
    setState(466);
    match(MIBParser::LESS_THAN);
    setState(467);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TaggedTypeContext ------------------------------------------------------------------

MIBParser::TaggedTypeContext::TaggedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::TagContext* MIBParser::TaggedTypeContext::tag() {
  return getRuleContext<MIBParser::TagContext>(0);
}

MIBParser::ExplicitOrImplicitTagContext* MIBParser::TaggedTypeContext::explicitOrImplicitTag() {
  return getRuleContext<MIBParser::ExplicitOrImplicitTagContext>(0);
}

MIBParser::TypeContext* MIBParser::TaggedTypeContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}


size_t MIBParser::TaggedTypeContext::getRuleIndex() const {
  return MIBParser::RuleTaggedType;
}

void MIBParser::TaggedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTaggedType(this);
}

void MIBParser::TaggedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTaggedType(this);
}

MIBParser::TaggedTypeContext* MIBParser::taggedType() {
  TaggedTypeContext *_localctx = _tracker.createInstance<TaggedTypeContext>(_ctx, getState());
  enterRule(_localctx, 78, MIBParser::RuleTaggedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(469);
    tag();
    setState(470);
    explicitOrImplicitTag();
    setState(471);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TagContext ------------------------------------------------------------------

MIBParser::TagContext::TagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::TagContext::LEFT_BRACKET() {
  return getToken(MIBParser::LEFT_BRACKET, 0);
}

tree::TerminalNode* MIBParser::TagContext::NUMBER_STRING() {
  return getToken(MIBParser::NUMBER_STRING, 0);
}

tree::TerminalNode* MIBParser::TagContext::RIGHT_BRACKET() {
  return getToken(MIBParser::RIGHT_BRACKET, 0);
}

MIBParser::Class_Context* MIBParser::TagContext::class_() {
  return getRuleContext<MIBParser::Class_Context>(0);
}


size_t MIBParser::TagContext::getRuleIndex() const {
  return MIBParser::RuleTag;
}

void MIBParser::TagContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTag(this);
}

void MIBParser::TagContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTag(this);
}

MIBParser::TagContext* MIBParser::tag() {
  TagContext *_localctx = _tracker.createInstance<TagContext>(_ctx, getState());
  enterRule(_localctx, 80, MIBParser::RuleTag);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(473);
    match(MIBParser::LEFT_BRACKET);
    setState(475);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::APPLICATION || _la == MIBParser::PRIVATE

    || _la == MIBParser::UNIVERSAL) {
      setState(474);
      class_();
    }
    setState(477);
    match(MIBParser::NUMBER_STRING);
    setState(478);
    match(MIBParser::RIGHT_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_Context ------------------------------------------------------------------

MIBParser::Class_Context::Class_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::Class_Context::UNIVERSAL() {
  return getToken(MIBParser::UNIVERSAL, 0);
}

tree::TerminalNode* MIBParser::Class_Context::APPLICATION() {
  return getToken(MIBParser::APPLICATION, 0);
}

tree::TerminalNode* MIBParser::Class_Context::PRIVATE() {
  return getToken(MIBParser::PRIVATE, 0);
}


size_t MIBParser::Class_Context::getRuleIndex() const {
  return MIBParser::RuleClass_;
}

void MIBParser::Class_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_(this);
}

void MIBParser::Class_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_(this);
}

MIBParser::Class_Context* MIBParser::class_() {
  Class_Context *_localctx = _tracker.createInstance<Class_Context>(_ctx, getState());
  enterRule(_localctx, 82, MIBParser::RuleClass_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(480);
    _la = _input->LA(1);
    if (!(_la == MIBParser::APPLICATION || _la == MIBParser::PRIVATE

    || _la == MIBParser::UNIVERSAL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplicitOrImplicitTagContext ------------------------------------------------------------------

MIBParser::ExplicitOrImplicitTagContext::ExplicitOrImplicitTagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ExplicitOrImplicitTagContext::EXPLICIT() {
  return getToken(MIBParser::EXPLICIT, 0);
}

tree::TerminalNode* MIBParser::ExplicitOrImplicitTagContext::IMPLICIT() {
  return getToken(MIBParser::IMPLICIT, 0);
}


size_t MIBParser::ExplicitOrImplicitTagContext::getRuleIndex() const {
  return MIBParser::RuleExplicitOrImplicitTag;
}

void MIBParser::ExplicitOrImplicitTagContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplicitOrImplicitTag(this);
}

void MIBParser::ExplicitOrImplicitTagContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplicitOrImplicitTag(this);
}

MIBParser::ExplicitOrImplicitTagContext* MIBParser::explicitOrImplicitTag() {
  ExplicitOrImplicitTagContext *_localctx = _tracker.createInstance<ExplicitOrImplicitTagContext>(_ctx, getState());
  enterRule(_localctx, 84, MIBParser::RuleExplicitOrImplicitTag);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(482);
    _la = _input->LA(1);
    if (!(_la == MIBParser::EXPLICIT

    || _la == MIBParser::IMPLICIT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnyTypeContext ------------------------------------------------------------------

MIBParser::AnyTypeContext::AnyTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::AnyTypeContext::ANY() {
  return getToken(MIBParser::ANY, 0);
}

tree::TerminalNode* MIBParser::AnyTypeContext::DEFINED() {
  return getToken(MIBParser::DEFINED, 0);
}

tree::TerminalNode* MIBParser::AnyTypeContext::BY() {
  return getToken(MIBParser::BY, 0);
}

tree::TerminalNode* MIBParser::AnyTypeContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}


size_t MIBParser::AnyTypeContext::getRuleIndex() const {
  return MIBParser::RuleAnyType;
}

void MIBParser::AnyTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnyType(this);
}

void MIBParser::AnyTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnyType(this);
}

MIBParser::AnyTypeContext* MIBParser::anyType() {
  AnyTypeContext *_localctx = _tracker.createInstance<AnyTypeContext>(_ctx, getState());
  enterRule(_localctx, 86, MIBParser::RuleAnyType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(484);
    match(MIBParser::ANY);
    setState(488);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::DEFINED) {
      setState(485);
      match(MIBParser::DEFINED);
      setState(486);
      match(MIBParser::BY);
      setState(487);
      match(MIBParser::IDENTIFIER_STRING);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementTypeListContext ------------------------------------------------------------------

MIBParser::ElementTypeListContext::ElementTypeListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MIBParser::ElementTypeContext *> MIBParser::ElementTypeListContext::elementType() {
  return getRuleContexts<MIBParser::ElementTypeContext>();
}

MIBParser::ElementTypeContext* MIBParser::ElementTypeListContext::elementType(size_t i) {
  return getRuleContext<MIBParser::ElementTypeContext>(i);
}

std::vector<tree::TerminalNode *> MIBParser::ElementTypeListContext::COMMA() {
  return getTokens(MIBParser::COMMA);
}

tree::TerminalNode* MIBParser::ElementTypeListContext::COMMA(size_t i) {
  return getToken(MIBParser::COMMA, i);
}


size_t MIBParser::ElementTypeListContext::getRuleIndex() const {
  return MIBParser::RuleElementTypeList;
}

void MIBParser::ElementTypeListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElementTypeList(this);
}

void MIBParser::ElementTypeListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElementTypeList(this);
}

MIBParser::ElementTypeListContext* MIBParser::elementTypeList() {
  ElementTypeListContext *_localctx = _tracker.createInstance<ElementTypeListContext>(_ctx, getState());
  enterRule(_localctx, 88, MIBParser::RuleElementTypeList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(490);
    elementType();
    setState(495);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(491);
        match(MIBParser::COMMA);
        setState(492);
        elementType(); 
      }
      setState(497);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementTypeContext ------------------------------------------------------------------

MIBParser::ElementTypeContext::ElementTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::TypeContext* MIBParser::ElementTypeContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}

tree::TerminalNode* MIBParser::ElementTypeContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::OptionalOrDefaultElementContext* MIBParser::ElementTypeContext::optionalOrDefaultElement() {
  return getRuleContext<MIBParser::OptionalOrDefaultElementContext>(0);
}

tree::TerminalNode* MIBParser::ElementTypeContext::COMPONENTS() {
  return getToken(MIBParser::COMPONENTS, 0);
}

tree::TerminalNode* MIBParser::ElementTypeContext::OF() {
  return getToken(MIBParser::OF, 0);
}


size_t MIBParser::ElementTypeContext::getRuleIndex() const {
  return MIBParser::RuleElementType;
}

void MIBParser::ElementTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElementType(this);
}

void MIBParser::ElementTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElementType(this);
}

MIBParser::ElementTypeContext* MIBParser::elementType() {
  ElementTypeContext *_localctx = _tracker.createInstance<ElementTypeContext>(_ctx, getState());
  enterRule(_localctx, 90, MIBParser::RuleElementType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(511);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(499);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
      case 1: {
        setState(498);
        match(MIBParser::IDENTIFIER_STRING);
        break;
      }

      default:
        break;
      }
      setState(501);
      type();
      setState(503);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
      case 1: {
        setState(502);
        optionalOrDefaultElement();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(506);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MIBParser::IDENTIFIER_STRING) {
        setState(505);
        match(MIBParser::IDENTIFIER_STRING);
      }
      setState(508);
      match(MIBParser::COMPONENTS);
      setState(509);
      match(MIBParser::OF);
      setState(510);
      type();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionalOrDefaultElementContext ------------------------------------------------------------------

MIBParser::OptionalOrDefaultElementContext::OptionalOrDefaultElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::OptionalOrDefaultElementContext::OPTIONAL() {
  return getToken(MIBParser::OPTIONAL, 0);
}

tree::TerminalNode* MIBParser::OptionalOrDefaultElementContext::DEFAULT() {
  return getToken(MIBParser::DEFAULT, 0);
}

MIBParser::ValueContext* MIBParser::OptionalOrDefaultElementContext::value() {
  return getRuleContext<MIBParser::ValueContext>(0);
}

tree::TerminalNode* MIBParser::OptionalOrDefaultElementContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}


size_t MIBParser::OptionalOrDefaultElementContext::getRuleIndex() const {
  return MIBParser::RuleOptionalOrDefaultElement;
}

void MIBParser::OptionalOrDefaultElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionalOrDefaultElement(this);
}

void MIBParser::OptionalOrDefaultElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionalOrDefaultElement(this);
}

MIBParser::OptionalOrDefaultElementContext* MIBParser::optionalOrDefaultElement() {
  OptionalOrDefaultElementContext *_localctx = _tracker.createInstance<OptionalOrDefaultElementContext>(_ctx, getState());
  enterRule(_localctx, 92, MIBParser::RuleOptionalOrDefaultElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(519);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::OPTIONAL: {
        enterOuterAlt(_localctx, 1);
        setState(513);
        match(MIBParser::OPTIONAL);
        break;
      }

      case MIBParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(514);
        match(MIBParser::DEFAULT);
        setState(516);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
        case 1: {
          setState(515);
          match(MIBParser::IDENTIFIER_STRING);
          break;
        }

        default:
          break;
        }
        setState(518);
        value();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueOrConstraintListContext ------------------------------------------------------------------

MIBParser::ValueOrConstraintListContext::ValueOrConstraintListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::NamedNumberListContext* MIBParser::ValueOrConstraintListContext::namedNumberList() {
  return getRuleContext<MIBParser::NamedNumberListContext>(0);
}

MIBParser::ConstraintListContext* MIBParser::ValueOrConstraintListContext::constraintList() {
  return getRuleContext<MIBParser::ConstraintListContext>(0);
}


size_t MIBParser::ValueOrConstraintListContext::getRuleIndex() const {
  return MIBParser::RuleValueOrConstraintList;
}

void MIBParser::ValueOrConstraintListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueOrConstraintList(this);
}

void MIBParser::ValueOrConstraintListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueOrConstraintList(this);
}

MIBParser::ValueOrConstraintListContext* MIBParser::valueOrConstraintList() {
  ValueOrConstraintListContext *_localctx = _tracker.createInstance<ValueOrConstraintListContext>(_ctx, getState());
  enterRule(_localctx, 94, MIBParser::RuleValueOrConstraintList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(523);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::LEFT_BRACE: {
        enterOuterAlt(_localctx, 1);
        setState(521);
        namedNumberList();
        break;
      }

      case MIBParser::LEFT_PAREN: {
        enterOuterAlt(_localctx, 2);
        setState(522);
        constraintList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedNumberListContext ------------------------------------------------------------------

MIBParser::NamedNumberListContext::NamedNumberListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NamedNumberListContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

std::vector<MIBParser::NamedNumberContext *> MIBParser::NamedNumberListContext::namedNumber() {
  return getRuleContexts<MIBParser::NamedNumberContext>();
}

MIBParser::NamedNumberContext* MIBParser::NamedNumberListContext::namedNumber(size_t i) {
  return getRuleContext<MIBParser::NamedNumberContext>(i);
}

tree::TerminalNode* MIBParser::NamedNumberListContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}

std::vector<tree::TerminalNode *> MIBParser::NamedNumberListContext::COMMA() {
  return getTokens(MIBParser::COMMA);
}

tree::TerminalNode* MIBParser::NamedNumberListContext::COMMA(size_t i) {
  return getToken(MIBParser::COMMA, i);
}


size_t MIBParser::NamedNumberListContext::getRuleIndex() const {
  return MIBParser::RuleNamedNumberList;
}

void MIBParser::NamedNumberListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedNumberList(this);
}

void MIBParser::NamedNumberListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedNumberList(this);
}

MIBParser::NamedNumberListContext* MIBParser::namedNumberList() {
  NamedNumberListContext *_localctx = _tracker.createInstance<NamedNumberListContext>(_ctx, getState());
  enterRule(_localctx, 96, MIBParser::RuleNamedNumberList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(525);
    match(MIBParser::LEFT_BRACE);
    setState(526);
    namedNumber();
    setState(531);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MIBParser::COMMA) {
      setState(527);
      match(MIBParser::COMMA);
      setState(528);
      namedNumber();
      setState(533);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(534);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedNumberContext ------------------------------------------------------------------

MIBParser::NamedNumberContext::NamedNumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NamedNumberContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

tree::TerminalNode* MIBParser::NamedNumberContext::LEFT_PAREN() {
  return getToken(MIBParser::LEFT_PAREN, 0);
}

MIBParser::NumberContext* MIBParser::NamedNumberContext::number() {
  return getRuleContext<MIBParser::NumberContext>(0);
}

tree::TerminalNode* MIBParser::NamedNumberContext::RIGHT_PAREN() {
  return getToken(MIBParser::RIGHT_PAREN, 0);
}


size_t MIBParser::NamedNumberContext::getRuleIndex() const {
  return MIBParser::RuleNamedNumber;
}

void MIBParser::NamedNumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedNumber(this);
}

void MIBParser::NamedNumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedNumber(this);
}

MIBParser::NamedNumberContext* MIBParser::namedNumber() {
  NamedNumberContext *_localctx = _tracker.createInstance<NamedNumberContext>(_ctx, getState());
  enterRule(_localctx, 98, MIBParser::RuleNamedNumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(536);
    match(MIBParser::IDENTIFIER_STRING);
    setState(537);
    match(MIBParser::LEFT_PAREN);
    setState(538);
    number();
    setState(539);
    match(MIBParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

MIBParser::NumberContext::NumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NumberContext::NUMBER_STRING() {
  return getToken(MIBParser::NUMBER_STRING, 0);
}

MIBParser::BinaryValueContext* MIBParser::NumberContext::binaryValue() {
  return getRuleContext<MIBParser::BinaryValueContext>(0);
}

MIBParser::HexadecimalValueContext* MIBParser::NumberContext::hexadecimalValue() {
  return getRuleContext<MIBParser::HexadecimalValueContext>(0);
}

MIBParser::DefinedValueContext* MIBParser::NumberContext::definedValue() {
  return getRuleContext<MIBParser::DefinedValueContext>(0);
}


size_t MIBParser::NumberContext::getRuleIndex() const {
  return MIBParser::RuleNumber;
}

void MIBParser::NumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumber(this);
}

void MIBParser::NumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumber(this);
}

MIBParser::NumberContext* MIBParser::number() {
  NumberContext *_localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
  enterRule(_localctx, 100, MIBParser::RuleNumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(545);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(541);
      match(MIBParser::NUMBER_STRING);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(542);
      binaryValue();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(543);
      hexadecimalValue();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(544);
      definedValue();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintListContext ------------------------------------------------------------------

MIBParser::ConstraintListContext::ConstraintListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ConstraintListContext::LEFT_PAREN() {
  return getToken(MIBParser::LEFT_PAREN, 0);
}

std::vector<MIBParser::ConstraintContext *> MIBParser::ConstraintListContext::constraint() {
  return getRuleContexts<MIBParser::ConstraintContext>();
}

MIBParser::ConstraintContext* MIBParser::ConstraintListContext::constraint(size_t i) {
  return getRuleContext<MIBParser::ConstraintContext>(i);
}

tree::TerminalNode* MIBParser::ConstraintListContext::RIGHT_PAREN() {
  return getToken(MIBParser::RIGHT_PAREN, 0);
}

std::vector<tree::TerminalNode *> MIBParser::ConstraintListContext::VERTICAL_BAR() {
  return getTokens(MIBParser::VERTICAL_BAR);
}

tree::TerminalNode* MIBParser::ConstraintListContext::VERTICAL_BAR(size_t i) {
  return getToken(MIBParser::VERTICAL_BAR, i);
}


size_t MIBParser::ConstraintListContext::getRuleIndex() const {
  return MIBParser::RuleConstraintList;
}

void MIBParser::ConstraintListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintList(this);
}

void MIBParser::ConstraintListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintList(this);
}

MIBParser::ConstraintListContext* MIBParser::constraintList() {
  ConstraintListContext *_localctx = _tracker.createInstance<ConstraintListContext>(_ctx, getState());
  enterRule(_localctx, 102, MIBParser::RuleConstraintList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(547);
    match(MIBParser::LEFT_PAREN);
    setState(548);
    constraint();
    setState(553);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MIBParser::VERTICAL_BAR) {
      setState(549);
      match(MIBParser::VERTICAL_BAR);
      setState(550);
      constraint();
      setState(555);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(556);
    match(MIBParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintContext ------------------------------------------------------------------

MIBParser::ConstraintContext::ConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::ValueConstraintContext* MIBParser::ConstraintContext::valueConstraint() {
  return getRuleContext<MIBParser::ValueConstraintContext>(0);
}

MIBParser::SizeConstraintContext* MIBParser::ConstraintContext::sizeConstraint() {
  return getRuleContext<MIBParser::SizeConstraintContext>(0);
}

MIBParser::AlphabetConstraintContext* MIBParser::ConstraintContext::alphabetConstraint() {
  return getRuleContext<MIBParser::AlphabetConstraintContext>(0);
}

MIBParser::ContainedTypeConstraintContext* MIBParser::ConstraintContext::containedTypeConstraint() {
  return getRuleContext<MIBParser::ContainedTypeConstraintContext>(0);
}

MIBParser::InnerTypeConstraintContext* MIBParser::ConstraintContext::innerTypeConstraint() {
  return getRuleContext<MIBParser::InnerTypeConstraintContext>(0);
}


size_t MIBParser::ConstraintContext::getRuleIndex() const {
  return MIBParser::RuleConstraint;
}

void MIBParser::ConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint(this);
}

void MIBParser::ConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint(this);
}

MIBParser::ConstraintContext* MIBParser::constraint() {
  ConstraintContext *_localctx = _tracker.createInstance<ConstraintContext>(_ctx, getState());
  enterRule(_localctx, 104, MIBParser::RuleConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(563);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::LEFT_BRACE:
      case MIBParser::MINUS:
      case MIBParser::FALSE:
      case MIBParser::MIN:
      case MIBParser::MINUS_INFINITY:
      case MIBParser::NULL_:
      case MIBParser::PLUS_INFINITY:
      case MIBParser::TRUE:
      case MIBParser::BINARY_STRING:
      case MIBParser::HEXADECIMAL_STRING:
      case MIBParser::QUOTED_STRING:
      case MIBParser::IDENTIFIER_STRING:
      case MIBParser::INTEGER_STRING:
      case MIBParser::NUMBER_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(558);
        valueConstraint();
        break;
      }

      case MIBParser::SIZE: {
        enterOuterAlt(_localctx, 2);
        setState(559);
        sizeConstraint();
        break;
      }

      case MIBParser::FROM: {
        enterOuterAlt(_localctx, 3);
        setState(560);
        alphabetConstraint();
        break;
      }

      case MIBParser::INCLUDES: {
        enterOuterAlt(_localctx, 4);
        setState(561);
        containedTypeConstraint();
        break;
      }

      case MIBParser::WITH: {
        enterOuterAlt(_localctx, 5);
        setState(562);
        innerTypeConstraint();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueConstraintListContext ------------------------------------------------------------------

MIBParser::ValueConstraintListContext::ValueConstraintListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ValueConstraintListContext::LEFT_PAREN() {
  return getToken(MIBParser::LEFT_PAREN, 0);
}

std::vector<MIBParser::ValueConstraintContext *> MIBParser::ValueConstraintListContext::valueConstraint() {
  return getRuleContexts<MIBParser::ValueConstraintContext>();
}

MIBParser::ValueConstraintContext* MIBParser::ValueConstraintListContext::valueConstraint(size_t i) {
  return getRuleContext<MIBParser::ValueConstraintContext>(i);
}

tree::TerminalNode* MIBParser::ValueConstraintListContext::RIGHT_PAREN() {
  return getToken(MIBParser::RIGHT_PAREN, 0);
}

std::vector<tree::TerminalNode *> MIBParser::ValueConstraintListContext::VERTICAL_BAR() {
  return getTokens(MIBParser::VERTICAL_BAR);
}

tree::TerminalNode* MIBParser::ValueConstraintListContext::VERTICAL_BAR(size_t i) {
  return getToken(MIBParser::VERTICAL_BAR, i);
}


size_t MIBParser::ValueConstraintListContext::getRuleIndex() const {
  return MIBParser::RuleValueConstraintList;
}

void MIBParser::ValueConstraintListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueConstraintList(this);
}

void MIBParser::ValueConstraintListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueConstraintList(this);
}

MIBParser::ValueConstraintListContext* MIBParser::valueConstraintList() {
  ValueConstraintListContext *_localctx = _tracker.createInstance<ValueConstraintListContext>(_ctx, getState());
  enterRule(_localctx, 106, MIBParser::RuleValueConstraintList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(565);
    match(MIBParser::LEFT_PAREN);
    setState(566);
    valueConstraint();
    setState(571);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MIBParser::VERTICAL_BAR) {
      setState(567);
      match(MIBParser::VERTICAL_BAR);
      setState(568);
      valueConstraint();
      setState(573);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(574);
    match(MIBParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueConstraintContext ------------------------------------------------------------------

MIBParser::ValueConstraintContext::ValueConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::LowerEndPointContext* MIBParser::ValueConstraintContext::lowerEndPoint() {
  return getRuleContext<MIBParser::LowerEndPointContext>(0);
}

MIBParser::ValueRangeContext* MIBParser::ValueConstraintContext::valueRange() {
  return getRuleContext<MIBParser::ValueRangeContext>(0);
}


size_t MIBParser::ValueConstraintContext::getRuleIndex() const {
  return MIBParser::RuleValueConstraint;
}

void MIBParser::ValueConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueConstraint(this);
}

void MIBParser::ValueConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueConstraint(this);
}

MIBParser::ValueConstraintContext* MIBParser::valueConstraint() {
  ValueConstraintContext *_localctx = _tracker.createInstance<ValueConstraintContext>(_ctx, getState());
  enterRule(_localctx, 108, MIBParser::RuleValueConstraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(576);
    lowerEndPoint();
    setState(578);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::DOUBLE_DOT

    || _la == MIBParser::LESS_THAN) {
      setState(577);
      valueRange();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueRangeContext ------------------------------------------------------------------

MIBParser::ValueRangeContext::ValueRangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ValueRangeContext::DOUBLE_DOT() {
  return getToken(MIBParser::DOUBLE_DOT, 0);
}

MIBParser::UpperEndPointContext* MIBParser::ValueRangeContext::upperEndPoint() {
  return getRuleContext<MIBParser::UpperEndPointContext>(0);
}

std::vector<tree::TerminalNode *> MIBParser::ValueRangeContext::LESS_THAN() {
  return getTokens(MIBParser::LESS_THAN);
}

tree::TerminalNode* MIBParser::ValueRangeContext::LESS_THAN(size_t i) {
  return getToken(MIBParser::LESS_THAN, i);
}


size_t MIBParser::ValueRangeContext::getRuleIndex() const {
  return MIBParser::RuleValueRange;
}

void MIBParser::ValueRangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueRange(this);
}

void MIBParser::ValueRangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueRange(this);
}

MIBParser::ValueRangeContext* MIBParser::valueRange() {
  ValueRangeContext *_localctx = _tracker.createInstance<ValueRangeContext>(_ctx, getState());
  enterRule(_localctx, 110, MIBParser::RuleValueRange);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(581);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LESS_THAN) {
      setState(580);
      match(MIBParser::LESS_THAN);
    }
    setState(583);
    match(MIBParser::DOUBLE_DOT);
    setState(585);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LESS_THAN) {
      setState(584);
      match(MIBParser::LESS_THAN);
    }
    setState(587);
    upperEndPoint();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LowerEndPointContext ------------------------------------------------------------------

MIBParser::LowerEndPointContext::LowerEndPointContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::ValueContext* MIBParser::LowerEndPointContext::value() {
  return getRuleContext<MIBParser::ValueContext>(0);
}

tree::TerminalNode* MIBParser::LowerEndPointContext::MIN() {
  return getToken(MIBParser::MIN, 0);
}


size_t MIBParser::LowerEndPointContext::getRuleIndex() const {
  return MIBParser::RuleLowerEndPoint;
}

void MIBParser::LowerEndPointContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLowerEndPoint(this);
}

void MIBParser::LowerEndPointContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLowerEndPoint(this);
}

MIBParser::LowerEndPointContext* MIBParser::lowerEndPoint() {
  LowerEndPointContext *_localctx = _tracker.createInstance<LowerEndPointContext>(_ctx, getState());
  enterRule(_localctx, 112, MIBParser::RuleLowerEndPoint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(591);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::LEFT_BRACE:
      case MIBParser::MINUS:
      case MIBParser::FALSE:
      case MIBParser::MINUS_INFINITY:
      case MIBParser::NULL_:
      case MIBParser::PLUS_INFINITY:
      case MIBParser::TRUE:
      case MIBParser::BINARY_STRING:
      case MIBParser::HEXADECIMAL_STRING:
      case MIBParser::QUOTED_STRING:
      case MIBParser::IDENTIFIER_STRING:
      case MIBParser::INTEGER_STRING:
      case MIBParser::NUMBER_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(589);
        value();
        break;
      }

      case MIBParser::MIN: {
        enterOuterAlt(_localctx, 2);
        setState(590);
        match(MIBParser::MIN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpperEndPointContext ------------------------------------------------------------------

MIBParser::UpperEndPointContext::UpperEndPointContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::ValueContext* MIBParser::UpperEndPointContext::value() {
  return getRuleContext<MIBParser::ValueContext>(0);
}

tree::TerminalNode* MIBParser::UpperEndPointContext::MAX() {
  return getToken(MIBParser::MAX, 0);
}


size_t MIBParser::UpperEndPointContext::getRuleIndex() const {
  return MIBParser::RuleUpperEndPoint;
}

void MIBParser::UpperEndPointContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpperEndPoint(this);
}

void MIBParser::UpperEndPointContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpperEndPoint(this);
}

MIBParser::UpperEndPointContext* MIBParser::upperEndPoint() {
  UpperEndPointContext *_localctx = _tracker.createInstance<UpperEndPointContext>(_ctx, getState());
  enterRule(_localctx, 114, MIBParser::RuleUpperEndPoint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(595);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::LEFT_BRACE:
      case MIBParser::MINUS:
      case MIBParser::FALSE:
      case MIBParser::MINUS_INFINITY:
      case MIBParser::NULL_:
      case MIBParser::PLUS_INFINITY:
      case MIBParser::TRUE:
      case MIBParser::BINARY_STRING:
      case MIBParser::HEXADECIMAL_STRING:
      case MIBParser::QUOTED_STRING:
      case MIBParser::IDENTIFIER_STRING:
      case MIBParser::INTEGER_STRING:
      case MIBParser::NUMBER_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(593);
        value();
        break;
      }

      case MIBParser::MAX: {
        enterOuterAlt(_localctx, 2);
        setState(594);
        match(MIBParser::MAX);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SizeConstraintContext ------------------------------------------------------------------

MIBParser::SizeConstraintContext::SizeConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SizeConstraintContext::SIZE() {
  return getToken(MIBParser::SIZE, 0);
}

MIBParser::ValueConstraintListContext* MIBParser::SizeConstraintContext::valueConstraintList() {
  return getRuleContext<MIBParser::ValueConstraintListContext>(0);
}


size_t MIBParser::SizeConstraintContext::getRuleIndex() const {
  return MIBParser::RuleSizeConstraint;
}

void MIBParser::SizeConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSizeConstraint(this);
}

void MIBParser::SizeConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSizeConstraint(this);
}

MIBParser::SizeConstraintContext* MIBParser::sizeConstraint() {
  SizeConstraintContext *_localctx = _tracker.createInstance<SizeConstraintContext>(_ctx, getState());
  enterRule(_localctx, 116, MIBParser::RuleSizeConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(597);
    match(MIBParser::SIZE);
    setState(598);
    valueConstraintList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlphabetConstraintContext ------------------------------------------------------------------

MIBParser::AlphabetConstraintContext::AlphabetConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::AlphabetConstraintContext::FROM() {
  return getToken(MIBParser::FROM, 0);
}

MIBParser::ValueConstraintListContext* MIBParser::AlphabetConstraintContext::valueConstraintList() {
  return getRuleContext<MIBParser::ValueConstraintListContext>(0);
}


size_t MIBParser::AlphabetConstraintContext::getRuleIndex() const {
  return MIBParser::RuleAlphabetConstraint;
}

void MIBParser::AlphabetConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlphabetConstraint(this);
}

void MIBParser::AlphabetConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlphabetConstraint(this);
}

MIBParser::AlphabetConstraintContext* MIBParser::alphabetConstraint() {
  AlphabetConstraintContext *_localctx = _tracker.createInstance<AlphabetConstraintContext>(_ctx, getState());
  enterRule(_localctx, 118, MIBParser::RuleAlphabetConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(600);
    match(MIBParser::FROM);
    setState(601);
    valueConstraintList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContainedTypeConstraintContext ------------------------------------------------------------------

MIBParser::ContainedTypeConstraintContext::ContainedTypeConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ContainedTypeConstraintContext::INCLUDES() {
  return getToken(MIBParser::INCLUDES, 0);
}

MIBParser::TypeContext* MIBParser::ContainedTypeConstraintContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}


size_t MIBParser::ContainedTypeConstraintContext::getRuleIndex() const {
  return MIBParser::RuleContainedTypeConstraint;
}

void MIBParser::ContainedTypeConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContainedTypeConstraint(this);
}

void MIBParser::ContainedTypeConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContainedTypeConstraint(this);
}

MIBParser::ContainedTypeConstraintContext* MIBParser::containedTypeConstraint() {
  ContainedTypeConstraintContext *_localctx = _tracker.createInstance<ContainedTypeConstraintContext>(_ctx, getState());
  enterRule(_localctx, 120, MIBParser::RuleContainedTypeConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(603);
    match(MIBParser::INCLUDES);
    setState(604);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InnerTypeConstraintContext ------------------------------------------------------------------

MIBParser::InnerTypeConstraintContext::InnerTypeConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::InnerTypeConstraintContext::WITH() {
  return getToken(MIBParser::WITH, 0);
}

tree::TerminalNode* MIBParser::InnerTypeConstraintContext::COMPONENT() {
  return getToken(MIBParser::COMPONENT, 0);
}

MIBParser::ValueOrConstraintListContext* MIBParser::InnerTypeConstraintContext::valueOrConstraintList() {
  return getRuleContext<MIBParser::ValueOrConstraintListContext>(0);
}

tree::TerminalNode* MIBParser::InnerTypeConstraintContext::COMPONENTS() {
  return getToken(MIBParser::COMPONENTS, 0);
}

MIBParser::ComponentsListContext* MIBParser::InnerTypeConstraintContext::componentsList() {
  return getRuleContext<MIBParser::ComponentsListContext>(0);
}


size_t MIBParser::InnerTypeConstraintContext::getRuleIndex() const {
  return MIBParser::RuleInnerTypeConstraint;
}

void MIBParser::InnerTypeConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInnerTypeConstraint(this);
}

void MIBParser::InnerTypeConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInnerTypeConstraint(this);
}

MIBParser::InnerTypeConstraintContext* MIBParser::innerTypeConstraint() {
  InnerTypeConstraintContext *_localctx = _tracker.createInstance<InnerTypeConstraintContext>(_ctx, getState());
  enterRule(_localctx, 122, MIBParser::RuleInnerTypeConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(612);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(606);
      match(MIBParser::WITH);
      setState(607);
      match(MIBParser::COMPONENT);
      setState(608);
      valueOrConstraintList();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(609);
      match(MIBParser::WITH);
      setState(610);
      match(MIBParser::COMPONENTS);
      setState(611);
      componentsList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentsListContext ------------------------------------------------------------------

MIBParser::ComponentsListContext::ComponentsListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ComponentsListContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

tree::TerminalNode* MIBParser::ComponentsListContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}

MIBParser::ComponentConstraintContext* MIBParser::ComponentsListContext::componentConstraint() {
  return getRuleContext<MIBParser::ComponentConstraintContext>(0);
}

tree::TerminalNode* MIBParser::ComponentsListContext::TRIPLE_DOT() {
  return getToken(MIBParser::TRIPLE_DOT, 0);
}

std::vector<MIBParser::ComponentsListTailContext *> MIBParser::ComponentsListContext::componentsListTail() {
  return getRuleContexts<MIBParser::ComponentsListTailContext>();
}

MIBParser::ComponentsListTailContext* MIBParser::ComponentsListContext::componentsListTail(size_t i) {
  return getRuleContext<MIBParser::ComponentsListTailContext>(i);
}


size_t MIBParser::ComponentsListContext::getRuleIndex() const {
  return MIBParser::RuleComponentsList;
}

void MIBParser::ComponentsListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponentsList(this);
}

void MIBParser::ComponentsListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponentsList(this);
}

MIBParser::ComponentsListContext* MIBParser::componentsList() {
  ComponentsListContext *_localctx = _tracker.createInstance<ComponentsListContext>(_ctx, getState());
  enterRule(_localctx, 124, MIBParser::RuleComponentsList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(614);
    match(MIBParser::LEFT_BRACE);
    setState(628);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::LEFT_BRACE:
      case MIBParser::LEFT_PAREN:
      case MIBParser::ABSENT:
      case MIBParser::OPTIONAL:
      case MIBParser::PRESENT:
      case MIBParser::IDENTIFIER_STRING: {
        setState(615);
        componentConstraint();
        setState(619);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MIBParser::COMMA) {
          setState(616);
          componentsListTail();
          setState(621);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MIBParser::TRIPLE_DOT: {
        setState(622);
        match(MIBParser::TRIPLE_DOT);
        setState(624); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(623);
          componentsListTail();
          setState(626); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == MIBParser::COMMA);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(630);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentsListTailContext ------------------------------------------------------------------

MIBParser::ComponentsListTailContext::ComponentsListTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ComponentsListTailContext::COMMA() {
  return getToken(MIBParser::COMMA, 0);
}

MIBParser::ComponentConstraintContext* MIBParser::ComponentsListTailContext::componentConstraint() {
  return getRuleContext<MIBParser::ComponentConstraintContext>(0);
}


size_t MIBParser::ComponentsListTailContext::getRuleIndex() const {
  return MIBParser::RuleComponentsListTail;
}

void MIBParser::ComponentsListTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponentsListTail(this);
}

void MIBParser::ComponentsListTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponentsListTail(this);
}

MIBParser::ComponentsListTailContext* MIBParser::componentsListTail() {
  ComponentsListTailContext *_localctx = _tracker.createInstance<ComponentsListTailContext>(_ctx, getState());
  enterRule(_localctx, 126, MIBParser::RuleComponentsListTail);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(632);
    match(MIBParser::COMMA);
    setState(634);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 65696) != 0) || ((((_la - 74) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 74)) & 4294967305) != 0)) {
      setState(633);
      componentConstraint();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentConstraintContext ------------------------------------------------------------------

MIBParser::ComponentConstraintContext::ComponentConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ComponentConstraintContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::ComponentValuePresenceContext* MIBParser::ComponentConstraintContext::componentValuePresence() {
  return getRuleContext<MIBParser::ComponentValuePresenceContext>(0);
}


size_t MIBParser::ComponentConstraintContext::getRuleIndex() const {
  return MIBParser::RuleComponentConstraint;
}

void MIBParser::ComponentConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponentConstraint(this);
}

void MIBParser::ComponentConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponentConstraint(this);
}

MIBParser::ComponentConstraintContext* MIBParser::componentConstraint() {
  ComponentConstraintContext *_localctx = _tracker.createInstance<ComponentConstraintContext>(_ctx, getState());
  enterRule(_localctx, 128, MIBParser::RuleComponentConstraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(641);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::IDENTIFIER_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(636);
        match(MIBParser::IDENTIFIER_STRING);
        setState(638);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 65696) != 0) || _la == MIBParser::OPTIONAL

        || _la == MIBParser::PRESENT) {
          setState(637);
          componentValuePresence();
        }
        break;
      }

      case MIBParser::LEFT_BRACE:
      case MIBParser::LEFT_PAREN:
      case MIBParser::ABSENT:
      case MIBParser::OPTIONAL:
      case MIBParser::PRESENT: {
        enterOuterAlt(_localctx, 2);
        setState(640);
        componentValuePresence();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentValuePresenceContext ------------------------------------------------------------------

MIBParser::ComponentValuePresenceContext::ComponentValuePresenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::ValueOrConstraintListContext* MIBParser::ComponentValuePresenceContext::valueOrConstraintList() {
  return getRuleContext<MIBParser::ValueOrConstraintListContext>(0);
}

MIBParser::ComponentPresenceContext* MIBParser::ComponentValuePresenceContext::componentPresence() {
  return getRuleContext<MIBParser::ComponentPresenceContext>(0);
}


size_t MIBParser::ComponentValuePresenceContext::getRuleIndex() const {
  return MIBParser::RuleComponentValuePresence;
}

void MIBParser::ComponentValuePresenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponentValuePresence(this);
}

void MIBParser::ComponentValuePresenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponentValuePresence(this);
}

MIBParser::ComponentValuePresenceContext* MIBParser::componentValuePresence() {
  ComponentValuePresenceContext *_localctx = _tracker.createInstance<ComponentValuePresenceContext>(_ctx, getState());
  enterRule(_localctx, 130, MIBParser::RuleComponentValuePresence);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(648);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::LEFT_BRACE:
      case MIBParser::LEFT_PAREN: {
        enterOuterAlt(_localctx, 1);
        setState(643);
        valueOrConstraintList();
        setState(645);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 16) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 16)) & 2594073385365405697) != 0)) {
          setState(644);
          componentPresence();
        }
        break;
      }

      case MIBParser::ABSENT:
      case MIBParser::OPTIONAL:
      case MIBParser::PRESENT: {
        enterOuterAlt(_localctx, 2);
        setState(647);
        componentPresence();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentPresenceContext ------------------------------------------------------------------

MIBParser::ComponentPresenceContext::ComponentPresenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ComponentPresenceContext::PRESENT() {
  return getToken(MIBParser::PRESENT, 0);
}

tree::TerminalNode* MIBParser::ComponentPresenceContext::ABSENT() {
  return getToken(MIBParser::ABSENT, 0);
}

tree::TerminalNode* MIBParser::ComponentPresenceContext::OPTIONAL() {
  return getToken(MIBParser::OPTIONAL, 0);
}


size_t MIBParser::ComponentPresenceContext::getRuleIndex() const {
  return MIBParser::RuleComponentPresence;
}

void MIBParser::ComponentPresenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponentPresence(this);
}

void MIBParser::ComponentPresenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponentPresence(this);
}

MIBParser::ComponentPresenceContext* MIBParser::componentPresence() {
  ComponentPresenceContext *_localctx = _tracker.createInstance<ComponentPresenceContext>(_ctx, getState());
  enterRule(_localctx, 132, MIBParser::RuleComponentPresence);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(650);
    _la = _input->LA(1);
    if (!(((((_la - 16) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 16)) & 2594073385365405697) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueAssignmentContext ------------------------------------------------------------------

MIBParser::ValueAssignmentContext::ValueAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ValueAssignmentContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::TypeContext* MIBParser::ValueAssignmentContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}

tree::TerminalNode* MIBParser::ValueAssignmentContext::DEFINITION() {
  return getToken(MIBParser::DEFINITION, 0);
}

MIBParser::ValueContext* MIBParser::ValueAssignmentContext::value() {
  return getRuleContext<MIBParser::ValueContext>(0);
}


size_t MIBParser::ValueAssignmentContext::getRuleIndex() const {
  return MIBParser::RuleValueAssignment;
}

void MIBParser::ValueAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueAssignment(this);
}

void MIBParser::ValueAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueAssignment(this);
}

MIBParser::ValueAssignmentContext* MIBParser::valueAssignment() {
  ValueAssignmentContext *_localctx = _tracker.createInstance<ValueAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 134, MIBParser::RuleValueAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(652);
    match(MIBParser::IDENTIFIER_STRING);
    setState(653);
    type();
    setState(654);
    match(MIBParser::DEFINITION);
    setState(655);
    value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueContext ------------------------------------------------------------------

MIBParser::ValueContext::ValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::BuiltinValueContext* MIBParser::ValueContext::builtinValue() {
  return getRuleContext<MIBParser::BuiltinValueContext>(0);
}

MIBParser::DefinedValueContext* MIBParser::ValueContext::definedValue() {
  return getRuleContext<MIBParser::DefinedValueContext>(0);
}


size_t MIBParser::ValueContext::getRuleIndex() const {
  return MIBParser::RuleValue;
}

void MIBParser::ValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValue(this);
}

void MIBParser::ValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValue(this);
}

MIBParser::ValueContext* MIBParser::value() {
  ValueContext *_localctx = _tracker.createInstance<ValueContext>(_ctx, getState());
  enterRule(_localctx, 136, MIBParser::RuleValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(659);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(657);
      builtinValue();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(658);
      definedValue();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefinedValueContext ------------------------------------------------------------------

MIBParser::DefinedValueContext::DefinedValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::DefinedValueContext::INTEGER_STRING() {
  return getToken(MIBParser::INTEGER_STRING, 0);
}

tree::TerminalNode* MIBParser::DefinedValueContext::BINARY_STRING() {
  return getToken(MIBParser::BINARY_STRING, 0);
}

tree::TerminalNode* MIBParser::DefinedValueContext::HEXADECIMAL_STRING() {
  return getToken(MIBParser::HEXADECIMAL_STRING, 0);
}

tree::TerminalNode* MIBParser::DefinedValueContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::ModuleReferenceContext* MIBParser::DefinedValueContext::moduleReference() {
  return getRuleContext<MIBParser::ModuleReferenceContext>(0);
}


size_t MIBParser::DefinedValueContext::getRuleIndex() const {
  return MIBParser::RuleDefinedValue;
}

void MIBParser::DefinedValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefinedValue(this);
}

void MIBParser::DefinedValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefinedValue(this);
}

MIBParser::DefinedValueContext* MIBParser::definedValue() {
  DefinedValueContext *_localctx = _tracker.createInstance<DefinedValueContext>(_ctx, getState());
  enterRule(_localctx, 138, MIBParser::RuleDefinedValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(668);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::INTEGER_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(661);
        match(MIBParser::INTEGER_STRING);
        break;
      }

      case MIBParser::BINARY_STRING: {
        enterOuterAlt(_localctx, 2);
        setState(662);
        match(MIBParser::BINARY_STRING);
        break;
      }

      case MIBParser::HEXADECIMAL_STRING: {
        enterOuterAlt(_localctx, 3);
        setState(663);
        match(MIBParser::HEXADECIMAL_STRING);
        break;
      }

      case MIBParser::IDENTIFIER_STRING: {
        enterOuterAlt(_localctx, 4);
        setState(665);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
        case 1: {
          setState(664);
          moduleReference();
          break;
        }

        default:
          break;
        }
        setState(667);
        match(MIBParser::IDENTIFIER_STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BuiltinValueContext ------------------------------------------------------------------

MIBParser::BuiltinValueContext::BuiltinValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::NullValueContext* MIBParser::BuiltinValueContext::nullValue() {
  return getRuleContext<MIBParser::NullValueContext>(0);
}

MIBParser::BooleanValueContext* MIBParser::BuiltinValueContext::booleanValue() {
  return getRuleContext<MIBParser::BooleanValueContext>(0);
}

MIBParser::SpecialRealValueContext* MIBParser::BuiltinValueContext::specialRealValue() {
  return getRuleContext<MIBParser::SpecialRealValueContext>(0);
}

MIBParser::NumberValueContext* MIBParser::BuiltinValueContext::numberValue() {
  return getRuleContext<MIBParser::NumberValueContext>(0);
}

MIBParser::BinaryValueContext* MIBParser::BuiltinValueContext::binaryValue() {
  return getRuleContext<MIBParser::BinaryValueContext>(0);
}

MIBParser::HexadecimalValueContext* MIBParser::BuiltinValueContext::hexadecimalValue() {
  return getRuleContext<MIBParser::HexadecimalValueContext>(0);
}

MIBParser::StringValueContext* MIBParser::BuiltinValueContext::stringValue() {
  return getRuleContext<MIBParser::StringValueContext>(0);
}

MIBParser::BitOrObjectIdentifierValueContext* MIBParser::BuiltinValueContext::bitOrObjectIdentifierValue() {
  return getRuleContext<MIBParser::BitOrObjectIdentifierValueContext>(0);
}


size_t MIBParser::BuiltinValueContext::getRuleIndex() const {
  return MIBParser::RuleBuiltinValue;
}

void MIBParser::BuiltinValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBuiltinValue(this);
}

void MIBParser::BuiltinValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBuiltinValue(this);
}

MIBParser::BuiltinValueContext* MIBParser::builtinValue() {
  BuiltinValueContext *_localctx = _tracker.createInstance<BuiltinValueContext>(_ctx, getState());
  enterRule(_localctx, 140, MIBParser::RuleBuiltinValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(678);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::NULL_: {
        enterOuterAlt(_localctx, 1);
        setState(670);
        nullValue();
        break;
      }

      case MIBParser::FALSE:
      case MIBParser::TRUE: {
        enterOuterAlt(_localctx, 2);
        setState(671);
        booleanValue();
        break;
      }

      case MIBParser::MINUS_INFINITY:
      case MIBParser::PLUS_INFINITY: {
        enterOuterAlt(_localctx, 3);
        setState(672);
        specialRealValue();
        break;
      }

      case MIBParser::MINUS:
      case MIBParser::NUMBER_STRING: {
        enterOuterAlt(_localctx, 4);
        setState(673);
        numberValue();
        break;
      }

      case MIBParser::BINARY_STRING: {
        enterOuterAlt(_localctx, 5);
        setState(674);
        binaryValue();
        break;
      }

      case MIBParser::HEXADECIMAL_STRING: {
        enterOuterAlt(_localctx, 6);
        setState(675);
        hexadecimalValue();
        break;
      }

      case MIBParser::QUOTED_STRING: {
        enterOuterAlt(_localctx, 7);
        setState(676);
        stringValue();
        break;
      }

      case MIBParser::LEFT_BRACE: {
        enterOuterAlt(_localctx, 8);
        setState(677);
        bitOrObjectIdentifierValue();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullValueContext ------------------------------------------------------------------

MIBParser::NullValueContext::NullValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NullValueContext::NULL_() {
  return getToken(MIBParser::NULL_, 0);
}


size_t MIBParser::NullValueContext::getRuleIndex() const {
  return MIBParser::RuleNullValue;
}

void MIBParser::NullValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullValue(this);
}

void MIBParser::NullValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullValue(this);
}

MIBParser::NullValueContext* MIBParser::nullValue() {
  NullValueContext *_localctx = _tracker.createInstance<NullValueContext>(_ctx, getState());
  enterRule(_localctx, 142, MIBParser::RuleNullValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(680);
    match(MIBParser::NULL_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanValueContext ------------------------------------------------------------------

MIBParser::BooleanValueContext::BooleanValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::BooleanValueContext::TRUE() {
  return getToken(MIBParser::TRUE, 0);
}

tree::TerminalNode* MIBParser::BooleanValueContext::FALSE() {
  return getToken(MIBParser::FALSE, 0);
}


size_t MIBParser::BooleanValueContext::getRuleIndex() const {
  return MIBParser::RuleBooleanValue;
}

void MIBParser::BooleanValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanValue(this);
}

void MIBParser::BooleanValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanValue(this);
}

MIBParser::BooleanValueContext* MIBParser::booleanValue() {
  BooleanValueContext *_localctx = _tracker.createInstance<BooleanValueContext>(_ctx, getState());
  enterRule(_localctx, 144, MIBParser::RuleBooleanValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(682);
    _la = _input->LA(1);
    if (!(_la == MIBParser::FALSE

    || _la == MIBParser::TRUE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpecialRealValueContext ------------------------------------------------------------------

MIBParser::SpecialRealValueContext::SpecialRealValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SpecialRealValueContext::PLUS_INFINITY() {
  return getToken(MIBParser::PLUS_INFINITY, 0);
}

tree::TerminalNode* MIBParser::SpecialRealValueContext::MINUS_INFINITY() {
  return getToken(MIBParser::MINUS_INFINITY, 0);
}


size_t MIBParser::SpecialRealValueContext::getRuleIndex() const {
  return MIBParser::RuleSpecialRealValue;
}

void MIBParser::SpecialRealValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecialRealValue(this);
}

void MIBParser::SpecialRealValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecialRealValue(this);
}

MIBParser::SpecialRealValueContext* MIBParser::specialRealValue() {
  SpecialRealValueContext *_localctx = _tracker.createInstance<SpecialRealValueContext>(_ctx, getState());
  enterRule(_localctx, 146, MIBParser::RuleSpecialRealValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(684);
    _la = _input->LA(1);
    if (!(_la == MIBParser::MINUS_INFINITY

    || _la == MIBParser::PLUS_INFINITY)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberValueContext ------------------------------------------------------------------

MIBParser::NumberValueContext::NumberValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NumberValueContext::NUMBER_STRING() {
  return getToken(MIBParser::NUMBER_STRING, 0);
}

tree::TerminalNode* MIBParser::NumberValueContext::MINUS() {
  return getToken(MIBParser::MINUS, 0);
}


size_t MIBParser::NumberValueContext::getRuleIndex() const {
  return MIBParser::RuleNumberValue;
}

void MIBParser::NumberValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumberValue(this);
}

void MIBParser::NumberValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumberValue(this);
}

MIBParser::NumberValueContext* MIBParser::numberValue() {
  NumberValueContext *_localctx = _tracker.createInstance<NumberValueContext>(_ctx, getState());
  enterRule(_localctx, 148, MIBParser::RuleNumberValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(687);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::MINUS) {
      setState(686);
      match(MIBParser::MINUS);
    }
    setState(689);
    match(MIBParser::NUMBER_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryValueContext ------------------------------------------------------------------

MIBParser::BinaryValueContext::BinaryValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::BinaryValueContext::BINARY_STRING() {
  return getToken(MIBParser::BINARY_STRING, 0);
}


size_t MIBParser::BinaryValueContext::getRuleIndex() const {
  return MIBParser::RuleBinaryValue;
}

void MIBParser::BinaryValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryValue(this);
}

void MIBParser::BinaryValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryValue(this);
}

MIBParser::BinaryValueContext* MIBParser::binaryValue() {
  BinaryValueContext *_localctx = _tracker.createInstance<BinaryValueContext>(_ctx, getState());
  enterRule(_localctx, 150, MIBParser::RuleBinaryValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(691);
    match(MIBParser::BINARY_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HexadecimalValueContext ------------------------------------------------------------------

MIBParser::HexadecimalValueContext::HexadecimalValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::HexadecimalValueContext::HEXADECIMAL_STRING() {
  return getToken(MIBParser::HEXADECIMAL_STRING, 0);
}


size_t MIBParser::HexadecimalValueContext::getRuleIndex() const {
  return MIBParser::RuleHexadecimalValue;
}

void MIBParser::HexadecimalValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHexadecimalValue(this);
}

void MIBParser::HexadecimalValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHexadecimalValue(this);
}

MIBParser::HexadecimalValueContext* MIBParser::hexadecimalValue() {
  HexadecimalValueContext *_localctx = _tracker.createInstance<HexadecimalValueContext>(_ctx, getState());
  enterRule(_localctx, 152, MIBParser::RuleHexadecimalValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(693);
    match(MIBParser::HEXADECIMAL_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringValueContext ------------------------------------------------------------------

MIBParser::StringValueContext::StringValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::StringValueContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::StringValueContext::getRuleIndex() const {
  return MIBParser::RuleStringValue;
}

void MIBParser::StringValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringValue(this);
}

void MIBParser::StringValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringValue(this);
}

MIBParser::StringValueContext* MIBParser::stringValue() {
  StringValueContext *_localctx = _tracker.createInstance<StringValueContext>(_ctx, getState());
  enterRule(_localctx, 154, MIBParser::RuleStringValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(695);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitOrObjectIdentifierValueContext ------------------------------------------------------------------

MIBParser::BitOrObjectIdentifierValueContext::BitOrObjectIdentifierValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::NameValueListContext* MIBParser::BitOrObjectIdentifierValueContext::nameValueList() {
  return getRuleContext<MIBParser::NameValueListContext>(0);
}


size_t MIBParser::BitOrObjectIdentifierValueContext::getRuleIndex() const {
  return MIBParser::RuleBitOrObjectIdentifierValue;
}

void MIBParser::BitOrObjectIdentifierValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitOrObjectIdentifierValue(this);
}

void MIBParser::BitOrObjectIdentifierValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitOrObjectIdentifierValue(this);
}

MIBParser::BitOrObjectIdentifierValueContext* MIBParser::bitOrObjectIdentifierValue() {
  BitOrObjectIdentifierValueContext *_localctx = _tracker.createInstance<BitOrObjectIdentifierValueContext>(_ctx, getState());
  enterRule(_localctx, 156, MIBParser::RuleBitOrObjectIdentifierValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(697);
    nameValueList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitValueContext ------------------------------------------------------------------

MIBParser::BitValueContext::BitValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::NameValueListContext* MIBParser::BitValueContext::nameValueList() {
  return getRuleContext<MIBParser::NameValueListContext>(0);
}


size_t MIBParser::BitValueContext::getRuleIndex() const {
  return MIBParser::RuleBitValue;
}

void MIBParser::BitValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitValue(this);
}

void MIBParser::BitValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitValue(this);
}

MIBParser::BitValueContext* MIBParser::bitValue() {
  BitValueContext *_localctx = _tracker.createInstance<BitValueContext>(_ctx, getState());
  enterRule(_localctx, 158, MIBParser::RuleBitValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(699);
    nameValueList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectIdentifierValueContext ------------------------------------------------------------------

MIBParser::ObjectIdentifierValueContext::ObjectIdentifierValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::NameValueListContext* MIBParser::ObjectIdentifierValueContext::nameValueList() {
  return getRuleContext<MIBParser::NameValueListContext>(0);
}


size_t MIBParser::ObjectIdentifierValueContext::getRuleIndex() const {
  return MIBParser::RuleObjectIdentifierValue;
}

void MIBParser::ObjectIdentifierValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectIdentifierValue(this);
}

void MIBParser::ObjectIdentifierValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectIdentifierValue(this);
}

MIBParser::ObjectIdentifierValueContext* MIBParser::objectIdentifierValue() {
  ObjectIdentifierValueContext *_localctx = _tracker.createInstance<ObjectIdentifierValueContext>(_ctx, getState());
  enterRule(_localctx, 160, MIBParser::RuleObjectIdentifierValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(701);
    nameValueList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameValueListContext ------------------------------------------------------------------

MIBParser::NameValueListContext::NameValueListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NameValueListContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

tree::TerminalNode* MIBParser::NameValueListContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}

std::vector<MIBParser::NameValueComponentContext *> MIBParser::NameValueListContext::nameValueComponent() {
  return getRuleContexts<MIBParser::NameValueComponentContext>();
}

MIBParser::NameValueComponentContext* MIBParser::NameValueListContext::nameValueComponent(size_t i) {
  return getRuleContext<MIBParser::NameValueComponentContext>(i);
}


size_t MIBParser::NameValueListContext::getRuleIndex() const {
  return MIBParser::RuleNameValueList;
}

void MIBParser::NameValueListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNameValueList(this);
}

void MIBParser::NameValueListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNameValueList(this);
}

MIBParser::NameValueListContext* MIBParser::nameValueList() {
  NameValueListContext *_localctx = _tracker.createInstance<NameValueListContext>(_ctx, getState());
  enterRule(_localctx, 162, MIBParser::RuleNameValueList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(703);
    match(MIBParser::LEFT_BRACE);
    setState(707);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MIBParser::COMMA || _la == MIBParser::IDENTIFIER_STRING

    || _la == MIBParser::NUMBER_STRING) {
      setState(704);
      nameValueComponent();
      setState(709);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(710);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameValueComponentContext ------------------------------------------------------------------

MIBParser::NameValueComponentContext::NameValueComponentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::NameOrNumberContext* MIBParser::NameValueComponentContext::nameOrNumber() {
  return getRuleContext<MIBParser::NameOrNumberContext>(0);
}

tree::TerminalNode* MIBParser::NameValueComponentContext::COMMA() {
  return getToken(MIBParser::COMMA, 0);
}


size_t MIBParser::NameValueComponentContext::getRuleIndex() const {
  return MIBParser::RuleNameValueComponent;
}

void MIBParser::NameValueComponentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNameValueComponent(this);
}

void MIBParser::NameValueComponentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNameValueComponent(this);
}

MIBParser::NameValueComponentContext* MIBParser::nameValueComponent() {
  NameValueComponentContext *_localctx = _tracker.createInstance<NameValueComponentContext>(_ctx, getState());
  enterRule(_localctx, 164, MIBParser::RuleNameValueComponent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(713);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::COMMA) {
      setState(712);
      match(MIBParser::COMMA);
    }
    setState(715);
    nameOrNumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameOrNumberContext ------------------------------------------------------------------

MIBParser::NameOrNumberContext::NameOrNumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NameOrNumberContext::NUMBER_STRING() {
  return getToken(MIBParser::NUMBER_STRING, 0);
}

tree::TerminalNode* MIBParser::NameOrNumberContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::NameAndNumberContext* MIBParser::NameOrNumberContext::nameAndNumber() {
  return getRuleContext<MIBParser::NameAndNumberContext>(0);
}


size_t MIBParser::NameOrNumberContext::getRuleIndex() const {
  return MIBParser::RuleNameOrNumber;
}

void MIBParser::NameOrNumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNameOrNumber(this);
}

void MIBParser::NameOrNumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNameOrNumber(this);
}

MIBParser::NameOrNumberContext* MIBParser::nameOrNumber() {
  NameOrNumberContext *_localctx = _tracker.createInstance<NameOrNumberContext>(_ctx, getState());
  enterRule(_localctx, 166, MIBParser::RuleNameOrNumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(720);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(717);
      match(MIBParser::NUMBER_STRING);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(718);
      match(MIBParser::IDENTIFIER_STRING);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(719);
      nameAndNumber();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameAndNumberContext ------------------------------------------------------------------

MIBParser::NameAndNumberContext::NameAndNumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NameAndNumberContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

tree::TerminalNode* MIBParser::NameAndNumberContext::LEFT_PAREN() {
  return getToken(MIBParser::LEFT_PAREN, 0);
}

tree::TerminalNode* MIBParser::NameAndNumberContext::RIGHT_PAREN() {
  return getToken(MIBParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* MIBParser::NameAndNumberContext::NUMBER_STRING() {
  return getToken(MIBParser::NUMBER_STRING, 0);
}

MIBParser::DefinedValueContext* MIBParser::NameAndNumberContext::definedValue() {
  return getRuleContext<MIBParser::DefinedValueContext>(0);
}


size_t MIBParser::NameAndNumberContext::getRuleIndex() const {
  return MIBParser::RuleNameAndNumber;
}

void MIBParser::NameAndNumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNameAndNumber(this);
}

void MIBParser::NameAndNumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNameAndNumber(this);
}

MIBParser::NameAndNumberContext* MIBParser::nameAndNumber() {
  NameAndNumberContext *_localctx = _tracker.createInstance<NameAndNumberContext>(_ctx, getState());
  enterRule(_localctx, 168, MIBParser::RuleNameAndNumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(722);
    match(MIBParser::IDENTIFIER_STRING);
    setState(723);
    match(MIBParser::LEFT_PAREN);
    setState(726);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::NUMBER_STRING: {
        setState(724);
        match(MIBParser::NUMBER_STRING);
        break;
      }

      case MIBParser::BINARY_STRING:
      case MIBParser::HEXADECIMAL_STRING:
      case MIBParser::IDENTIFIER_STRING:
      case MIBParser::INTEGER_STRING: {
        setState(725);
        definedValue();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(728);
    match(MIBParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefinedMacroTypeContext ------------------------------------------------------------------

MIBParser::DefinedMacroTypeContext::DefinedMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::SnmpModuleIdentityMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpModuleIdentityMacroType() {
  return getRuleContext<MIBParser::SnmpModuleIdentityMacroTypeContext>(0);
}

MIBParser::SnmpObjectIdentityMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpObjectIdentityMacroType() {
  return getRuleContext<MIBParser::SnmpObjectIdentityMacroTypeContext>(0);
}

MIBParser::SnmpObjectTypeMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpObjectTypeMacroType() {
  return getRuleContext<MIBParser::SnmpObjectTypeMacroTypeContext>(0);
}

MIBParser::SnmpNotificationTypeMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpNotificationTypeMacroType() {
  return getRuleContext<MIBParser::SnmpNotificationTypeMacroTypeContext>(0);
}

MIBParser::SnmpTrapTypeMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpTrapTypeMacroType() {
  return getRuleContext<MIBParser::SnmpTrapTypeMacroTypeContext>(0);
}

MIBParser::SnmpTextualConventionMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpTextualConventionMacroType() {
  return getRuleContext<MIBParser::SnmpTextualConventionMacroTypeContext>(0);
}

MIBParser::SnmpObjectGroupMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpObjectGroupMacroType() {
  return getRuleContext<MIBParser::SnmpObjectGroupMacroTypeContext>(0);
}

MIBParser::SnmpNotificationGroupMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpNotificationGroupMacroType() {
  return getRuleContext<MIBParser::SnmpNotificationGroupMacroTypeContext>(0);
}

MIBParser::SnmpModuleComplianceMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpModuleComplianceMacroType() {
  return getRuleContext<MIBParser::SnmpModuleComplianceMacroTypeContext>(0);
}

MIBParser::SnmpAgentCapabilitiesMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpAgentCapabilitiesMacroType() {
  return getRuleContext<MIBParser::SnmpAgentCapabilitiesMacroTypeContext>(0);
}


size_t MIBParser::DefinedMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleDefinedMacroType;
}

void MIBParser::DefinedMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefinedMacroType(this);
}

void MIBParser::DefinedMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefinedMacroType(this);
}

MIBParser::DefinedMacroTypeContext* MIBParser::definedMacroType() {
  DefinedMacroTypeContext *_localctx = _tracker.createInstance<DefinedMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 170, MIBParser::RuleDefinedMacroType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(740);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::MODULE_IDENTITY: {
        enterOuterAlt(_localctx, 1);
        setState(730);
        snmpModuleIdentityMacroType();
        break;
      }

      case MIBParser::OBJECT_IDENTITY: {
        enterOuterAlt(_localctx, 2);
        setState(731);
        snmpObjectIdentityMacroType();
        break;
      }

      case MIBParser::OBJECT_TYPE: {
        enterOuterAlt(_localctx, 3);
        setState(732);
        snmpObjectTypeMacroType();
        break;
      }

      case MIBParser::NOTIFICATION_TYPE: {
        enterOuterAlt(_localctx, 4);
        setState(733);
        snmpNotificationTypeMacroType();
        break;
      }

      case MIBParser::TRAP_TYPE: {
        enterOuterAlt(_localctx, 5);
        setState(734);
        snmpTrapTypeMacroType();
        break;
      }

      case MIBParser::TEXTUAL_CONVENTION: {
        enterOuterAlt(_localctx, 6);
        setState(735);
        snmpTextualConventionMacroType();
        break;
      }

      case MIBParser::OBJECT_GROUP: {
        enterOuterAlt(_localctx, 7);
        setState(736);
        snmpObjectGroupMacroType();
        break;
      }

      case MIBParser::NOTIFICATION_GROUP: {
        enterOuterAlt(_localctx, 8);
        setState(737);
        snmpNotificationGroupMacroType();
        break;
      }

      case MIBParser::MODULE_COMPLIANCE: {
        enterOuterAlt(_localctx, 9);
        setState(738);
        snmpModuleComplianceMacroType();
        break;
      }

      case MIBParser::AGENT_CAPABILITIES: {
        enterOuterAlt(_localctx, 10);
        setState(739);
        snmpAgentCapabilitiesMacroType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefinedMacroNameContext ------------------------------------------------------------------

MIBParser::DefinedMacroNameContext::DefinedMacroNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::MODULE_IDENTITY() {
  return getToken(MIBParser::MODULE_IDENTITY, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::OBJECT_IDENTITY() {
  return getToken(MIBParser::OBJECT_IDENTITY, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::OBJECT_TYPE() {
  return getToken(MIBParser::OBJECT_TYPE, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::NOTIFICATION_TYPE() {
  return getToken(MIBParser::NOTIFICATION_TYPE, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::TRAP_TYPE() {
  return getToken(MIBParser::TRAP_TYPE, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::TEXTUAL_CONVENTION() {
  return getToken(MIBParser::TEXTUAL_CONVENTION, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::OBJECT_GROUP() {
  return getToken(MIBParser::OBJECT_GROUP, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::NOTIFICATION_GROUP() {
  return getToken(MIBParser::NOTIFICATION_GROUP, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::MODULE_COMPLIANCE() {
  return getToken(MIBParser::MODULE_COMPLIANCE, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::AGENT_CAPABILITIES() {
  return getToken(MIBParser::AGENT_CAPABILITIES, 0);
}


size_t MIBParser::DefinedMacroNameContext::getRuleIndex() const {
  return MIBParser::RuleDefinedMacroName;
}

void MIBParser::DefinedMacroNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefinedMacroName(this);
}

void MIBParser::DefinedMacroNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefinedMacroName(this);
}

MIBParser::DefinedMacroNameContext* MIBParser::definedMacroName() {
  DefinedMacroNameContext *_localctx = _tracker.createInstance<DefinedMacroNameContext>(_ctx, getState());
  enterRule(_localctx, 172, MIBParser::RuleDefinedMacroName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(742);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -5764607523033710592) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 3221225585) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpStatusDescrReferPartContext ------------------------------------------------------------------

MIBParser::SnmpStatusDescrReferPartContext::SnmpStatusDescrReferPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::SnmpStatusPartContext* MIBParser::SnmpStatusDescrReferPartContext::snmpStatusPart() {
  return getRuleContext<MIBParser::SnmpStatusPartContext>(0);
}

MIBParser::SnmpDescrPartContext* MIBParser::SnmpStatusDescrReferPartContext::snmpDescrPart() {
  return getRuleContext<MIBParser::SnmpDescrPartContext>(0);
}

MIBParser::SnmpReferPartContext* MIBParser::SnmpStatusDescrReferPartContext::snmpReferPart() {
  return getRuleContext<MIBParser::SnmpReferPartContext>(0);
}


size_t MIBParser::SnmpStatusDescrReferPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpStatusDescrReferPart;
}

void MIBParser::SnmpStatusDescrReferPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpStatusDescrReferPart(this);
}

void MIBParser::SnmpStatusDescrReferPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpStatusDescrReferPart(this);
}

MIBParser::SnmpStatusDescrReferPartContext* MIBParser::snmpStatusDescrReferPart() {
  SnmpStatusDescrReferPartContext *_localctx = _tracker.createInstance<SnmpStatusDescrReferPartContext>(_ctx, getState());
  enterRule(_localctx, 174, MIBParser::RuleSnmpStatusDescrReferPart);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(744);
    snmpStatusPart();
    setState(745);
    snmpDescrPart();
    setState(747);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::REFERENCE) {
      setState(746);
      snmpReferPart();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpObjectStatusDescrReferPartContext ------------------------------------------------------------------

MIBParser::SnmpObjectStatusDescrReferPartContext::SnmpObjectStatusDescrReferPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::SnmpObjectsPartContext* MIBParser::SnmpObjectStatusDescrReferPartContext::snmpObjectsPart() {
  return getRuleContext<MIBParser::SnmpObjectsPartContext>(0);
}

MIBParser::SnmpStatusDescrReferPartContext* MIBParser::SnmpObjectStatusDescrReferPartContext::snmpStatusDescrReferPart() {
  return getRuleContext<MIBParser::SnmpStatusDescrReferPartContext>(0);
}


size_t MIBParser::SnmpObjectStatusDescrReferPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpObjectStatusDescrReferPart;
}

void MIBParser::SnmpObjectStatusDescrReferPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpObjectStatusDescrReferPart(this);
}

void MIBParser::SnmpObjectStatusDescrReferPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpObjectStatusDescrReferPart(this);
}

MIBParser::SnmpObjectStatusDescrReferPartContext* MIBParser::snmpObjectStatusDescrReferPart() {
  SnmpObjectStatusDescrReferPartContext *_localctx = _tracker.createInstance<SnmpObjectStatusDescrReferPartContext>(_ctx, getState());
  enterRule(_localctx, 176, MIBParser::RuleSnmpObjectStatusDescrReferPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(749);
    snmpObjectsPart();
    setState(750);
    snmpStatusDescrReferPart();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpModuleIdentityMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpModuleIdentityMacroTypeContext::SnmpModuleIdentityMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpModuleIdentityMacroTypeContext::MODULE_IDENTITY() {
  return getToken(MIBParser::MODULE_IDENTITY, 0);
}

MIBParser::SnmpUpdatePartContext* MIBParser::SnmpModuleIdentityMacroTypeContext::snmpUpdatePart() {
  return getRuleContext<MIBParser::SnmpUpdatePartContext>(0);
}

MIBParser::SnmpOrganizationPartContext* MIBParser::SnmpModuleIdentityMacroTypeContext::snmpOrganizationPart() {
  return getRuleContext<MIBParser::SnmpOrganizationPartContext>(0);
}

MIBParser::SnmpContactPartContext* MIBParser::SnmpModuleIdentityMacroTypeContext::snmpContactPart() {
  return getRuleContext<MIBParser::SnmpContactPartContext>(0);
}

MIBParser::SnmpDescrPartContext* MIBParser::SnmpModuleIdentityMacroTypeContext::snmpDescrPart() {
  return getRuleContext<MIBParser::SnmpDescrPartContext>(0);
}

std::vector<MIBParser::SnmpRevisionPartContext *> MIBParser::SnmpModuleIdentityMacroTypeContext::snmpRevisionPart() {
  return getRuleContexts<MIBParser::SnmpRevisionPartContext>();
}

MIBParser::SnmpRevisionPartContext* MIBParser::SnmpModuleIdentityMacroTypeContext::snmpRevisionPart(size_t i) {
  return getRuleContext<MIBParser::SnmpRevisionPartContext>(i);
}


size_t MIBParser::SnmpModuleIdentityMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpModuleIdentityMacroType;
}

void MIBParser::SnmpModuleIdentityMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpModuleIdentityMacroType(this);
}

void MIBParser::SnmpModuleIdentityMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpModuleIdentityMacroType(this);
}

MIBParser::SnmpModuleIdentityMacroTypeContext* MIBParser::snmpModuleIdentityMacroType() {
  SnmpModuleIdentityMacroTypeContext *_localctx = _tracker.createInstance<SnmpModuleIdentityMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 178, MIBParser::RuleSnmpModuleIdentityMacroType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(752);
    match(MIBParser::MODULE_IDENTITY);
    setState(753);
    snmpUpdatePart();
    setState(754);
    snmpOrganizationPart();
    setState(755);
    snmpContactPart();
    setState(756);
    snmpDescrPart();
    setState(760);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MIBParser::REVISION) {
      setState(757);
      snmpRevisionPart();
      setState(762);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpObjectIdentityMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpObjectIdentityMacroTypeContext::SnmpObjectIdentityMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpObjectIdentityMacroTypeContext::OBJECT_IDENTITY() {
  return getToken(MIBParser::OBJECT_IDENTITY, 0);
}

MIBParser::SnmpStatusDescrReferPartContext* MIBParser::SnmpObjectIdentityMacroTypeContext::snmpStatusDescrReferPart() {
  return getRuleContext<MIBParser::SnmpStatusDescrReferPartContext>(0);
}


size_t MIBParser::SnmpObjectIdentityMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpObjectIdentityMacroType;
}

void MIBParser::SnmpObjectIdentityMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpObjectIdentityMacroType(this);
}

void MIBParser::SnmpObjectIdentityMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpObjectIdentityMacroType(this);
}

MIBParser::SnmpObjectIdentityMacroTypeContext* MIBParser::snmpObjectIdentityMacroType() {
  SnmpObjectIdentityMacroTypeContext *_localctx = _tracker.createInstance<SnmpObjectIdentityMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 180, MIBParser::RuleSnmpObjectIdentityMacroType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(763);
    match(MIBParser::OBJECT_IDENTITY);
    setState(764);
    snmpStatusDescrReferPart();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpObjectTypeMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpObjectTypeMacroTypeContext::SnmpObjectTypeMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpObjectTypeMacroTypeContext::OBJECT_TYPE() {
  return getToken(MIBParser::OBJECT_TYPE, 0);
}

MIBParser::SnmpSyntaxPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpSyntaxPart() {
  return getRuleContext<MIBParser::SnmpSyntaxPartContext>(0);
}

MIBParser::SnmpMaxAccessPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpMaxAccessPart() {
  return getRuleContext<MIBParser::SnmpMaxAccessPartContext>(0);
}

MIBParser::SnmpStatusPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpStatusPart() {
  return getRuleContext<MIBParser::SnmpStatusPartContext>(0);
}

MIBParser::SnmpDescrPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpDescrPart() {
  return getRuleContext<MIBParser::SnmpDescrPartContext>(0);
}

MIBParser::SnmpUnitsPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpUnitsPart() {
  return getRuleContext<MIBParser::SnmpUnitsPartContext>(0);
}

MIBParser::SnmpAccessPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpAccessPart() {
  return getRuleContext<MIBParser::SnmpAccessPartContext>(0);
}

MIBParser::SnmpIndexPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpIndexPart() {
  return getRuleContext<MIBParser::SnmpIndexPartContext>(0);
}

MIBParser::SnmpDefValPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpDefValPart() {
  return getRuleContext<MIBParser::SnmpDefValPartContext>(0);
}


size_t MIBParser::SnmpObjectTypeMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpObjectTypeMacroType;
}

void MIBParser::SnmpObjectTypeMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpObjectTypeMacroType(this);
}

void MIBParser::SnmpObjectTypeMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpObjectTypeMacroType(this);
}

MIBParser::SnmpObjectTypeMacroTypeContext* MIBParser::snmpObjectTypeMacroType() {
  SnmpObjectTypeMacroTypeContext *_localctx = _tracker.createInstance<SnmpObjectTypeMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 182, MIBParser::RuleSnmpObjectTypeMacroType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(766);
    match(MIBParser::OBJECT_TYPE);
    setState(767);
    snmpSyntaxPart();
    setState(769);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::UNITS) {
      setState(768);
      snmpUnitsPart();
    }
    setState(772);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::ACCESS) {
      setState(771);
      snmpAccessPart();
    }
    setState(774);
    snmpMaxAccessPart();
    setState(775);
    snmpStatusPart();
    setState(776);
    snmpDescrPart();
    setState(778);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
    case 1: {
      setState(777);
      snmpIndexPart();
      break;
    }

    default:
      break;
    }
    setState(781);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
    case 1: {
      setState(780);
      snmpDefValPart();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpNotificationTypeMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpNotificationTypeMacroTypeContext::SnmpNotificationTypeMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpNotificationTypeMacroTypeContext::NOTIFICATION_TYPE() {
  return getToken(MIBParser::NOTIFICATION_TYPE, 0);
}

MIBParser::SnmpObjectStatusDescrReferPartContext* MIBParser::SnmpNotificationTypeMacroTypeContext::snmpObjectStatusDescrReferPart() {
  return getRuleContext<MIBParser::SnmpObjectStatusDescrReferPartContext>(0);
}


size_t MIBParser::SnmpNotificationTypeMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpNotificationTypeMacroType;
}

void MIBParser::SnmpNotificationTypeMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpNotificationTypeMacroType(this);
}

void MIBParser::SnmpNotificationTypeMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpNotificationTypeMacroType(this);
}

MIBParser::SnmpNotificationTypeMacroTypeContext* MIBParser::snmpNotificationTypeMacroType() {
  SnmpNotificationTypeMacroTypeContext *_localctx = _tracker.createInstance<SnmpNotificationTypeMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 184, MIBParser::RuleSnmpNotificationTypeMacroType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(783);
    match(MIBParser::NOTIFICATION_TYPE);
    setState(784);
    snmpObjectStatusDescrReferPart();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpTrapTypeMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpTrapTypeMacroTypeContext::SnmpTrapTypeMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpTrapTypeMacroTypeContext::TRAP_TYPE() {
  return getToken(MIBParser::TRAP_TYPE, 0);
}

MIBParser::SnmpEnterprisePartContext* MIBParser::SnmpTrapTypeMacroTypeContext::snmpEnterprisePart() {
  return getRuleContext<MIBParser::SnmpEnterprisePartContext>(0);
}

MIBParser::SnmpDescrPartContext* MIBParser::SnmpTrapTypeMacroTypeContext::snmpDescrPart() {
  return getRuleContext<MIBParser::SnmpDescrPartContext>(0);
}

MIBParser::SnmpVarPartContext* MIBParser::SnmpTrapTypeMacroTypeContext::snmpVarPart() {
  return getRuleContext<MIBParser::SnmpVarPartContext>(0);
}

MIBParser::SnmpReferPartContext* MIBParser::SnmpTrapTypeMacroTypeContext::snmpReferPart() {
  return getRuleContext<MIBParser::SnmpReferPartContext>(0);
}


size_t MIBParser::SnmpTrapTypeMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpTrapTypeMacroType;
}

void MIBParser::SnmpTrapTypeMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpTrapTypeMacroType(this);
}

void MIBParser::SnmpTrapTypeMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpTrapTypeMacroType(this);
}

MIBParser::SnmpTrapTypeMacroTypeContext* MIBParser::snmpTrapTypeMacroType() {
  SnmpTrapTypeMacroTypeContext *_localctx = _tracker.createInstance<SnmpTrapTypeMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 186, MIBParser::RuleSnmpTrapTypeMacroType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(786);
    match(MIBParser::TRAP_TYPE);
    setState(787);
    snmpEnterprisePart();
    setState(789);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::VARIABLES) {
      setState(788);
      snmpVarPart();
    }
    setState(791);
    snmpDescrPart();
    setState(793);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::REFERENCE) {
      setState(792);
      snmpReferPart();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpTextualConventionMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpTextualConventionMacroTypeContext::SnmpTextualConventionMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpTextualConventionMacroTypeContext::TEXTUAL_CONVENTION() {
  return getToken(MIBParser::TEXTUAL_CONVENTION, 0);
}

MIBParser::SnmpStatusDescrReferPartContext* MIBParser::SnmpTextualConventionMacroTypeContext::snmpStatusDescrReferPart() {
  return getRuleContext<MIBParser::SnmpStatusDescrReferPartContext>(0);
}

MIBParser::SnmpSyntaxPartContext* MIBParser::SnmpTextualConventionMacroTypeContext::snmpSyntaxPart() {
  return getRuleContext<MIBParser::SnmpSyntaxPartContext>(0);
}


size_t MIBParser::SnmpTextualConventionMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpTextualConventionMacroType;
}

void MIBParser::SnmpTextualConventionMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpTextualConventionMacroType(this);
}

void MIBParser::SnmpTextualConventionMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpTextualConventionMacroType(this);
}

MIBParser::SnmpTextualConventionMacroTypeContext* MIBParser::snmpTextualConventionMacroType() {
  SnmpTextualConventionMacroTypeContext *_localctx = _tracker.createInstance<SnmpTextualConventionMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 188, MIBParser::RuleSnmpTextualConventionMacroType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(795);
    match(MIBParser::TEXTUAL_CONVENTION);
    setState(796);
    snmpStatusDescrReferPart();
    setState(797);
    snmpSyntaxPart();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpObjectGroupMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpObjectGroupMacroTypeContext::SnmpObjectGroupMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpObjectGroupMacroTypeContext::OBJECT_GROUP() {
  return getToken(MIBParser::OBJECT_GROUP, 0);
}

MIBParser::SnmpObjectStatusDescrReferPartContext* MIBParser::SnmpObjectGroupMacroTypeContext::snmpObjectStatusDescrReferPart() {
  return getRuleContext<MIBParser::SnmpObjectStatusDescrReferPartContext>(0);
}


size_t MIBParser::SnmpObjectGroupMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpObjectGroupMacroType;
}

void MIBParser::SnmpObjectGroupMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpObjectGroupMacroType(this);
}

void MIBParser::SnmpObjectGroupMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpObjectGroupMacroType(this);
}

MIBParser::SnmpObjectGroupMacroTypeContext* MIBParser::snmpObjectGroupMacroType() {
  SnmpObjectGroupMacroTypeContext *_localctx = _tracker.createInstance<SnmpObjectGroupMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 190, MIBParser::RuleSnmpObjectGroupMacroType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(799);
    match(MIBParser::OBJECT_GROUP);
    setState(800);
    snmpObjectStatusDescrReferPart();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpNotificationGroupMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpNotificationGroupMacroTypeContext::SnmpNotificationGroupMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpNotificationGroupMacroTypeContext::NOTIFICATION_GROUP() {
  return getToken(MIBParser::NOTIFICATION_GROUP, 0);
}

MIBParser::SnmpNotificationPartContext* MIBParser::SnmpNotificationGroupMacroTypeContext::snmpNotificationPart() {
  return getRuleContext<MIBParser::SnmpNotificationPartContext>(0);
}

MIBParser::SnmpStatusPartContext* MIBParser::SnmpNotificationGroupMacroTypeContext::snmpStatusPart() {
  return getRuleContext<MIBParser::SnmpStatusPartContext>(0);
}

MIBParser::SnmpDescrPartContext* MIBParser::SnmpNotificationGroupMacroTypeContext::snmpDescrPart() {
  return getRuleContext<MIBParser::SnmpDescrPartContext>(0);
}

MIBParser::SnmpSyntaxPartContext* MIBParser::SnmpNotificationGroupMacroTypeContext::snmpSyntaxPart() {
  return getRuleContext<MIBParser::SnmpSyntaxPartContext>(0);
}

MIBParser::SnmpMaxAccessPartContext* MIBParser::SnmpNotificationGroupMacroTypeContext::snmpMaxAccessPart() {
  return getRuleContext<MIBParser::SnmpMaxAccessPartContext>(0);
}


size_t MIBParser::SnmpNotificationGroupMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpNotificationGroupMacroType;
}

void MIBParser::SnmpNotificationGroupMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpNotificationGroupMacroType(this);
}

void MIBParser::SnmpNotificationGroupMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpNotificationGroupMacroType(this);
}

MIBParser::SnmpNotificationGroupMacroTypeContext* MIBParser::snmpNotificationGroupMacroType() {
  SnmpNotificationGroupMacroTypeContext *_localctx = _tracker.createInstance<SnmpNotificationGroupMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 192, MIBParser::RuleSnmpNotificationGroupMacroType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(802);
    match(MIBParser::NOTIFICATION_GROUP);
    setState(803);
    snmpNotificationPart();
    setState(805);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::SYNTAX) {
      setState(804);
      snmpSyntaxPart();
    }
    setState(808);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::MAX_ACCESS) {
      setState(807);
      snmpMaxAccessPart();
    }
    setState(810);
    snmpStatusPart();
    setState(811);
    snmpDescrPart();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpModuleComplianceMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpModuleComplianceMacroTypeContext::SnmpModuleComplianceMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpModuleComplianceMacroTypeContext::MODULE_COMPLIANCE() {
  return getToken(MIBParser::MODULE_COMPLIANCE, 0);
}

MIBParser::SnmpStatusDescrReferPartContext* MIBParser::SnmpModuleComplianceMacroTypeContext::snmpStatusDescrReferPart() {
  return getRuleContext<MIBParser::SnmpStatusDescrReferPartContext>(0);
}

MIBParser::SnmpModulesPartContext* MIBParser::SnmpModuleComplianceMacroTypeContext::snmpModulesPart() {
  return getRuleContext<MIBParser::SnmpModulesPartContext>(0);
}

std::vector<MIBParser::SnmpGroupPartContext *> MIBParser::SnmpModuleComplianceMacroTypeContext::snmpGroupPart() {
  return getRuleContexts<MIBParser::SnmpGroupPartContext>();
}

MIBParser::SnmpGroupPartContext* MIBParser::SnmpModuleComplianceMacroTypeContext::snmpGroupPart(size_t i) {
  return getRuleContext<MIBParser::SnmpGroupPartContext>(i);
}

tree::TerminalNode* MIBParser::SnmpModuleComplianceMacroTypeContext::MODULE() {
  return getToken(MIBParser::MODULE, 0);
}

MIBParser::SnmpMandatoryGroupsPartContext* MIBParser::SnmpModuleComplianceMacroTypeContext::snmpMandatoryGroupsPart() {
  return getRuleContext<MIBParser::SnmpMandatoryGroupsPartContext>(0);
}


size_t MIBParser::SnmpModuleComplianceMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpModuleComplianceMacroType;
}

void MIBParser::SnmpModuleComplianceMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpModuleComplianceMacroType(this);
}

void MIBParser::SnmpModuleComplianceMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpModuleComplianceMacroType(this);
}

MIBParser::SnmpModuleComplianceMacroTypeContext* MIBParser::snmpModuleComplianceMacroType() {
  SnmpModuleComplianceMacroTypeContext *_localctx = _tracker.createInstance<SnmpModuleComplianceMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 194, MIBParser::RuleSnmpModuleComplianceMacroType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(813);
    match(MIBParser::MODULE_COMPLIANCE);
    setState(814);
    snmpStatusDescrReferPart();
    setState(818);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MIBParser::GROUP) {
      setState(815);
      snmpGroupPart();
      setState(820);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(824);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::MODULE: {
        setState(821);
        match(MIBParser::MODULE);
        setState(822);
        snmpMandatoryGroupsPart();
        break;
      }

      case MIBParser::MODULES: {
        setState(823);
        snmpModulesPart();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpAgentCapabilitiesMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpAgentCapabilitiesMacroTypeContext::SnmpAgentCapabilitiesMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpAgentCapabilitiesMacroTypeContext::AGENT_CAPABILITIES() {
  return getToken(MIBParser::AGENT_CAPABILITIES, 0);
}

MIBParser::SnmpProductPartContext* MIBParser::SnmpAgentCapabilitiesMacroTypeContext::snmpProductPart() {
  return getRuleContext<MIBParser::SnmpProductPartContext>(0);
}

MIBParser::SnmpStatusDescrReferPartContext* MIBParser::SnmpAgentCapabilitiesMacroTypeContext::snmpStatusDescrReferPart() {
  return getRuleContext<MIBParser::SnmpStatusDescrReferPartContext>(0);
}

std::vector<MIBParser::SnmpSupportPartContext *> MIBParser::SnmpAgentCapabilitiesMacroTypeContext::snmpSupportPart() {
  return getRuleContexts<MIBParser::SnmpSupportPartContext>();
}

MIBParser::SnmpSupportPartContext* MIBParser::SnmpAgentCapabilitiesMacroTypeContext::snmpSupportPart(size_t i) {
  return getRuleContext<MIBParser::SnmpSupportPartContext>(i);
}


size_t MIBParser::SnmpAgentCapabilitiesMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpAgentCapabilitiesMacroType;
}

void MIBParser::SnmpAgentCapabilitiesMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpAgentCapabilitiesMacroType(this);
}

void MIBParser::SnmpAgentCapabilitiesMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpAgentCapabilitiesMacroType(this);
}

MIBParser::SnmpAgentCapabilitiesMacroTypeContext* MIBParser::snmpAgentCapabilitiesMacroType() {
  SnmpAgentCapabilitiesMacroTypeContext *_localctx = _tracker.createInstance<SnmpAgentCapabilitiesMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 196, MIBParser::RuleSnmpAgentCapabilitiesMacroType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(826);
    match(MIBParser::AGENT_CAPABILITIES);
    setState(827);
    snmpProductPart();
    setState(828);
    snmpStatusDescrReferPart();
    setState(832);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(829);
        snmpSupportPart(); 
      }
      setState(834);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpSupportPartContext ------------------------------------------------------------------

MIBParser::SnmpSupportPartContext::SnmpSupportPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpSupportPartContext::SUPPORTS() {
  return getToken(MIBParser::SUPPORTS, 0);
}

MIBParser::ModuleIdentifierContext* MIBParser::SnmpSupportPartContext::moduleIdentifier() {
  return getRuleContext<MIBParser::ModuleIdentifierContext>(0);
}

MIBParser::SnmpInclusionPartContext* MIBParser::SnmpSupportPartContext::snmpInclusionPart() {
  return getRuleContext<MIBParser::SnmpInclusionPartContext>(0);
}

MIBParser::SnmpVariationPartContext* MIBParser::SnmpSupportPartContext::snmpVariationPart() {
  return getRuleContext<MIBParser::SnmpVariationPartContext>(0);
}


size_t MIBParser::SnmpSupportPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpSupportPart;
}

void MIBParser::SnmpSupportPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpSupportPart(this);
}

void MIBParser::SnmpSupportPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpSupportPart(this);
}

MIBParser::SnmpSupportPartContext* MIBParser::snmpSupportPart() {
  SnmpSupportPartContext *_localctx = _tracker.createInstance<SnmpSupportPartContext>(_ctx, getState());
  enterRule(_localctx, 198, MIBParser::RuleSnmpSupportPart);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(835);
    match(MIBParser::SUPPORTS);
    setState(836);
    moduleIdentifier();
    setState(837);
    snmpInclusionPart();
    setState(839);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::VARIATION) {
      setState(838);
      snmpVariationPart();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpInclusionPartContext ------------------------------------------------------------------

MIBParser::SnmpInclusionPartContext::SnmpInclusionPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpInclusionPartContext::INCLUDES() {
  return getToken(MIBParser::INCLUDES, 0);
}

MIBParser::SymbolListContext* MIBParser::SnmpInclusionPartContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}


size_t MIBParser::SnmpInclusionPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpInclusionPart;
}

void MIBParser::SnmpInclusionPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpInclusionPart(this);
}

void MIBParser::SnmpInclusionPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpInclusionPart(this);
}

MIBParser::SnmpInclusionPartContext* MIBParser::snmpInclusionPart() {
  SnmpInclusionPartContext *_localctx = _tracker.createInstance<SnmpInclusionPartContext>(_ctx, getState());
  enterRule(_localctx, 200, MIBParser::RuleSnmpInclusionPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(841);
    match(MIBParser::INCLUDES);
    setState(842);
    symbolList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpVariationPartContext ------------------------------------------------------------------

MIBParser::SnmpVariationPartContext::SnmpVariationPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpVariationPartContext::VARIATION() {
  return getToken(MIBParser::VARIATION, 0);
}

tree::TerminalNode* MIBParser::SnmpVariationPartContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::SnmpSyntaxPartContext* MIBParser::SnmpVariationPartContext::snmpSyntaxPart() {
  return getRuleContext<MIBParser::SnmpSyntaxPartContext>(0);
}

MIBParser::SnmpAccessPartContext* MIBParser::SnmpVariationPartContext::snmpAccessPart() {
  return getRuleContext<MIBParser::SnmpAccessPartContext>(0);
}

MIBParser::SnmpWritePartContext* MIBParser::SnmpVariationPartContext::snmpWritePart() {
  return getRuleContext<MIBParser::SnmpWritePartContext>(0);
}

MIBParser::SnmpDefValPartContext* MIBParser::SnmpVariationPartContext::snmpDefValPart() {
  return getRuleContext<MIBParser::SnmpDefValPartContext>(0);
}


size_t MIBParser::SnmpVariationPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpVariationPart;
}

void MIBParser::SnmpVariationPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpVariationPart(this);
}

void MIBParser::SnmpVariationPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpVariationPart(this);
}

MIBParser::SnmpVariationPartContext* MIBParser::snmpVariationPart() {
  SnmpVariationPartContext *_localctx = _tracker.createInstance<SnmpVariationPartContext>(_ctx, getState());
  enterRule(_localctx, 202, MIBParser::RuleSnmpVariationPart);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(844);
    match(MIBParser::VARIATION);
    setState(845);
    match(MIBParser::IDENTIFIER_STRING);
    setState(854);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::SYNTAX: {
        setState(846);
        snmpSyntaxPart();
        break;
      }

      case MIBParser::ACCESS:
      case MIBParser::WRITE_SYNTAX: {
        setState(848);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MIBParser::WRITE_SYNTAX) {
          setState(847);
          snmpWritePart();
        }
        setState(850);
        snmpAccessPart();
        setState(852);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx)) {
        case 1: {
          setState(851);
          snmpDefValPart();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpGroupPartContext ------------------------------------------------------------------

MIBParser::SnmpGroupPartContext::SnmpGroupPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpGroupPartContext::GROUP() {
  return getToken(MIBParser::GROUP, 0);
}

tree::TerminalNode* MIBParser::SnmpGroupPartContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::SnmpDescrPartContext* MIBParser::SnmpGroupPartContext::snmpDescrPart() {
  return getRuleContext<MIBParser::SnmpDescrPartContext>(0);
}

MIBParser::SnmpReferPartContext* MIBParser::SnmpGroupPartContext::snmpReferPart() {
  return getRuleContext<MIBParser::SnmpReferPartContext>(0);
}


size_t MIBParser::SnmpGroupPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpGroupPart;
}

void MIBParser::SnmpGroupPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpGroupPart(this);
}

void MIBParser::SnmpGroupPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpGroupPart(this);
}

MIBParser::SnmpGroupPartContext* MIBParser::snmpGroupPart() {
  SnmpGroupPartContext *_localctx = _tracker.createInstance<SnmpGroupPartContext>(_ctx, getState());
  enterRule(_localctx, 204, MIBParser::RuleSnmpGroupPart);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(856);
    match(MIBParser::GROUP);
    setState(857);
    match(MIBParser::IDENTIFIER_STRING);
    setState(858);
    snmpDescrPart();
    setState(860);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::REFERENCE) {
      setState(859);
      snmpReferPart();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpAccessPartContext ------------------------------------------------------------------

MIBParser::SnmpAccessPartContext::SnmpAccessPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpAccessPartContext::ACCESS() {
  return getToken(MIBParser::ACCESS, 0);
}

tree::TerminalNode* MIBParser::SnmpAccessPartContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}


size_t MIBParser::SnmpAccessPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpAccessPart;
}

void MIBParser::SnmpAccessPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpAccessPart(this);
}

void MIBParser::SnmpAccessPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpAccessPart(this);
}

MIBParser::SnmpAccessPartContext* MIBParser::snmpAccessPart() {
  SnmpAccessPartContext *_localctx = _tracker.createInstance<SnmpAccessPartContext>(_ctx, getState());
  enterRule(_localctx, 206, MIBParser::RuleSnmpAccessPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(862);
    match(MIBParser::ACCESS);
    setState(863);
    match(MIBParser::IDENTIFIER_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpContactPartContext ------------------------------------------------------------------

MIBParser::SnmpContactPartContext::SnmpContactPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpContactPartContext::CONTACT_INFO() {
  return getToken(MIBParser::CONTACT_INFO, 0);
}

tree::TerminalNode* MIBParser::SnmpContactPartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpContactPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpContactPart;
}

void MIBParser::SnmpContactPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpContactPart(this);
}

void MIBParser::SnmpContactPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpContactPart(this);
}

MIBParser::SnmpContactPartContext* MIBParser::snmpContactPart() {
  SnmpContactPartContext *_localctx = _tracker.createInstance<SnmpContactPartContext>(_ctx, getState());
  enterRule(_localctx, 208, MIBParser::RuleSnmpContactPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(865);
    match(MIBParser::CONTACT_INFO);
    setState(866);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpDefValPartContext ------------------------------------------------------------------

MIBParser::SnmpDefValPartContext::SnmpDefValPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpDefValPartContext::DEFVAL() {
  return getToken(MIBParser::DEFVAL, 0);
}

tree::TerminalNode* MIBParser::SnmpDefValPartContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

MIBParser::ValueContext* MIBParser::SnmpDefValPartContext::value() {
  return getRuleContext<MIBParser::ValueContext>(0);
}

tree::TerminalNode* MIBParser::SnmpDefValPartContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}


size_t MIBParser::SnmpDefValPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpDefValPart;
}

void MIBParser::SnmpDefValPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpDefValPart(this);
}

void MIBParser::SnmpDefValPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpDefValPart(this);
}

MIBParser::SnmpDefValPartContext* MIBParser::snmpDefValPart() {
  SnmpDefValPartContext *_localctx = _tracker.createInstance<SnmpDefValPartContext>(_ctx, getState());
  enterRule(_localctx, 210, MIBParser::RuleSnmpDefValPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(868);
    match(MIBParser::DEFVAL);
    setState(869);
    match(MIBParser::LEFT_BRACE);
    setState(870);
    value();
    setState(871);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpDescrPartContext ------------------------------------------------------------------

MIBParser::SnmpDescrPartContext::SnmpDescrPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpDescrPartContext::DESCRIPTION() {
  return getToken(MIBParser::DESCRIPTION, 0);
}

tree::TerminalNode* MIBParser::SnmpDescrPartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpDescrPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpDescrPart;
}

void MIBParser::SnmpDescrPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpDescrPart(this);
}

void MIBParser::SnmpDescrPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpDescrPart(this);
}

MIBParser::SnmpDescrPartContext* MIBParser::snmpDescrPart() {
  SnmpDescrPartContext *_localctx = _tracker.createInstance<SnmpDescrPartContext>(_ctx, getState());
  enterRule(_localctx, 212, MIBParser::RuleSnmpDescrPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(873);
    match(MIBParser::DESCRIPTION);
    setState(874);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpDisplayPartContext ------------------------------------------------------------------

MIBParser::SnmpDisplayPartContext::SnmpDisplayPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpDisplayPartContext::DISPLAY_HINT() {
  return getToken(MIBParser::DISPLAY_HINT, 0);
}

tree::TerminalNode* MIBParser::SnmpDisplayPartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpDisplayPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpDisplayPart;
}

void MIBParser::SnmpDisplayPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpDisplayPart(this);
}

void MIBParser::SnmpDisplayPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpDisplayPart(this);
}

MIBParser::SnmpDisplayPartContext* MIBParser::snmpDisplayPart() {
  SnmpDisplayPartContext *_localctx = _tracker.createInstance<SnmpDisplayPartContext>(_ctx, getState());
  enterRule(_localctx, 214, MIBParser::RuleSnmpDisplayPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(876);
    match(MIBParser::DISPLAY_HINT);
    setState(877);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpEnterprisePartContext ------------------------------------------------------------------

MIBParser::SnmpEnterprisePartContext::SnmpEnterprisePartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpEnterprisePartContext::ENTERPRISE() {
  return getToken(MIBParser::ENTERPRISE, 0);
}

MIBParser::ElementTypeListContext* MIBParser::SnmpEnterprisePartContext::elementTypeList() {
  return getRuleContext<MIBParser::ElementTypeListContext>(0);
}


size_t MIBParser::SnmpEnterprisePartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpEnterprisePart;
}

void MIBParser::SnmpEnterprisePartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpEnterprisePart(this);
}

void MIBParser::SnmpEnterprisePartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpEnterprisePart(this);
}

MIBParser::SnmpEnterprisePartContext* MIBParser::snmpEnterprisePart() {
  SnmpEnterprisePartContext *_localctx = _tracker.createInstance<SnmpEnterprisePartContext>(_ctx, getState());
  enterRule(_localctx, 216, MIBParser::RuleSnmpEnterprisePart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(879);
    match(MIBParser::ENTERPRISE);
    setState(880);
    elementTypeList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpIndexPartContext ------------------------------------------------------------------

MIBParser::SnmpIndexPartContext::SnmpIndexPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpIndexPartContext::INDEX() {
  return getToken(MIBParser::INDEX, 0);
}

MIBParser::SequenceContentContext* MIBParser::SnmpIndexPartContext::sequenceContent() {
  return getRuleContext<MIBParser::SequenceContentContext>(0);
}

MIBParser::ElementTypeListContext* MIBParser::SnmpIndexPartContext::elementTypeList() {
  return getRuleContext<MIBParser::ElementTypeListContext>(0);
}


size_t MIBParser::SnmpIndexPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpIndexPart;
}

void MIBParser::SnmpIndexPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpIndexPart(this);
}

void MIBParser::SnmpIndexPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpIndexPart(this);
}

MIBParser::SnmpIndexPartContext* MIBParser::snmpIndexPart() {
  SnmpIndexPartContext *_localctx = _tracker.createInstance<SnmpIndexPartContext>(_ctx, getState());
  enterRule(_localctx, 218, MIBParser::RuleSnmpIndexPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(885);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::INDEX: {
        enterOuterAlt(_localctx, 1);
        setState(882);
        match(MIBParser::INDEX);
        setState(883);
        sequenceContent();
        break;
      }

      case MIBParser::LEFT_BRACKET:
      case MIBParser::AGENT_CAPABILITIES:
      case MIBParser::ANY:
      case MIBParser::BIT:
      case MIBParser::BITS:
      case MIBParser::BOOLEAN:
      case MIBParser::CHOICE:
      case MIBParser::COMPONENTS:
      case MIBParser::ENUMERATED:
      case MIBParser::INTEGER:
      case MIBParser::MODULE_COMPLIANCE:
      case MIBParser::MODULE_IDENTITY:
      case MIBParser::NOTIFICATION_GROUP:
      case MIBParser::NOTIFICATION_TYPE:
      case MIBParser::NULL_:
      case MIBParser::OBJECT:
      case MIBParser::OBJECT_GROUP:
      case MIBParser::OBJECT_IDENTITY:
      case MIBParser::OBJECT_TYPE:
      case MIBParser::OCTET:
      case MIBParser::REAL:
      case MIBParser::SEQUENCE:
      case MIBParser::SET:
      case MIBParser::TEXTUAL_CONVENTION:
      case MIBParser::TRAP_TYPE:
      case MIBParser::IDENTIFIER_STRING: {
        enterOuterAlt(_localctx, 2);
        setState(884);
        elementTypeList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpMaxAccessPartContext ------------------------------------------------------------------

MIBParser::SnmpMaxAccessPartContext::SnmpMaxAccessPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpMaxAccessPartContext::MAX_ACCESS() {
  return getToken(MIBParser::MAX_ACCESS, 0);
}

MIBParser::AccessLevelContext* MIBParser::SnmpMaxAccessPartContext::accessLevel() {
  return getRuleContext<MIBParser::AccessLevelContext>(0);
}


size_t MIBParser::SnmpMaxAccessPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpMaxAccessPart;
}

void MIBParser::SnmpMaxAccessPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpMaxAccessPart(this);
}

void MIBParser::SnmpMaxAccessPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpMaxAccessPart(this);
}

MIBParser::SnmpMaxAccessPartContext* MIBParser::snmpMaxAccessPart() {
  SnmpMaxAccessPartContext *_localctx = _tracker.createInstance<SnmpMaxAccessPartContext>(_ctx, getState());
  enterRule(_localctx, 220, MIBParser::RuleSnmpMaxAccessPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(887);
    match(MIBParser::MAX_ACCESS);
    setState(888);
    accessLevel();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpMandatoryGroupsPartContext ------------------------------------------------------------------

MIBParser::SnmpMandatoryGroupsPartContext::SnmpMandatoryGroupsPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpMandatoryGroupsPartContext::MANDATORY_GROUPS() {
  return getToken(MIBParser::MANDATORY_GROUPS, 0);
}

tree::TerminalNode* MIBParser::SnmpMandatoryGroupsPartContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

MIBParser::SymbolListContext* MIBParser::SnmpMandatoryGroupsPartContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}

tree::TerminalNode* MIBParser::SnmpMandatoryGroupsPartContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}


size_t MIBParser::SnmpMandatoryGroupsPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpMandatoryGroupsPart;
}

void MIBParser::SnmpMandatoryGroupsPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpMandatoryGroupsPart(this);
}

void MIBParser::SnmpMandatoryGroupsPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpMandatoryGroupsPart(this);
}

MIBParser::SnmpMandatoryGroupsPartContext* MIBParser::snmpMandatoryGroupsPart() {
  SnmpMandatoryGroupsPartContext *_localctx = _tracker.createInstance<SnmpMandatoryGroupsPartContext>(_ctx, getState());
  enterRule(_localctx, 222, MIBParser::RuleSnmpMandatoryGroupsPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(890);
    match(MIBParser::MANDATORY_GROUPS);
    setState(891);
    match(MIBParser::LEFT_BRACE);
    setState(892);
    symbolList();
    setState(893);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpMibGroupsPartContext ------------------------------------------------------------------

MIBParser::SnmpMibGroupsPartContext::SnmpMibGroupsPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpMibGroupsPartContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

MIBParser::SymbolListContext* MIBParser::SnmpMibGroupsPartContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}

tree::TerminalNode* MIBParser::SnmpMibGroupsPartContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}


size_t MIBParser::SnmpMibGroupsPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpMibGroupsPart;
}

void MIBParser::SnmpMibGroupsPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpMibGroupsPart(this);
}

void MIBParser::SnmpMibGroupsPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpMibGroupsPart(this);
}

MIBParser::SnmpMibGroupsPartContext* MIBParser::snmpMibGroupsPart() {
  SnmpMibGroupsPartContext *_localctx = _tracker.createInstance<SnmpMibGroupsPartContext>(_ctx, getState());
  enterRule(_localctx, 224, MIBParser::RuleSnmpMibGroupsPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(895);
    match(MIBParser::LEFT_BRACE);
    setState(896);
    symbolList();
    setState(897);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpMibCompliancePartContext ------------------------------------------------------------------

MIBParser::SnmpMibCompliancePartContext::SnmpMibCompliancePartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::ModuleReferenceContext* MIBParser::SnmpMibCompliancePartContext::moduleReference() {
  return getRuleContext<MIBParser::ModuleReferenceContext>(0);
}

MIBParser::SnmpMibGroupsPartContext* MIBParser::SnmpMibCompliancePartContext::snmpMibGroupsPart() {
  return getRuleContext<MIBParser::SnmpMibGroupsPartContext>(0);
}


size_t MIBParser::SnmpMibCompliancePartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpMibCompliancePart;
}

void MIBParser::SnmpMibCompliancePartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpMibCompliancePart(this);
}

void MIBParser::SnmpMibCompliancePartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpMibCompliancePart(this);
}

MIBParser::SnmpMibCompliancePartContext* MIBParser::snmpMibCompliancePart() {
  SnmpMibCompliancePartContext *_localctx = _tracker.createInstance<SnmpMibCompliancePartContext>(_ctx, getState());
  enterRule(_localctx, 226, MIBParser::RuleSnmpMibCompliancePart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(899);
    moduleReference();
    setState(900);
    snmpMibGroupsPart();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpModulesPartContext ------------------------------------------------------------------

MIBParser::SnmpModulesPartContext::SnmpModulesPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpModulesPartContext::MODULES() {
  return getToken(MIBParser::MODULES, 0);
}

tree::TerminalNode* MIBParser::SnmpModulesPartContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

std::vector<MIBParser::SnmpMibCompliancePartContext *> MIBParser::SnmpModulesPartContext::snmpMibCompliancePart() {
  return getRuleContexts<MIBParser::SnmpMibCompliancePartContext>();
}

MIBParser::SnmpMibCompliancePartContext* MIBParser::SnmpModulesPartContext::snmpMibCompliancePart(size_t i) {
  return getRuleContext<MIBParser::SnmpMibCompliancePartContext>(i);
}

tree::TerminalNode* MIBParser::SnmpModulesPartContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}

std::vector<tree::TerminalNode *> MIBParser::SnmpModulesPartContext::COMMA() {
  return getTokens(MIBParser::COMMA);
}

tree::TerminalNode* MIBParser::SnmpModulesPartContext::COMMA(size_t i) {
  return getToken(MIBParser::COMMA, i);
}


size_t MIBParser::SnmpModulesPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpModulesPart;
}

void MIBParser::SnmpModulesPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpModulesPart(this);
}

void MIBParser::SnmpModulesPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpModulesPart(this);
}

MIBParser::SnmpModulesPartContext* MIBParser::snmpModulesPart() {
  SnmpModulesPartContext *_localctx = _tracker.createInstance<SnmpModulesPartContext>(_ctx, getState());
  enterRule(_localctx, 228, MIBParser::RuleSnmpModulesPart);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(902);
    match(MIBParser::MODULES);
    setState(903);
    match(MIBParser::LEFT_BRACE);
    setState(904);
    snmpMibCompliancePart();
    setState(909);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MIBParser::COMMA) {
      setState(905);
      match(MIBParser::COMMA);
      setState(906);
      snmpMibCompliancePart();
      setState(911);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(912);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpNotificationPartContext ------------------------------------------------------------------

MIBParser::SnmpNotificationPartContext::SnmpNotificationPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpNotificationPartContext::NOTIFICATIONS() {
  return getToken(MIBParser::NOTIFICATIONS, 0);
}

tree::TerminalNode* MIBParser::SnmpNotificationPartContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

MIBParser::SymbolListContext* MIBParser::SnmpNotificationPartContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}

tree::TerminalNode* MIBParser::SnmpNotificationPartContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}


size_t MIBParser::SnmpNotificationPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpNotificationPart;
}

void MIBParser::SnmpNotificationPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpNotificationPart(this);
}

void MIBParser::SnmpNotificationPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpNotificationPart(this);
}

MIBParser::SnmpNotificationPartContext* MIBParser::snmpNotificationPart() {
  SnmpNotificationPartContext *_localctx = _tracker.createInstance<SnmpNotificationPartContext>(_ctx, getState());
  enterRule(_localctx, 230, MIBParser::RuleSnmpNotificationPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(914);
    match(MIBParser::NOTIFICATIONS);
    setState(915);
    match(MIBParser::LEFT_BRACE);
    setState(916);
    symbolList();
    setState(917);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpObjectsPartContext ------------------------------------------------------------------

MIBParser::SnmpObjectsPartContext::SnmpObjectsPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpObjectsPartContext::OBJECTS() {
  return getToken(MIBParser::OBJECTS, 0);
}

tree::TerminalNode* MIBParser::SnmpObjectsPartContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

MIBParser::SymbolListContext* MIBParser::SnmpObjectsPartContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}

tree::TerminalNode* MIBParser::SnmpObjectsPartContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}


size_t MIBParser::SnmpObjectsPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpObjectsPart;
}

void MIBParser::SnmpObjectsPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpObjectsPart(this);
}

void MIBParser::SnmpObjectsPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpObjectsPart(this);
}

MIBParser::SnmpObjectsPartContext* MIBParser::snmpObjectsPart() {
  SnmpObjectsPartContext *_localctx = _tracker.createInstance<SnmpObjectsPartContext>(_ctx, getState());
  enterRule(_localctx, 232, MIBParser::RuleSnmpObjectsPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(919);
    match(MIBParser::OBJECTS);
    setState(920);
    match(MIBParser::LEFT_BRACE);
    setState(921);
    symbolList();
    setState(922);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpOrganizationPartContext ------------------------------------------------------------------

MIBParser::SnmpOrganizationPartContext::SnmpOrganizationPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpOrganizationPartContext::ORGANIZATION() {
  return getToken(MIBParser::ORGANIZATION, 0);
}

tree::TerminalNode* MIBParser::SnmpOrganizationPartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpOrganizationPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpOrganizationPart;
}

void MIBParser::SnmpOrganizationPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpOrganizationPart(this);
}

void MIBParser::SnmpOrganizationPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpOrganizationPart(this);
}

MIBParser::SnmpOrganizationPartContext* MIBParser::snmpOrganizationPart() {
  SnmpOrganizationPartContext *_localctx = _tracker.createInstance<SnmpOrganizationPartContext>(_ctx, getState());
  enterRule(_localctx, 234, MIBParser::RuleSnmpOrganizationPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(924);
    match(MIBParser::ORGANIZATION);
    setState(925);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpProductPartContext ------------------------------------------------------------------

MIBParser::SnmpProductPartContext::SnmpProductPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpProductPartContext::PRODUCT_RELEASE() {
  return getToken(MIBParser::PRODUCT_RELEASE, 0);
}

tree::TerminalNode* MIBParser::SnmpProductPartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpProductPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpProductPart;
}

void MIBParser::SnmpProductPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpProductPart(this);
}

void MIBParser::SnmpProductPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpProductPart(this);
}

MIBParser::SnmpProductPartContext* MIBParser::snmpProductPart() {
  SnmpProductPartContext *_localctx = _tracker.createInstance<SnmpProductPartContext>(_ctx, getState());
  enterRule(_localctx, 236, MIBParser::RuleSnmpProductPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(927);
    match(MIBParser::PRODUCT_RELEASE);
    setState(928);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpReferPartContext ------------------------------------------------------------------

MIBParser::SnmpReferPartContext::SnmpReferPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpReferPartContext::REFERENCE() {
  return getToken(MIBParser::REFERENCE, 0);
}

tree::TerminalNode* MIBParser::SnmpReferPartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpReferPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpReferPart;
}

void MIBParser::SnmpReferPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpReferPart(this);
}

void MIBParser::SnmpReferPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpReferPart(this);
}

MIBParser::SnmpReferPartContext* MIBParser::snmpReferPart() {
  SnmpReferPartContext *_localctx = _tracker.createInstance<SnmpReferPartContext>(_ctx, getState());
  enterRule(_localctx, 238, MIBParser::RuleSnmpReferPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(930);
    match(MIBParser::REFERENCE);
    setState(931);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpRevisionPartContext ------------------------------------------------------------------

MIBParser::SnmpRevisionPartContext::SnmpRevisionPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpRevisionPartContext::REVISION() {
  return getToken(MIBParser::REVISION, 0);
}

std::vector<tree::TerminalNode *> MIBParser::SnmpRevisionPartContext::QUOTED_STRING() {
  return getTokens(MIBParser::QUOTED_STRING);
}

tree::TerminalNode* MIBParser::SnmpRevisionPartContext::QUOTED_STRING(size_t i) {
  return getToken(MIBParser::QUOTED_STRING, i);
}

tree::TerminalNode* MIBParser::SnmpRevisionPartContext::DESCRIPTION() {
  return getToken(MIBParser::DESCRIPTION, 0);
}


size_t MIBParser::SnmpRevisionPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpRevisionPart;
}

void MIBParser::SnmpRevisionPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpRevisionPart(this);
}

void MIBParser::SnmpRevisionPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpRevisionPart(this);
}

MIBParser::SnmpRevisionPartContext* MIBParser::snmpRevisionPart() {
  SnmpRevisionPartContext *_localctx = _tracker.createInstance<SnmpRevisionPartContext>(_ctx, getState());
  enterRule(_localctx, 240, MIBParser::RuleSnmpRevisionPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(933);
    match(MIBParser::REVISION);
    setState(934);
    match(MIBParser::QUOTED_STRING);
    setState(935);
    match(MIBParser::DESCRIPTION);
    setState(936);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpStatusPartContext ------------------------------------------------------------------

MIBParser::SnmpStatusPartContext::SnmpStatusPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpStatusPartContext::STATUS() {
  return getToken(MIBParser::STATUS, 0);
}

tree::TerminalNode* MIBParser::SnmpStatusPartContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}


size_t MIBParser::SnmpStatusPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpStatusPart;
}

void MIBParser::SnmpStatusPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpStatusPart(this);
}

void MIBParser::SnmpStatusPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpStatusPart(this);
}

MIBParser::SnmpStatusPartContext* MIBParser::snmpStatusPart() {
  SnmpStatusPartContext *_localctx = _tracker.createInstance<SnmpStatusPartContext>(_ctx, getState());
  enterRule(_localctx, 242, MIBParser::RuleSnmpStatusPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(938);
    match(MIBParser::STATUS);
    setState(939);
    match(MIBParser::IDENTIFIER_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpSyntaxPartContext ------------------------------------------------------------------

MIBParser::SnmpSyntaxPartContext::SnmpSyntaxPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpSyntaxPartContext::SYNTAX() {
  return getToken(MIBParser::SYNTAX, 0);
}

MIBParser::TypeContext* MIBParser::SnmpSyntaxPartContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}


size_t MIBParser::SnmpSyntaxPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpSyntaxPart;
}

void MIBParser::SnmpSyntaxPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpSyntaxPart(this);
}

void MIBParser::SnmpSyntaxPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpSyntaxPart(this);
}

MIBParser::SnmpSyntaxPartContext* MIBParser::snmpSyntaxPart() {
  SnmpSyntaxPartContext *_localctx = _tracker.createInstance<SnmpSyntaxPartContext>(_ctx, getState());
  enterRule(_localctx, 244, MIBParser::RuleSnmpSyntaxPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(941);
    match(MIBParser::SYNTAX);
    setState(942);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpUnitsPartContext ------------------------------------------------------------------

MIBParser::SnmpUnitsPartContext::SnmpUnitsPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpUnitsPartContext::UNITS() {
  return getToken(MIBParser::UNITS, 0);
}

tree::TerminalNode* MIBParser::SnmpUnitsPartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpUnitsPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpUnitsPart;
}

void MIBParser::SnmpUnitsPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpUnitsPart(this);
}

void MIBParser::SnmpUnitsPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpUnitsPart(this);
}

MIBParser::SnmpUnitsPartContext* MIBParser::snmpUnitsPart() {
  SnmpUnitsPartContext *_localctx = _tracker.createInstance<SnmpUnitsPartContext>(_ctx, getState());
  enterRule(_localctx, 246, MIBParser::RuleSnmpUnitsPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(944);
    match(MIBParser::UNITS);
    setState(945);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpUpdatePartContext ------------------------------------------------------------------

MIBParser::SnmpUpdatePartContext::SnmpUpdatePartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpUpdatePartContext::LAST_UPDATED() {
  return getToken(MIBParser::LAST_UPDATED, 0);
}

tree::TerminalNode* MIBParser::SnmpUpdatePartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpUpdatePartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpUpdatePart;
}

void MIBParser::SnmpUpdatePartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpUpdatePart(this);
}

void MIBParser::SnmpUpdatePartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpUpdatePart(this);
}

MIBParser::SnmpUpdatePartContext* MIBParser::snmpUpdatePart() {
  SnmpUpdatePartContext *_localctx = _tracker.createInstance<SnmpUpdatePartContext>(_ctx, getState());
  enterRule(_localctx, 248, MIBParser::RuleSnmpUpdatePart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(947);
    match(MIBParser::LAST_UPDATED);
    setState(948);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpVarPartContext ------------------------------------------------------------------

MIBParser::SnmpVarPartContext::SnmpVarPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpVarPartContext::VARIABLES() {
  return getToken(MIBParser::VARIABLES, 0);
}

MIBParser::ElementTypeListContext* MIBParser::SnmpVarPartContext::elementTypeList() {
  return getRuleContext<MIBParser::ElementTypeListContext>(0);
}


size_t MIBParser::SnmpVarPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpVarPart;
}

void MIBParser::SnmpVarPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpVarPart(this);
}

void MIBParser::SnmpVarPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpVarPart(this);
}

MIBParser::SnmpVarPartContext* MIBParser::snmpVarPart() {
  SnmpVarPartContext *_localctx = _tracker.createInstance<SnmpVarPartContext>(_ctx, getState());
  enterRule(_localctx, 250, MIBParser::RuleSnmpVarPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(950);
    match(MIBParser::VARIABLES);
    setState(951);
    elementTypeList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpWritePartContext ------------------------------------------------------------------

MIBParser::SnmpWritePartContext::SnmpWritePartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpWritePartContext::WRITE_SYNTAX() {
  return getToken(MIBParser::WRITE_SYNTAX, 0);
}

MIBParser::TypeContext* MIBParser::SnmpWritePartContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}


size_t MIBParser::SnmpWritePartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpWritePart;
}

void MIBParser::SnmpWritePartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpWritePart(this);
}

void MIBParser::SnmpWritePartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpWritePart(this);
}

MIBParser::SnmpWritePartContext* MIBParser::snmpWritePart() {
  SnmpWritePartContext *_localctx = _tracker.createInstance<SnmpWritePartContext>(_ctx, getState());
  enterRule(_localctx, 252, MIBParser::RuleSnmpWritePart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(953);
    match(MIBParser::WRITE_SYNTAX);
    setState(954);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void MIBParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  mibParserInitialize();
#else
  ::antlr4::internal::call_once(mibParserOnceFlag, mibParserInitialize);
#endif
}
