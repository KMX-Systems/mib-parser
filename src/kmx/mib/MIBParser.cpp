
// Generated from MIB.g4 by ANTLR 4.13.2


#include "MIBListener.h"

#include "MIBParser.h"


using namespace antlrcpp;
using namespace kmx::mib;

using namespace antlr4;

namespace {

struct MIBParserStaticData final {
  MIBParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  MIBParserStaticData(const MIBParserStaticData&) = delete;
  MIBParserStaticData(MIBParserStaticData&&) = delete;
  MIBParserStaticData& operator=(const MIBParserStaticData&) = delete;
  MIBParserStaticData& operator=(MIBParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag mibParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<MIBParserStaticData> mibParserStaticData = nullptr;

void mibParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (mibParserStaticData != nullptr) {
    return;
  }
#else
  assert(mibParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<MIBParserStaticData>(
    std::vector<std::string>{
      "data", "moduleDefinition", "moduleIdentifier", "moduleReference", 
      "tagDefault", "moduleBody", "exportList", "importList", "symbolsFromModule", 
      "symbolList", "symbol", "assignmentList", "assignment", "macroDefinition", 
      "macroReference", "macroBody", "macroBodyElement", "typeAssignment", 
      "type", "definedType", "builtinType", "nullType", "booleanType", "realType", 
      "accessLevel", "integerType", "objectIdentifierType", "stringType", 
      "bitStringType", "bitsType", "sequenceContent", "sequenceType", "sequenceOfType", 
      "setType", "setOfType", "choiceType", "enumeratedType", "selectionType", 
      "taggedType", "tag", "class_", "explicitOrImplicitTag", "anyType", 
      "elementTypeList", "elementType", "optionalOrDefaultElement", "valueOrConstraintList", 
      "namedNumberList", "namedNumber", "number", "constraintList", "constraint", 
      "valueConstraintList", "valueConstraint", "valueRange", "lowerEndPoint", 
      "upperEndPoint", "sizeConstraint", "alphabetConstraint", "containedTypeConstraint", 
      "innerTypeConstraint", "componentsList", "componentsListTail", "componentConstraint", 
      "componentValuePresence", "componentPresence", "valueAssignment", 
      "value", "definedValue", "builtinValue", "nullValue", "booleanValue", 
      "specialRealValue", "numberValue", "binaryValue", "hexadecimalValue", 
      "stringValue", "bitOrObjectIdentifierValue", "bitValue", "objectIdentifierValue", 
      "nameValueList", "nameValueComponent", "nameOrNumber", "nameAndNumber", 
      "definedMacroType", "definedMacroName", "snmpStatusDescrReferPart", 
      "snmpModuleIdentityMacroType", "snmpObjectIdentityMacroType", "snmpObjectTypeMacroType", 
      "snmpNotificationTypeMacroType", "snmpTrapTypeMacroType", "snmpTextualConventionMacroType", 
      "snmpObjectGroupMacroType", "snmpNotificationGroupMacroType", "snmpModuleComplianceMacroType", 
      "snmpAgentCapabilitiesMacroType", "snmpSupportPart", "snmpInclusionPart", 
      "snmpVariationPart", "snmpGroupPart", "snmpAccessPart", "snmpAugmentsPart", 
      "snmpContactPart", "snmpDefValPart", "snmpDescrPart", "snmpDisplayPart", 
      "snmpEnterprisePart", "snmpIndexPart", "snmpMaxAccessPart", "snmpMandatoryGroupsPart", 
      "snmpMibGroupsPart", "snmpMibCompliancePart", "snmpModulesPart", "snmpNotificationPart", 
      "snmpObjectsPart", "snmpOrganizationPart", "snmpProductPart", "snmpReferPart", 
      "snmpRevisionPart", "snmpStatusPart", "snmpSyntaxPart", "snmpUnitsPart", 
      "snmpUpdatePart", "snmpVarPart", "snmpWritePart"
    },
    std::vector<std::string>{
      "", "','", "'::='", "'.'", "'..'", "'{'", "'['", "'('", "'<'", "'-'", 
      "'}'", "']'", "')'", "';'", "'...'", "'|'", "'ABSENT'", "'accessible-for-notify'", 
      "'ACCESS'", "'AGENT-CAPABILITIES'", "'ANY'", "'APPLICATION'", "'AUGMENTS'", 
      "'BEGIN'", "'BIT'", "'BITS'", "'BOOLEAN'", "'BY'", "'CHOICE'", "'COMPONENT'", 
      "'COMPONENTS'", "'CONTACT-INFO'", "'DEFAULT'", "'DEFINED'", "'DEFINITIONS'", 
      "'DEFVAL'", "'DESCRIPTION'", "'DISPLAY-HINT'", "'END'", "'ENTERPRISE'", 
      "'ENUMERATED'", "'EXPLICIT'", "'EXPORTS'", "'FALSE'", "'FROM'", "'GROUP'", 
      "'IDENTIFIER'", "'IMPLICIT'", "'IMPORTS'", "'INCLUDES'", "'INDEX'", 
      "'INTEGER'", "'LAST-UPDATED'", "'MANDATORY-GROUPS'", "'MACRO'", "'MAX'", 
      "'MAX-ACCESS'", "'MIN'", "'MINUS-INFINITY'", "'MODULE'", "'MODULES'", 
      "'MODULE-COMPLIANCE'", "'MODULE-IDENTITY'", "'not-accessible'", "'NOTIFICATION-GROUP'", 
      "'NOTIFICATION-TYPE'", "'NOTIFICATIONS'", "'NULL'", "'OBJECT'", "'OBJECT-GROUP'", 
      "'OBJECT-IDENTITY'", "'OBJECT-TYPE'", "'OBJECTS'", "'OCTET'", "'OF'", 
      "'OPTIONAL'", "'ORGANIZATION'", "'PLUS-INFINITY'", "'PRESENT'", "'PRIVATE'", 
      "'PRODUCT-RELEASE'", "'read-create'", "'read-only'", "'read-write'", 
      "'REAL'", "'REFERENCE'", "'REVISION'", "'SEQUENCE'", "'SET'", "'SIZE'", 
      "'STATUS'", "'STRING'", "'SUPPORTS'", "'SYNTAX'", "'TAGS'", "'TEXTUAL-CONVENTION'", 
      "'TRAP-TYPE'", "'TRUE'", "'UNITS'", "'UNIVERSAL'", "'VARIABLES'", 
      "'VARIATION'", "'WITH'", "'WRITE-SYNTAX'"
    },
    std::vector<std::string>{
      "", "COMMA", "DEFINITION", "DOT", "DOUBLE_DOT", "LEFT_BRACE", "LEFT_BRACKET", 
      "LEFT_PAREN", "LESS_THAN", "MINUS", "RIGHT_BRACE", "RIGHT_BRACKET", 
      "RIGHT_PAREN", "SEMI_COLON", "TRIPLE_DOT", "VERTICAL_BAR", "ABSENT", 
      "ACCESSIBLE_FOR_NOTIFY", "ACCESS", "AGENT_CAPABILITIES", "ANY", "APPLICATION", 
      "AUGMENTS", "BEGIN", "BIT", "BITS", "BOOLEAN", "BY", "CHOICE", "COMPONENT", 
      "COMPONENTS", "CONTACT_INFO", "DEFAULT", "DEFINED", "DEFINITIONS", 
      "DEFVAL", "DESCRIPTION", "DISPLAY_HINT", "END", "ENTERPRISE", "ENUMERATED", 
      "EXPLICIT", "EXPORTS", "FALSE", "FROM", "GROUP", "IDENTIFIER", "IMPLICIT", 
      "IMPORTS", "INCLUDES", "INDEX", "INTEGER", "LAST_UPDATED", "MANDATORY_GROUPS", 
      "MACRO", "MAX", "MAX_ACCESS", "MIN", "MINUS_INFINITY", "MODULE", "MODULES", 
      "MODULE_COMPLIANCE", "MODULE_IDENTITY", "NOT_ACCESSIBLE", "NOTIFICATION_GROUP", 
      "NOTIFICATION_TYPE", "NOTIFICATIONS", "NULL", "OBJECT", "OBJECT_GROUP", 
      "OBJECT_IDENTITY", "OBJECT_TYPE", "OBJECTS", "OCTET", "OF", "OPTIONAL", 
      "ORGANIZATION", "PLUS_INFINITY", "PRESENT", "PRIVATE", "PRODUCT_RELEASE", 
      "READ_CREATE", "READ_ONLY", "READ_WRITE", "REAL", "REFERENCE", "REVISION", 
      "SEQUENCE", "SET", "SIZE", "STATUS", "STRING", "SUPPORTS", "SYNTAX", 
      "TAGS", "TEXTUAL_CONVENTION", "TRAP_TYPE", "TRUE", "UNITS", "UNIVERSAL", 
      "VARIABLES", "VARIATION", "WITH", "WRITE_SYNTAX", "BINARY_STRING", 
      "HEXADECIMAL_STRING", "QUOTED_STRING", "IDENTIFIER_STRING", "INTEGER_STRING", 
      "NUMBER_STRING", "WHITESPACE", "COMMENT"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,111,964,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
  	63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,
  	70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,
  	77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,
  	84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
  	91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,7,
  	98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,7,
  	104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,
  	7,116,2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,
  	7,122,2,123,7,123,2,124,7,124,2,125,7,125,1,0,4,0,254,8,0,11,0,12,0,255,
  	1,1,1,1,1,1,3,1,261,8,1,1,1,1,1,1,1,3,1,266,8,1,1,1,1,1,1,2,1,2,3,2,272,
  	8,2,1,3,1,3,1,4,1,4,1,4,1,4,3,4,280,8,4,1,5,3,5,283,8,5,1,5,3,5,286,8,
  	5,1,5,1,5,1,6,1,6,3,6,292,8,6,1,6,1,6,1,7,1,7,5,7,298,8,7,10,7,12,7,301,
  	9,7,1,7,1,7,1,8,1,8,1,8,1,8,1,9,1,9,1,9,5,9,312,8,9,10,9,12,9,315,9,9,
  	1,10,1,10,3,10,319,8,10,1,11,4,11,322,8,11,11,11,12,11,323,1,12,1,12,
  	1,12,3,12,329,8,12,1,12,3,12,332,8,12,1,13,1,13,1,13,1,13,1,13,1,14,1,
  	14,3,14,341,8,14,1,15,1,15,5,15,345,8,15,10,15,12,15,348,9,15,1,15,1,
  	15,1,15,1,15,3,15,354,8,15,1,16,1,16,1,17,1,17,1,17,1,17,1,18,1,18,1,
  	18,3,18,365,8,18,1,19,3,19,368,8,19,1,19,1,19,3,19,372,8,19,1,20,1,20,
  	1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,
  	1,20,3,20,391,8,20,1,21,1,21,1,22,1,22,1,23,1,23,1,24,1,24,1,25,1,25,
  	3,25,403,8,25,1,26,1,26,1,26,1,27,1,27,1,27,3,27,411,8,27,1,28,1,28,1,
  	28,3,28,416,8,28,1,29,1,29,3,29,420,8,29,1,30,1,30,3,30,424,8,30,1,30,
  	1,30,1,31,1,31,1,31,1,32,1,32,3,32,433,8,32,1,32,1,32,1,32,1,33,1,33,
  	1,33,3,33,441,8,33,1,33,1,33,1,34,1,34,3,34,447,8,34,1,34,1,34,1,34,1,
  	35,1,35,1,35,1,35,1,35,1,36,1,36,1,36,1,37,1,37,1,37,1,37,1,38,1,38,1,
  	38,1,38,1,39,1,39,3,39,470,8,39,1,39,1,39,1,39,1,40,1,40,1,41,1,41,1,
  	42,1,42,1,42,1,42,3,42,483,8,42,1,43,1,43,1,43,5,43,488,8,43,10,43,12,
  	43,491,9,43,1,44,3,44,494,8,44,1,44,1,44,3,44,498,8,44,1,44,3,44,501,
  	8,44,1,44,1,44,1,44,3,44,506,8,44,1,45,1,45,1,45,3,45,511,8,45,1,45,3,
  	45,514,8,45,1,46,1,46,3,46,518,8,46,1,47,1,47,1,47,1,47,5,47,524,8,47,
  	10,47,12,47,527,9,47,1,47,1,47,1,48,1,48,1,48,1,48,1,48,1,49,1,49,1,49,
  	1,49,3,49,540,8,49,1,50,1,50,1,50,1,50,5,50,546,8,50,10,50,12,50,549,
  	9,50,1,50,1,50,1,51,1,51,1,51,1,51,1,51,3,51,558,8,51,1,52,1,52,1,52,
  	1,52,5,52,564,8,52,10,52,12,52,567,9,52,1,52,1,52,1,53,1,53,3,53,573,
  	8,53,1,54,3,54,576,8,54,1,54,1,54,3,54,580,8,54,1,54,1,54,1,55,1,55,3,
  	55,586,8,55,1,56,1,56,3,56,590,8,56,1,57,1,57,1,57,1,58,1,58,1,58,1,59,
  	1,59,1,59,1,60,1,60,1,60,1,60,1,60,1,60,3,60,607,8,60,1,61,1,61,1,61,
  	5,61,612,8,61,10,61,12,61,615,9,61,1,61,1,61,4,61,619,8,61,11,61,12,61,
  	620,3,61,623,8,61,1,61,1,61,1,62,1,62,3,62,629,8,62,1,63,1,63,3,63,633,
  	8,63,1,63,3,63,636,8,63,1,64,1,64,3,64,640,8,64,1,64,3,64,643,8,64,1,
  	65,1,65,1,66,1,66,1,66,1,66,1,66,1,67,1,67,3,67,654,8,67,1,68,1,68,1,
  	68,1,68,3,68,660,8,68,1,68,3,68,663,8,68,1,69,1,69,1,69,1,69,1,69,1,69,
  	1,69,1,69,3,69,673,8,69,1,70,1,70,1,71,1,71,1,72,1,72,1,73,3,73,682,8,
  	73,1,73,1,73,1,74,1,74,1,75,1,75,1,76,1,76,1,77,1,77,1,78,1,78,1,79,1,
  	79,1,80,1,80,5,80,700,8,80,10,80,12,80,703,9,80,1,80,1,80,1,81,3,81,708,
  	8,81,1,81,1,81,1,82,1,82,1,82,3,82,715,8,82,1,83,1,83,1,83,1,83,3,83,
  	721,8,83,1,83,1,83,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,1,84,
  	3,84,735,8,84,1,85,1,85,1,86,1,86,3,86,741,8,86,1,86,3,86,744,8,86,1,
  	87,1,87,1,87,1,87,1,87,1,87,5,87,752,8,87,10,87,12,87,755,9,87,1,88,1,
  	88,1,88,1,89,1,89,1,89,3,89,763,8,89,1,89,3,89,766,8,89,1,89,1,89,1,89,
  	3,89,771,8,89,1,89,3,89,774,8,89,1,89,3,89,777,8,89,1,90,1,90,3,90,781,
  	8,90,1,90,1,90,1,91,1,91,1,91,3,91,788,8,91,1,91,1,91,3,91,792,8,91,1,
  	92,1,92,3,92,796,8,92,1,92,1,92,1,92,1,93,1,93,1,93,1,93,1,94,1,94,1,
  	94,3,94,808,8,94,1,94,3,94,811,8,94,1,94,1,94,1,94,1,95,1,95,1,95,5,95,
  	819,8,95,10,95,12,95,822,9,95,1,95,1,95,1,95,3,95,827,8,95,1,96,1,96,
  	1,96,1,96,5,96,833,8,96,10,96,12,96,836,9,96,1,97,1,97,1,97,1,97,3,97,
  	842,8,97,1,98,1,98,1,98,1,99,1,99,1,99,1,99,3,99,851,8,99,1,99,1,99,3,
  	99,855,8,99,3,99,857,8,99,1,100,1,100,1,100,1,100,3,100,863,8,100,1,101,
  	1,101,1,101,1,102,1,102,1,102,1,102,1,102,1,103,1,103,1,103,1,104,1,104,
  	1,104,1,104,1,104,1,105,1,105,1,105,1,106,1,106,1,106,1,107,1,107,1,107,
  	1,108,1,108,1,108,3,108,893,8,108,1,109,1,109,1,109,1,110,1,110,1,110,
  	1,110,1,110,1,111,1,111,1,111,1,111,1,112,1,112,1,112,1,113,1,113,1,113,
  	1,113,1,113,5,113,915,8,113,10,113,12,113,918,9,113,1,113,1,113,1,114,
  	1,114,1,114,1,114,1,114,1,115,1,115,1,115,1,115,1,115,1,116,1,116,1,116,
  	1,117,1,117,1,117,1,118,1,118,1,118,1,119,1,119,1,119,1,119,1,119,1,120,
  	1,120,1,120,1,121,1,121,1,121,1,122,1,122,1,122,1,123,1,123,1,123,1,124,
  	1,124,1,124,1,125,1,125,1,125,1,125,0,0,126,0,2,4,6,8,10,12,14,16,18,
  	20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,
  	66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,
  	110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,
  	146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,
  	182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,
  	218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,0,
  	8,13,0,2,2,7,7,12,12,15,15,24,24,26,26,46,46,51,51,67,68,73,73,84,84,
  	91,91,106,107,3,0,17,17,63,63,81,83,3,0,21,21,79,79,99,99,2,0,41,41,47,
  	47,3,0,16,16,75,75,78,78,2,0,43,43,97,97,2,0,58,58,77,77,5,0,19,19,61,
  	62,64,65,69,71,95,96,968,0,253,1,0,0,0,2,257,1,0,0,0,4,269,1,0,0,0,6,
  	273,1,0,0,0,8,279,1,0,0,0,10,282,1,0,0,0,12,289,1,0,0,0,14,295,1,0,0,
  	0,16,304,1,0,0,0,18,308,1,0,0,0,20,318,1,0,0,0,22,321,1,0,0,0,24,328,
  	1,0,0,0,26,333,1,0,0,0,28,340,1,0,0,0,30,353,1,0,0,0,32,355,1,0,0,0,34,
  	357,1,0,0,0,36,364,1,0,0,0,38,367,1,0,0,0,40,390,1,0,0,0,42,392,1,0,0,
  	0,44,394,1,0,0,0,46,396,1,0,0,0,48,398,1,0,0,0,50,400,1,0,0,0,52,404,
  	1,0,0,0,54,407,1,0,0,0,56,412,1,0,0,0,58,417,1,0,0,0,60,421,1,0,0,0,62,
  	427,1,0,0,0,64,430,1,0,0,0,66,437,1,0,0,0,68,444,1,0,0,0,70,451,1,0,0,
  	0,72,456,1,0,0,0,74,459,1,0,0,0,76,463,1,0,0,0,78,467,1,0,0,0,80,474,
  	1,0,0,0,82,476,1,0,0,0,84,478,1,0,0,0,86,484,1,0,0,0,88,505,1,0,0,0,90,
  	513,1,0,0,0,92,517,1,0,0,0,94,519,1,0,0,0,96,530,1,0,0,0,98,539,1,0,0,
  	0,100,541,1,0,0,0,102,557,1,0,0,0,104,559,1,0,0,0,106,570,1,0,0,0,108,
  	575,1,0,0,0,110,585,1,0,0,0,112,589,1,0,0,0,114,591,1,0,0,0,116,594,1,
  	0,0,0,118,597,1,0,0,0,120,606,1,0,0,0,122,608,1,0,0,0,124,626,1,0,0,0,
  	126,635,1,0,0,0,128,642,1,0,0,0,130,644,1,0,0,0,132,646,1,0,0,0,134,653,
  	1,0,0,0,136,662,1,0,0,0,138,672,1,0,0,0,140,674,1,0,0,0,142,676,1,0,0,
  	0,144,678,1,0,0,0,146,681,1,0,0,0,148,685,1,0,0,0,150,687,1,0,0,0,152,
  	689,1,0,0,0,154,691,1,0,0,0,156,693,1,0,0,0,158,695,1,0,0,0,160,697,1,
  	0,0,0,162,707,1,0,0,0,164,714,1,0,0,0,166,716,1,0,0,0,168,734,1,0,0,0,
  	170,736,1,0,0,0,172,738,1,0,0,0,174,745,1,0,0,0,176,756,1,0,0,0,178,759,
  	1,0,0,0,180,778,1,0,0,0,182,784,1,0,0,0,184,793,1,0,0,0,186,800,1,0,0,
  	0,188,804,1,0,0,0,190,815,1,0,0,0,192,828,1,0,0,0,194,837,1,0,0,0,196,
  	843,1,0,0,0,198,846,1,0,0,0,200,858,1,0,0,0,202,864,1,0,0,0,204,867,1,
  	0,0,0,206,872,1,0,0,0,208,875,1,0,0,0,210,880,1,0,0,0,212,883,1,0,0,0,
  	214,886,1,0,0,0,216,892,1,0,0,0,218,894,1,0,0,0,220,897,1,0,0,0,222,902,
  	1,0,0,0,224,906,1,0,0,0,226,909,1,0,0,0,228,921,1,0,0,0,230,926,1,0,0,
  	0,232,931,1,0,0,0,234,934,1,0,0,0,236,937,1,0,0,0,238,940,1,0,0,0,240,
  	945,1,0,0,0,242,948,1,0,0,0,244,951,1,0,0,0,246,954,1,0,0,0,248,957,1,
  	0,0,0,250,960,1,0,0,0,252,254,3,2,1,0,253,252,1,0,0,0,254,255,1,0,0,0,
  	255,253,1,0,0,0,255,256,1,0,0,0,256,1,1,0,0,0,257,258,3,4,2,0,258,260,
  	5,34,0,0,259,261,3,8,4,0,260,259,1,0,0,0,260,261,1,0,0,0,261,262,1,0,
  	0,0,262,263,5,2,0,0,263,265,5,23,0,0,264,266,3,10,5,0,265,264,1,0,0,0,
  	265,266,1,0,0,0,266,267,1,0,0,0,267,268,5,38,0,0,268,3,1,0,0,0,269,271,
  	5,107,0,0,270,272,3,158,79,0,271,270,1,0,0,0,271,272,1,0,0,0,272,5,1,
  	0,0,0,273,274,5,107,0,0,274,7,1,0,0,0,275,276,5,41,0,0,276,280,5,94,0,
  	0,277,278,5,47,0,0,278,280,5,94,0,0,279,275,1,0,0,0,279,277,1,0,0,0,280,
  	9,1,0,0,0,281,283,3,12,6,0,282,281,1,0,0,0,282,283,1,0,0,0,283,285,1,
  	0,0,0,284,286,3,14,7,0,285,284,1,0,0,0,285,286,1,0,0,0,286,287,1,0,0,
  	0,287,288,3,22,11,0,288,11,1,0,0,0,289,291,5,42,0,0,290,292,3,18,9,0,
  	291,290,1,0,0,0,291,292,1,0,0,0,292,293,1,0,0,0,293,294,5,13,0,0,294,
  	13,1,0,0,0,295,299,5,48,0,0,296,298,3,16,8,0,297,296,1,0,0,0,298,301,
  	1,0,0,0,299,297,1,0,0,0,299,300,1,0,0,0,300,302,1,0,0,0,301,299,1,0,0,
  	0,302,303,5,13,0,0,303,15,1,0,0,0,304,305,3,18,9,0,305,306,5,44,0,0,306,
  	307,3,4,2,0,307,17,1,0,0,0,308,313,3,20,10,0,309,310,5,1,0,0,310,312,
  	3,20,10,0,311,309,1,0,0,0,312,315,1,0,0,0,313,311,1,0,0,0,313,314,1,0,
  	0,0,314,19,1,0,0,0,315,313,1,0,0,0,316,319,5,107,0,0,317,319,3,170,85,
  	0,318,316,1,0,0,0,318,317,1,0,0,0,319,21,1,0,0,0,320,322,3,24,12,0,321,
  	320,1,0,0,0,322,323,1,0,0,0,323,321,1,0,0,0,323,324,1,0,0,0,324,23,1,
  	0,0,0,325,329,3,26,13,0,326,329,3,34,17,0,327,329,3,132,66,0,328,325,
  	1,0,0,0,328,326,1,0,0,0,328,327,1,0,0,0,329,331,1,0,0,0,330,332,5,13,
  	0,0,331,330,1,0,0,0,331,332,1,0,0,0,332,25,1,0,0,0,333,334,3,28,14,0,
  	334,335,5,54,0,0,335,336,5,2,0,0,336,337,3,30,15,0,337,27,1,0,0,0,338,
  	341,5,107,0,0,339,341,3,170,85,0,340,338,1,0,0,0,340,339,1,0,0,0,341,
  	29,1,0,0,0,342,346,5,23,0,0,343,345,3,32,16,0,344,343,1,0,0,0,345,348,
  	1,0,0,0,346,344,1,0,0,0,346,347,1,0,0,0,347,349,1,0,0,0,348,346,1,0,0,
  	0,349,354,5,38,0,0,350,351,3,6,3,0,351,352,3,28,14,0,352,354,1,0,0,0,
  	353,342,1,0,0,0,353,350,1,0,0,0,354,31,1,0,0,0,355,356,7,0,0,0,356,33,
  	1,0,0,0,357,358,5,107,0,0,358,359,5,2,0,0,359,360,3,36,18,0,360,35,1,
  	0,0,0,361,365,3,40,20,0,362,365,3,38,19,0,363,365,3,168,84,0,364,361,
  	1,0,0,0,364,362,1,0,0,0,364,363,1,0,0,0,365,37,1,0,0,0,366,368,3,6,3,
  	0,367,366,1,0,0,0,367,368,1,0,0,0,368,369,1,0,0,0,369,371,5,107,0,0,370,
  	372,3,92,46,0,371,370,1,0,0,0,371,372,1,0,0,0,372,39,1,0,0,0,373,391,
  	3,42,21,0,374,391,3,44,22,0,375,391,3,46,23,0,376,391,3,50,25,0,377,391,
  	3,52,26,0,378,391,3,54,27,0,379,391,3,56,28,0,380,391,3,58,29,0,381,391,
  	3,62,31,0,382,391,3,64,32,0,383,391,3,66,33,0,384,391,3,68,34,0,385,391,
  	3,70,35,0,386,391,3,72,36,0,387,391,3,74,37,0,388,391,3,76,38,0,389,391,
  	3,84,42,0,390,373,1,0,0,0,390,374,1,0,0,0,390,375,1,0,0,0,390,376,1,0,
  	0,0,390,377,1,0,0,0,390,378,1,0,0,0,390,379,1,0,0,0,390,380,1,0,0,0,390,
  	381,1,0,0,0,390,382,1,0,0,0,390,383,1,0,0,0,390,384,1,0,0,0,390,385,1,
  	0,0,0,390,386,1,0,0,0,390,387,1,0,0,0,390,388,1,0,0,0,390,389,1,0,0,0,
  	391,41,1,0,0,0,392,393,5,67,0,0,393,43,1,0,0,0,394,395,5,26,0,0,395,45,
  	1,0,0,0,396,397,5,84,0,0,397,47,1,0,0,0,398,399,7,1,0,0,399,49,1,0,0,
  	0,400,402,5,51,0,0,401,403,3,92,46,0,402,401,1,0,0,0,402,403,1,0,0,0,
  	403,51,1,0,0,0,404,405,5,68,0,0,405,406,5,46,0,0,406,53,1,0,0,0,407,408,
  	5,73,0,0,408,410,5,91,0,0,409,411,3,100,50,0,410,409,1,0,0,0,410,411,
  	1,0,0,0,411,55,1,0,0,0,412,413,5,24,0,0,413,415,5,91,0,0,414,416,3,92,
  	46,0,415,414,1,0,0,0,415,416,1,0,0,0,416,57,1,0,0,0,417,419,5,25,0,0,
  	418,420,3,92,46,0,419,418,1,0,0,0,419,420,1,0,0,0,420,59,1,0,0,0,421,
  	423,5,5,0,0,422,424,3,86,43,0,423,422,1,0,0,0,423,424,1,0,0,0,424,425,
  	1,0,0,0,425,426,5,10,0,0,426,61,1,0,0,0,427,428,5,87,0,0,428,429,3,60,
  	30,0,429,63,1,0,0,0,430,432,5,87,0,0,431,433,3,100,50,0,432,431,1,0,0,
  	0,432,433,1,0,0,0,433,434,1,0,0,0,434,435,5,74,0,0,435,436,3,36,18,0,
  	436,65,1,0,0,0,437,438,5,88,0,0,438,440,5,5,0,0,439,441,3,86,43,0,440,
  	439,1,0,0,0,440,441,1,0,0,0,441,442,1,0,0,0,442,443,5,10,0,0,443,67,1,
  	0,0,0,444,446,5,88,0,0,445,447,3,114,57,0,446,445,1,0,0,0,446,447,1,0,
  	0,0,447,448,1,0,0,0,448,449,5,74,0,0,449,450,3,36,18,0,450,69,1,0,0,0,
  	451,452,5,28,0,0,452,453,5,5,0,0,453,454,3,86,43,0,454,455,5,10,0,0,455,
  	71,1,0,0,0,456,457,5,40,0,0,457,458,3,94,47,0,458,73,1,0,0,0,459,460,
  	5,107,0,0,460,461,5,8,0,0,461,462,3,36,18,0,462,75,1,0,0,0,463,464,3,
  	78,39,0,464,465,3,82,41,0,465,466,3,36,18,0,466,77,1,0,0,0,467,469,5,
  	6,0,0,468,470,3,80,40,0,469,468,1,0,0,0,469,470,1,0,0,0,470,471,1,0,0,
  	0,471,472,5,109,0,0,472,473,5,11,0,0,473,79,1,0,0,0,474,475,7,2,0,0,475,
  	81,1,0,0,0,476,477,7,3,0,0,477,83,1,0,0,0,478,482,5,20,0,0,479,480,5,
  	33,0,0,480,481,5,27,0,0,481,483,5,107,0,0,482,479,1,0,0,0,482,483,1,0,
  	0,0,483,85,1,0,0,0,484,489,3,88,44,0,485,486,5,1,0,0,486,488,3,88,44,
  	0,487,485,1,0,0,0,488,491,1,0,0,0,489,487,1,0,0,0,489,490,1,0,0,0,490,
  	87,1,0,0,0,491,489,1,0,0,0,492,494,5,107,0,0,493,492,1,0,0,0,493,494,
  	1,0,0,0,494,495,1,0,0,0,495,497,3,36,18,0,496,498,3,90,45,0,497,496,1,
  	0,0,0,497,498,1,0,0,0,498,506,1,0,0,0,499,501,5,107,0,0,500,499,1,0,0,
  	0,500,501,1,0,0,0,501,502,1,0,0,0,502,503,5,30,0,0,503,504,5,74,0,0,504,
  	506,3,36,18,0,505,493,1,0,0,0,505,500,1,0,0,0,506,89,1,0,0,0,507,514,
  	5,75,0,0,508,510,5,32,0,0,509,511,5,107,0,0,510,509,1,0,0,0,510,511,1,
  	0,0,0,511,512,1,0,0,0,512,514,3,134,67,0,513,507,1,0,0,0,513,508,1,0,
  	0,0,514,91,1,0,0,0,515,518,3,94,47,0,516,518,3,100,50,0,517,515,1,0,0,
  	0,517,516,1,0,0,0,518,93,1,0,0,0,519,520,5,5,0,0,520,525,3,96,48,0,521,
  	522,5,1,0,0,522,524,3,96,48,0,523,521,1,0,0,0,524,527,1,0,0,0,525,523,
  	1,0,0,0,525,526,1,0,0,0,526,528,1,0,0,0,527,525,1,0,0,0,528,529,5,10,
  	0,0,529,95,1,0,0,0,530,531,5,107,0,0,531,532,5,7,0,0,532,533,3,98,49,
  	0,533,534,5,12,0,0,534,97,1,0,0,0,535,540,5,109,0,0,536,540,3,148,74,
  	0,537,540,3,150,75,0,538,540,3,136,68,0,539,535,1,0,0,0,539,536,1,0,0,
  	0,539,537,1,0,0,0,539,538,1,0,0,0,540,99,1,0,0,0,541,542,5,7,0,0,542,
  	547,3,102,51,0,543,544,5,15,0,0,544,546,3,102,51,0,545,543,1,0,0,0,546,
  	549,1,0,0,0,547,545,1,0,0,0,547,548,1,0,0,0,548,550,1,0,0,0,549,547,1,
  	0,0,0,550,551,5,12,0,0,551,101,1,0,0,0,552,558,3,106,53,0,553,558,3,114,
  	57,0,554,558,3,116,58,0,555,558,3,118,59,0,556,558,3,120,60,0,557,552,
  	1,0,0,0,557,553,1,0,0,0,557,554,1,0,0,0,557,555,1,0,0,0,557,556,1,0,0,
  	0,558,103,1,0,0,0,559,560,5,7,0,0,560,565,3,106,53,0,561,562,5,15,0,0,
  	562,564,3,106,53,0,563,561,1,0,0,0,564,567,1,0,0,0,565,563,1,0,0,0,565,
  	566,1,0,0,0,566,568,1,0,0,0,567,565,1,0,0,0,568,569,5,12,0,0,569,105,
  	1,0,0,0,570,572,3,110,55,0,571,573,3,108,54,0,572,571,1,0,0,0,572,573,
  	1,0,0,0,573,107,1,0,0,0,574,576,5,8,0,0,575,574,1,0,0,0,575,576,1,0,0,
  	0,576,577,1,0,0,0,577,579,5,4,0,0,578,580,5,8,0,0,579,578,1,0,0,0,579,
  	580,1,0,0,0,580,581,1,0,0,0,581,582,3,112,56,0,582,109,1,0,0,0,583,586,
  	3,134,67,0,584,586,5,57,0,0,585,583,1,0,0,0,585,584,1,0,0,0,586,111,1,
  	0,0,0,587,590,3,134,67,0,588,590,5,55,0,0,589,587,1,0,0,0,589,588,1,0,
  	0,0,590,113,1,0,0,0,591,592,5,89,0,0,592,593,3,104,52,0,593,115,1,0,0,
  	0,594,595,5,44,0,0,595,596,3,104,52,0,596,117,1,0,0,0,597,598,5,49,0,
  	0,598,599,3,36,18,0,599,119,1,0,0,0,600,601,5,102,0,0,601,602,5,29,0,
  	0,602,607,3,92,46,0,603,604,5,102,0,0,604,605,5,30,0,0,605,607,3,122,
  	61,0,606,600,1,0,0,0,606,603,1,0,0,0,607,121,1,0,0,0,608,622,5,5,0,0,
  	609,613,3,126,63,0,610,612,3,124,62,0,611,610,1,0,0,0,612,615,1,0,0,0,
  	613,611,1,0,0,0,613,614,1,0,0,0,614,623,1,0,0,0,615,613,1,0,0,0,616,618,
  	5,14,0,0,617,619,3,124,62,0,618,617,1,0,0,0,619,620,1,0,0,0,620,618,1,
  	0,0,0,620,621,1,0,0,0,621,623,1,0,0,0,622,609,1,0,0,0,622,616,1,0,0,0,
  	623,624,1,0,0,0,624,625,5,10,0,0,625,123,1,0,0,0,626,628,5,1,0,0,627,
  	629,3,126,63,0,628,627,1,0,0,0,628,629,1,0,0,0,629,125,1,0,0,0,630,632,
  	5,107,0,0,631,633,3,128,64,0,632,631,1,0,0,0,632,633,1,0,0,0,633,636,
  	1,0,0,0,634,636,3,128,64,0,635,630,1,0,0,0,635,634,1,0,0,0,636,127,1,
  	0,0,0,637,639,3,92,46,0,638,640,3,130,65,0,639,638,1,0,0,0,639,640,1,
  	0,0,0,640,643,1,0,0,0,641,643,3,130,65,0,642,637,1,0,0,0,642,641,1,0,
  	0,0,643,129,1,0,0,0,644,645,7,4,0,0,645,131,1,0,0,0,646,647,5,107,0,0,
  	647,648,3,36,18,0,648,649,5,2,0,0,649,650,3,134,67,0,650,133,1,0,0,0,
  	651,654,3,138,69,0,652,654,3,136,68,0,653,651,1,0,0,0,653,652,1,0,0,0,
  	654,135,1,0,0,0,655,663,5,108,0,0,656,663,5,104,0,0,657,663,5,105,0,0,
  	658,660,3,6,3,0,659,658,1,0,0,0,659,660,1,0,0,0,660,661,1,0,0,0,661,663,
  	5,107,0,0,662,655,1,0,0,0,662,656,1,0,0,0,662,657,1,0,0,0,662,659,1,0,
  	0,0,663,137,1,0,0,0,664,673,3,140,70,0,665,673,3,142,71,0,666,673,3,144,
  	72,0,667,673,3,146,73,0,668,673,3,148,74,0,669,673,3,150,75,0,670,673,
  	3,152,76,0,671,673,3,154,77,0,672,664,1,0,0,0,672,665,1,0,0,0,672,666,
  	1,0,0,0,672,667,1,0,0,0,672,668,1,0,0,0,672,669,1,0,0,0,672,670,1,0,0,
  	0,672,671,1,0,0,0,673,139,1,0,0,0,674,675,5,67,0,0,675,141,1,0,0,0,676,
  	677,7,5,0,0,677,143,1,0,0,0,678,679,7,6,0,0,679,145,1,0,0,0,680,682,5,
  	9,0,0,681,680,1,0,0,0,681,682,1,0,0,0,682,683,1,0,0,0,683,684,5,109,0,
  	0,684,147,1,0,0,0,685,686,5,104,0,0,686,149,1,0,0,0,687,688,5,105,0,0,
  	688,151,1,0,0,0,689,690,5,106,0,0,690,153,1,0,0,0,691,692,3,160,80,0,
  	692,155,1,0,0,0,693,694,3,160,80,0,694,157,1,0,0,0,695,696,3,160,80,0,
  	696,159,1,0,0,0,697,701,5,5,0,0,698,700,3,162,81,0,699,698,1,0,0,0,700,
  	703,1,0,0,0,701,699,1,0,0,0,701,702,1,0,0,0,702,704,1,0,0,0,703,701,1,
  	0,0,0,704,705,5,10,0,0,705,161,1,0,0,0,706,708,5,1,0,0,707,706,1,0,0,
  	0,707,708,1,0,0,0,708,709,1,0,0,0,709,710,3,164,82,0,710,163,1,0,0,0,
  	711,715,5,109,0,0,712,715,5,107,0,0,713,715,3,166,83,0,714,711,1,0,0,
  	0,714,712,1,0,0,0,714,713,1,0,0,0,715,165,1,0,0,0,716,717,5,107,0,0,717,
  	720,5,7,0,0,718,721,5,109,0,0,719,721,3,136,68,0,720,718,1,0,0,0,720,
  	719,1,0,0,0,721,722,1,0,0,0,722,723,5,12,0,0,723,167,1,0,0,0,724,735,
  	3,174,87,0,725,735,3,176,88,0,726,735,3,178,89,0,727,735,3,180,90,0,728,
  	735,3,182,91,0,729,735,3,184,92,0,730,735,3,186,93,0,731,735,3,188,94,
  	0,732,735,3,190,95,0,733,735,3,192,96,0,734,724,1,0,0,0,734,725,1,0,0,
  	0,734,726,1,0,0,0,734,727,1,0,0,0,734,728,1,0,0,0,734,729,1,0,0,0,734,
  	730,1,0,0,0,734,731,1,0,0,0,734,732,1,0,0,0,734,733,1,0,0,0,735,169,1,
  	0,0,0,736,737,7,7,0,0,737,171,1,0,0,0,738,740,3,240,120,0,739,741,3,210,
  	105,0,740,739,1,0,0,0,740,741,1,0,0,0,741,743,1,0,0,0,742,744,3,236,118,
  	0,743,742,1,0,0,0,743,744,1,0,0,0,744,173,1,0,0,0,745,746,5,62,0,0,746,
  	747,3,246,123,0,747,748,3,232,116,0,748,749,3,206,103,0,749,753,3,210,
  	105,0,750,752,3,238,119,0,751,750,1,0,0,0,752,755,1,0,0,0,753,751,1,0,
  	0,0,753,754,1,0,0,0,754,175,1,0,0,0,755,753,1,0,0,0,756,757,5,70,0,0,
  	757,758,3,172,86,0,758,177,1,0,0,0,759,760,5,71,0,0,760,762,3,242,121,
  	0,761,763,3,244,122,0,762,761,1,0,0,0,762,763,1,0,0,0,763,765,1,0,0,0,
  	764,766,3,202,101,0,765,764,1,0,0,0,765,766,1,0,0,0,766,767,1,0,0,0,767,
  	768,3,218,109,0,768,770,3,172,86,0,769,771,3,216,108,0,770,769,1,0,0,
  	0,770,771,1,0,0,0,771,773,1,0,0,0,772,774,3,204,102,0,773,772,1,0,0,0,
  	773,774,1,0,0,0,774,776,1,0,0,0,775,777,3,208,104,0,776,775,1,0,0,0,776,
  	777,1,0,0,0,777,179,1,0,0,0,778,780,5,65,0,0,779,781,3,230,115,0,780,
  	779,1,0,0,0,780,781,1,0,0,0,781,782,1,0,0,0,782,783,3,172,86,0,783,181,
  	1,0,0,0,784,785,5,96,0,0,785,787,3,214,107,0,786,788,3,248,124,0,787,
  	786,1,0,0,0,787,788,1,0,0,0,788,789,1,0,0,0,789,791,3,210,105,0,790,792,
  	3,236,118,0,791,790,1,0,0,0,791,792,1,0,0,0,792,183,1,0,0,0,793,795,5,
  	95,0,0,794,796,3,212,106,0,795,794,1,0,0,0,795,796,1,0,0,0,796,797,1,
  	0,0,0,797,798,3,172,86,0,798,799,3,242,121,0,799,185,1,0,0,0,800,801,
  	5,69,0,0,801,802,3,230,115,0,802,803,3,172,86,0,803,187,1,0,0,0,804,805,
  	5,64,0,0,805,807,3,228,114,0,806,808,3,242,121,0,807,806,1,0,0,0,807,
  	808,1,0,0,0,808,810,1,0,0,0,809,811,3,218,109,0,810,809,1,0,0,0,810,811,
  	1,0,0,0,811,812,1,0,0,0,812,813,3,240,120,0,813,814,3,210,105,0,814,189,
  	1,0,0,0,815,816,5,61,0,0,816,820,3,172,86,0,817,819,3,200,100,0,818,817,
  	1,0,0,0,819,822,1,0,0,0,820,818,1,0,0,0,820,821,1,0,0,0,821,826,1,0,0,
  	0,822,820,1,0,0,0,823,824,5,59,0,0,824,827,3,220,110,0,825,827,3,226,
  	113,0,826,823,1,0,0,0,826,825,1,0,0,0,827,191,1,0,0,0,828,829,5,19,0,
  	0,829,830,3,234,117,0,830,834,3,172,86,0,831,833,3,194,97,0,832,831,1,
  	0,0,0,833,836,1,0,0,0,834,832,1,0,0,0,834,835,1,0,0,0,835,193,1,0,0,0,
  	836,834,1,0,0,0,837,838,5,92,0,0,838,839,3,4,2,0,839,841,3,196,98,0,840,
  	842,3,198,99,0,841,840,1,0,0,0,841,842,1,0,0,0,842,195,1,0,0,0,843,844,
  	5,49,0,0,844,845,3,18,9,0,845,197,1,0,0,0,846,847,5,101,0,0,847,856,5,
  	107,0,0,848,857,3,242,121,0,849,851,3,250,125,0,850,849,1,0,0,0,850,851,
  	1,0,0,0,851,852,1,0,0,0,852,854,3,202,101,0,853,855,3,208,104,0,854,853,
  	1,0,0,0,854,855,1,0,0,0,855,857,1,0,0,0,856,848,1,0,0,0,856,850,1,0,0,
  	0,857,199,1,0,0,0,858,859,5,45,0,0,859,860,5,107,0,0,860,862,3,210,105,
  	0,861,863,3,236,118,0,862,861,1,0,0,0,862,863,1,0,0,0,863,201,1,0,0,0,
  	864,865,5,18,0,0,865,866,5,107,0,0,866,203,1,0,0,0,867,868,5,22,0,0,868,
  	869,5,5,0,0,869,870,3,18,9,0,870,871,5,10,0,0,871,205,1,0,0,0,872,873,
  	5,31,0,0,873,874,5,106,0,0,874,207,1,0,0,0,875,876,5,35,0,0,876,877,5,
  	5,0,0,877,878,3,134,67,0,878,879,5,10,0,0,879,209,1,0,0,0,880,881,5,36,
  	0,0,881,882,5,106,0,0,882,211,1,0,0,0,883,884,5,37,0,0,884,885,5,106,
  	0,0,885,213,1,0,0,0,886,887,5,39,0,0,887,888,3,86,43,0,888,215,1,0,0,
  	0,889,890,5,50,0,0,890,893,3,60,30,0,891,893,3,86,43,0,892,889,1,0,0,
  	0,892,891,1,0,0,0,893,217,1,0,0,0,894,895,5,56,0,0,895,896,3,48,24,0,
  	896,219,1,0,0,0,897,898,5,53,0,0,898,899,5,5,0,0,899,900,3,18,9,0,900,
  	901,5,10,0,0,901,221,1,0,0,0,902,903,5,5,0,0,903,904,3,18,9,0,904,905,
  	5,10,0,0,905,223,1,0,0,0,906,907,3,6,3,0,907,908,3,222,111,0,908,225,
  	1,0,0,0,909,910,5,60,0,0,910,911,5,5,0,0,911,916,3,224,112,0,912,913,
  	5,1,0,0,913,915,3,224,112,0,914,912,1,0,0,0,915,918,1,0,0,0,916,914,1,
  	0,0,0,916,917,1,0,0,0,917,919,1,0,0,0,918,916,1,0,0,0,919,920,5,10,0,
  	0,920,227,1,0,0,0,921,922,5,66,0,0,922,923,5,5,0,0,923,924,3,18,9,0,924,
  	925,5,10,0,0,925,229,1,0,0,0,926,927,5,72,0,0,927,928,5,5,0,0,928,929,
  	3,18,9,0,929,930,5,10,0,0,930,231,1,0,0,0,931,932,5,76,0,0,932,933,5,
  	106,0,0,933,233,1,0,0,0,934,935,5,80,0,0,935,936,5,106,0,0,936,235,1,
  	0,0,0,937,938,5,85,0,0,938,939,5,106,0,0,939,237,1,0,0,0,940,941,5,86,
  	0,0,941,942,5,106,0,0,942,943,5,36,0,0,943,944,5,106,0,0,944,239,1,0,
  	0,0,945,946,5,90,0,0,946,947,5,107,0,0,947,241,1,0,0,0,948,949,5,93,0,
  	0,949,950,3,36,18,0,950,243,1,0,0,0,951,952,5,98,0,0,952,953,5,106,0,
  	0,953,245,1,0,0,0,954,955,5,52,0,0,955,956,5,106,0,0,956,247,1,0,0,0,
  	957,958,5,100,0,0,958,959,3,86,43,0,959,249,1,0,0,0,960,961,5,103,0,0,
  	961,962,3,36,18,0,962,251,1,0,0,0,92,255,260,265,271,279,282,285,291,
  	299,313,318,323,328,331,340,346,353,364,367,371,390,402,410,415,419,423,
  	432,440,446,469,482,489,493,497,500,505,510,513,517,525,539,547,557,565,
  	572,575,579,585,589,606,613,620,622,628,632,635,639,642,653,659,662,672,
  	681,701,707,714,720,734,740,743,753,762,765,770,773,776,780,787,791,795,
  	807,810,820,826,834,841,850,854,856,862,892,916
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  mibParserStaticData = std::move(staticData);
}

}

MIBParser::MIBParser(TokenStream *input) : MIBParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

MIBParser::MIBParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  MIBParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *mibParserStaticData->atn, mibParserStaticData->decisionToDFA, mibParserStaticData->sharedContextCache, options);
}

MIBParser::~MIBParser() {
  delete _interpreter;
}

const atn::ATN& MIBParser::getATN() const {
  return *mibParserStaticData->atn;
}

std::string MIBParser::getGrammarFileName() const {
  return "MIB.g4";
}

const std::vector<std::string>& MIBParser::getRuleNames() const {
  return mibParserStaticData->ruleNames;
}

const dfa::Vocabulary& MIBParser::getVocabulary() const {
  return mibParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView MIBParser::getSerializedATN() const {
  return mibParserStaticData->serializedATN;
}


//----------------- DataContext ------------------------------------------------------------------

MIBParser::DataContext::DataContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MIBParser::ModuleDefinitionContext *> MIBParser::DataContext::moduleDefinition() {
  return getRuleContexts<MIBParser::ModuleDefinitionContext>();
}

MIBParser::ModuleDefinitionContext* MIBParser::DataContext::moduleDefinition(size_t i) {
  return getRuleContext<MIBParser::ModuleDefinitionContext>(i);
}


size_t MIBParser::DataContext::getRuleIndex() const {
  return MIBParser::RuleData;
}

void MIBParser::DataContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterData(this);
}

void MIBParser::DataContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitData(this);
}

MIBParser::DataContext* MIBParser::data() {
  DataContext *_localctx = _tracker.createInstance<DataContext>(_ctx, getState());
  enterRule(_localctx, 0, MIBParser::RuleData);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(253); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(252);
      moduleDefinition();
      setState(255); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MIBParser::IDENTIFIER_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleDefinitionContext ------------------------------------------------------------------

MIBParser::ModuleDefinitionContext::ModuleDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::ModuleIdentifierContext* MIBParser::ModuleDefinitionContext::moduleIdentifier() {
  return getRuleContext<MIBParser::ModuleIdentifierContext>(0);
}

tree::TerminalNode* MIBParser::ModuleDefinitionContext::DEFINITIONS() {
  return getToken(MIBParser::DEFINITIONS, 0);
}

tree::TerminalNode* MIBParser::ModuleDefinitionContext::DEFINITION() {
  return getToken(MIBParser::DEFINITION, 0);
}

tree::TerminalNode* MIBParser::ModuleDefinitionContext::BEGIN() {
  return getToken(MIBParser::BEGIN, 0);
}

tree::TerminalNode* MIBParser::ModuleDefinitionContext::END() {
  return getToken(MIBParser::END, 0);
}

MIBParser::TagDefaultContext* MIBParser::ModuleDefinitionContext::tagDefault() {
  return getRuleContext<MIBParser::TagDefaultContext>(0);
}

MIBParser::ModuleBodyContext* MIBParser::ModuleDefinitionContext::moduleBody() {
  return getRuleContext<MIBParser::ModuleBodyContext>(0);
}


size_t MIBParser::ModuleDefinitionContext::getRuleIndex() const {
  return MIBParser::RuleModuleDefinition;
}

void MIBParser::ModuleDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleDefinition(this);
}

void MIBParser::ModuleDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleDefinition(this);
}

MIBParser::ModuleDefinitionContext* MIBParser::moduleDefinition() {
  ModuleDefinitionContext *_localctx = _tracker.createInstance<ModuleDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 2, MIBParser::RuleModuleDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(257);
    moduleIdentifier();
    setState(258);
    match(MIBParser::DEFINITIONS);
    setState(260);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::EXPLICIT

    || _la == MIBParser::IMPLICIT) {
      setState(259);
      tagDefault();
    }
    setState(262);
    match(MIBParser::DEFINITION);
    setState(263);
    match(MIBParser::BEGIN);
    setState(265);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917814900664827904) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 8802535473379) != 0)) {
      setState(264);
      moduleBody();
    }
    setState(267);
    match(MIBParser::END);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleIdentifierContext ------------------------------------------------------------------

MIBParser::ModuleIdentifierContext::ModuleIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ModuleIdentifierContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::ObjectIdentifierValueContext* MIBParser::ModuleIdentifierContext::objectIdentifierValue() {
  return getRuleContext<MIBParser::ObjectIdentifierValueContext>(0);
}


size_t MIBParser::ModuleIdentifierContext::getRuleIndex() const {
  return MIBParser::RuleModuleIdentifier;
}

void MIBParser::ModuleIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleIdentifier(this);
}

void MIBParser::ModuleIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleIdentifier(this);
}

MIBParser::ModuleIdentifierContext* MIBParser::moduleIdentifier() {
  ModuleIdentifierContext *_localctx = _tracker.createInstance<ModuleIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 4, MIBParser::RuleModuleIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(269);
    match(MIBParser::IDENTIFIER_STRING);
    setState(271);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LEFT_BRACE) {
      setState(270);
      objectIdentifierValue();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleReferenceContext ------------------------------------------------------------------

MIBParser::ModuleReferenceContext::ModuleReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ModuleReferenceContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}


size_t MIBParser::ModuleReferenceContext::getRuleIndex() const {
  return MIBParser::RuleModuleReference;
}

void MIBParser::ModuleReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleReference(this);
}

void MIBParser::ModuleReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleReference(this);
}

MIBParser::ModuleReferenceContext* MIBParser::moduleReference() {
  ModuleReferenceContext *_localctx = _tracker.createInstance<ModuleReferenceContext>(_ctx, getState());
  enterRule(_localctx, 6, MIBParser::RuleModuleReference);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(273);
    match(MIBParser::IDENTIFIER_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TagDefaultContext ------------------------------------------------------------------

MIBParser::TagDefaultContext::TagDefaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::TagDefaultContext::EXPLICIT() {
  return getToken(MIBParser::EXPLICIT, 0);
}

tree::TerminalNode* MIBParser::TagDefaultContext::TAGS() {
  return getToken(MIBParser::TAGS, 0);
}

tree::TerminalNode* MIBParser::TagDefaultContext::IMPLICIT() {
  return getToken(MIBParser::IMPLICIT, 0);
}


size_t MIBParser::TagDefaultContext::getRuleIndex() const {
  return MIBParser::RuleTagDefault;
}

void MIBParser::TagDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTagDefault(this);
}

void MIBParser::TagDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTagDefault(this);
}

MIBParser::TagDefaultContext* MIBParser::tagDefault() {
  TagDefaultContext *_localctx = _tracker.createInstance<TagDefaultContext>(_ctx, getState());
  enterRule(_localctx, 8, MIBParser::RuleTagDefault);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(279);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::EXPLICIT: {
        enterOuterAlt(_localctx, 1);
        setState(275);
        match(MIBParser::EXPLICIT);
        setState(276);
        match(MIBParser::TAGS);
        break;
      }

      case MIBParser::IMPLICIT: {
        enterOuterAlt(_localctx, 2);
        setState(277);
        match(MIBParser::IMPLICIT);
        setState(278);
        match(MIBParser::TAGS);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ModuleBodyContext ------------------------------------------------------------------

MIBParser::ModuleBodyContext::ModuleBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::AssignmentListContext* MIBParser::ModuleBodyContext::assignmentList() {
  return getRuleContext<MIBParser::AssignmentListContext>(0);
}

MIBParser::ExportListContext* MIBParser::ModuleBodyContext::exportList() {
  return getRuleContext<MIBParser::ExportListContext>(0);
}

MIBParser::ImportListContext* MIBParser::ModuleBodyContext::importList() {
  return getRuleContext<MIBParser::ImportListContext>(0);
}


size_t MIBParser::ModuleBodyContext::getRuleIndex() const {
  return MIBParser::RuleModuleBody;
}

void MIBParser::ModuleBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModuleBody(this);
}

void MIBParser::ModuleBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModuleBody(this);
}

MIBParser::ModuleBodyContext* MIBParser::moduleBody() {
  ModuleBodyContext *_localctx = _tracker.createInstance<ModuleBodyContext>(_ctx, getState());
  enterRule(_localctx, 10, MIBParser::RuleModuleBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(282);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::EXPORTS) {
      setState(281);
      exportList();
    }
    setState(285);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::IMPORTS) {
      setState(284);
      importList();
    }
    setState(287);
    assignmentList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExportListContext ------------------------------------------------------------------

MIBParser::ExportListContext::ExportListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ExportListContext::EXPORTS() {
  return getToken(MIBParser::EXPORTS, 0);
}

tree::TerminalNode* MIBParser::ExportListContext::SEMI_COLON() {
  return getToken(MIBParser::SEMI_COLON, 0);
}

MIBParser::SymbolListContext* MIBParser::ExportListContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}


size_t MIBParser::ExportListContext::getRuleIndex() const {
  return MIBParser::RuleExportList;
}

void MIBParser::ExportListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExportList(this);
}

void MIBParser::ExportListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExportList(this);
}

MIBParser::ExportListContext* MIBParser::exportList() {
  ExportListContext *_localctx = _tracker.createInstance<ExportListContext>(_ctx, getState());
  enterRule(_localctx, 12, MIBParser::RuleExportList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(289);
    match(MIBParser::EXPORTS);
    setState(291);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917529027641606144) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 8802535473379) != 0)) {
      setState(290);
      symbolList();
    }
    setState(293);
    match(MIBParser::SEMI_COLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportListContext ------------------------------------------------------------------

MIBParser::ImportListContext::ImportListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ImportListContext::IMPORTS() {
  return getToken(MIBParser::IMPORTS, 0);
}

tree::TerminalNode* MIBParser::ImportListContext::SEMI_COLON() {
  return getToken(MIBParser::SEMI_COLON, 0);
}

std::vector<MIBParser::SymbolsFromModuleContext *> MIBParser::ImportListContext::symbolsFromModule() {
  return getRuleContexts<MIBParser::SymbolsFromModuleContext>();
}

MIBParser::SymbolsFromModuleContext* MIBParser::ImportListContext::symbolsFromModule(size_t i) {
  return getRuleContext<MIBParser::SymbolsFromModuleContext>(i);
}


size_t MIBParser::ImportListContext::getRuleIndex() const {
  return MIBParser::RuleImportList;
}

void MIBParser::ImportListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportList(this);
}

void MIBParser::ImportListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportList(this);
}

MIBParser::ImportListContext* MIBParser::importList() {
  ImportListContext *_localctx = _tracker.createInstance<ImportListContext>(_ctx, getState());
  enterRule(_localctx, 14, MIBParser::RuleImportList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(295);
    match(MIBParser::IMPORTS);
    setState(299);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917529027641606144) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 8802535473379) != 0)) {
      setState(296);
      symbolsFromModule();
      setState(301);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(302);
    match(MIBParser::SEMI_COLON);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolsFromModuleContext ------------------------------------------------------------------

MIBParser::SymbolsFromModuleContext::SymbolsFromModuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::SymbolListContext* MIBParser::SymbolsFromModuleContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}

tree::TerminalNode* MIBParser::SymbolsFromModuleContext::FROM() {
  return getToken(MIBParser::FROM, 0);
}

MIBParser::ModuleIdentifierContext* MIBParser::SymbolsFromModuleContext::moduleIdentifier() {
  return getRuleContext<MIBParser::ModuleIdentifierContext>(0);
}


size_t MIBParser::SymbolsFromModuleContext::getRuleIndex() const {
  return MIBParser::RuleSymbolsFromModule;
}

void MIBParser::SymbolsFromModuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbolsFromModule(this);
}

void MIBParser::SymbolsFromModuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbolsFromModule(this);
}

MIBParser::SymbolsFromModuleContext* MIBParser::symbolsFromModule() {
  SymbolsFromModuleContext *_localctx = _tracker.createInstance<SymbolsFromModuleContext>(_ctx, getState());
  enterRule(_localctx, 16, MIBParser::RuleSymbolsFromModule);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(304);
    symbolList();
    setState(305);
    match(MIBParser::FROM);
    setState(306);
    moduleIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolListContext ------------------------------------------------------------------

MIBParser::SymbolListContext::SymbolListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MIBParser::SymbolContext *> MIBParser::SymbolListContext::symbol() {
  return getRuleContexts<MIBParser::SymbolContext>();
}

MIBParser::SymbolContext* MIBParser::SymbolListContext::symbol(size_t i) {
  return getRuleContext<MIBParser::SymbolContext>(i);
}

std::vector<tree::TerminalNode *> MIBParser::SymbolListContext::COMMA() {
  return getTokens(MIBParser::COMMA);
}

tree::TerminalNode* MIBParser::SymbolListContext::COMMA(size_t i) {
  return getToken(MIBParser::COMMA, i);
}


size_t MIBParser::SymbolListContext::getRuleIndex() const {
  return MIBParser::RuleSymbolList;
}

void MIBParser::SymbolListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbolList(this);
}

void MIBParser::SymbolListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbolList(this);
}

MIBParser::SymbolListContext* MIBParser::symbolList() {
  SymbolListContext *_localctx = _tracker.createInstance<SymbolListContext>(_ctx, getState());
  enterRule(_localctx, 18, MIBParser::RuleSymbolList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(308);
    symbol();
    setState(313);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(309);
        match(MIBParser::COMMA);
        setState(310);
        symbol(); 
      }
      setState(315);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SymbolContext ------------------------------------------------------------------

MIBParser::SymbolContext::SymbolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SymbolContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::DefinedMacroNameContext* MIBParser::SymbolContext::definedMacroName() {
  return getRuleContext<MIBParser::DefinedMacroNameContext>(0);
}


size_t MIBParser::SymbolContext::getRuleIndex() const {
  return MIBParser::RuleSymbol;
}

void MIBParser::SymbolContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSymbol(this);
}

void MIBParser::SymbolContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSymbol(this);
}

MIBParser::SymbolContext* MIBParser::symbol() {
  SymbolContext *_localctx = _tracker.createInstance<SymbolContext>(_ctx, getState());
  enterRule(_localctx, 20, MIBParser::RuleSymbol);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(318);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::IDENTIFIER_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(316);
        match(MIBParser::IDENTIFIER_STRING);
        break;
      }

      case MIBParser::AGENT_CAPABILITIES:
      case MIBParser::MODULE_COMPLIANCE:
      case MIBParser::MODULE_IDENTITY:
      case MIBParser::NOTIFICATION_GROUP:
      case MIBParser::NOTIFICATION_TYPE:
      case MIBParser::OBJECT_GROUP:
      case MIBParser::OBJECT_IDENTITY:
      case MIBParser::OBJECT_TYPE:
      case MIBParser::TEXTUAL_CONVENTION:
      case MIBParser::TRAP_TYPE: {
        enterOuterAlt(_localctx, 2);
        setState(317);
        definedMacroName();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentListContext ------------------------------------------------------------------

MIBParser::AssignmentListContext::AssignmentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MIBParser::AssignmentContext *> MIBParser::AssignmentListContext::assignment() {
  return getRuleContexts<MIBParser::AssignmentContext>();
}

MIBParser::AssignmentContext* MIBParser::AssignmentListContext::assignment(size_t i) {
  return getRuleContext<MIBParser::AssignmentContext>(i);
}


size_t MIBParser::AssignmentListContext::getRuleIndex() const {
  return MIBParser::RuleAssignmentList;
}

void MIBParser::AssignmentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignmentList(this);
}

void MIBParser::AssignmentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignmentList(this);
}

MIBParser::AssignmentListContext* MIBParser::assignmentList() {
  AssignmentListContext *_localctx = _tracker.createInstance<AssignmentListContext>(_ctx, getState());
  enterRule(_localctx, 22, MIBParser::RuleAssignmentList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(321); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(320);
      assignment();
      setState(323); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917529027641606144) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 8802535473379) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignmentContext ------------------------------------------------------------------

MIBParser::AssignmentContext::AssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::MacroDefinitionContext* MIBParser::AssignmentContext::macroDefinition() {
  return getRuleContext<MIBParser::MacroDefinitionContext>(0);
}

MIBParser::TypeAssignmentContext* MIBParser::AssignmentContext::typeAssignment() {
  return getRuleContext<MIBParser::TypeAssignmentContext>(0);
}

MIBParser::ValueAssignmentContext* MIBParser::AssignmentContext::valueAssignment() {
  return getRuleContext<MIBParser::ValueAssignmentContext>(0);
}

tree::TerminalNode* MIBParser::AssignmentContext::SEMI_COLON() {
  return getToken(MIBParser::SEMI_COLON, 0);
}


size_t MIBParser::AssignmentContext::getRuleIndex() const {
  return MIBParser::RuleAssignment;
}

void MIBParser::AssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignment(this);
}

void MIBParser::AssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignment(this);
}

MIBParser::AssignmentContext* MIBParser::assignment() {
  AssignmentContext *_localctx = _tracker.createInstance<AssignmentContext>(_ctx, getState());
  enterRule(_localctx, 24, MIBParser::RuleAssignment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(328);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
    case 1: {
      setState(325);
      macroDefinition();
      break;
    }

    case 2: {
      setState(326);
      typeAssignment();
      break;
    }

    case 3: {
      setState(327);
      valueAssignment();
      break;
    }

    default:
      break;
    }
    setState(331);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::SEMI_COLON) {
      setState(330);
      match(MIBParser::SEMI_COLON);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroDefinitionContext ------------------------------------------------------------------

MIBParser::MacroDefinitionContext::MacroDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::MacroReferenceContext* MIBParser::MacroDefinitionContext::macroReference() {
  return getRuleContext<MIBParser::MacroReferenceContext>(0);
}

tree::TerminalNode* MIBParser::MacroDefinitionContext::MACRO() {
  return getToken(MIBParser::MACRO, 0);
}

tree::TerminalNode* MIBParser::MacroDefinitionContext::DEFINITION() {
  return getToken(MIBParser::DEFINITION, 0);
}

MIBParser::MacroBodyContext* MIBParser::MacroDefinitionContext::macroBody() {
  return getRuleContext<MIBParser::MacroBodyContext>(0);
}


size_t MIBParser::MacroDefinitionContext::getRuleIndex() const {
  return MIBParser::RuleMacroDefinition;
}

void MIBParser::MacroDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroDefinition(this);
}

void MIBParser::MacroDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroDefinition(this);
}

MIBParser::MacroDefinitionContext* MIBParser::macroDefinition() {
  MacroDefinitionContext *_localctx = _tracker.createInstance<MacroDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 26, MIBParser::RuleMacroDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(333);
    macroReference();
    setState(334);
    match(MIBParser::MACRO);
    setState(335);
    match(MIBParser::DEFINITION);
    setState(336);
    macroBody();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroReferenceContext ------------------------------------------------------------------

MIBParser::MacroReferenceContext::MacroReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::MacroReferenceContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::DefinedMacroNameContext* MIBParser::MacroReferenceContext::definedMacroName() {
  return getRuleContext<MIBParser::DefinedMacroNameContext>(0);
}


size_t MIBParser::MacroReferenceContext::getRuleIndex() const {
  return MIBParser::RuleMacroReference;
}

void MIBParser::MacroReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroReference(this);
}

void MIBParser::MacroReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroReference(this);
}

MIBParser::MacroReferenceContext* MIBParser::macroReference() {
  MacroReferenceContext *_localctx = _tracker.createInstance<MacroReferenceContext>(_ctx, getState());
  enterRule(_localctx, 28, MIBParser::RuleMacroReference);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(340);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::IDENTIFIER_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(338);
        match(MIBParser::IDENTIFIER_STRING);
        break;
      }

      case MIBParser::AGENT_CAPABILITIES:
      case MIBParser::MODULE_COMPLIANCE:
      case MIBParser::MODULE_IDENTITY:
      case MIBParser::NOTIFICATION_GROUP:
      case MIBParser::NOTIFICATION_TYPE:
      case MIBParser::OBJECT_GROUP:
      case MIBParser::OBJECT_IDENTITY:
      case MIBParser::OBJECT_TYPE:
      case MIBParser::TEXTUAL_CONVENTION:
      case MIBParser::TRAP_TYPE: {
        enterOuterAlt(_localctx, 2);
        setState(339);
        definedMacroName();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroBodyContext ------------------------------------------------------------------

MIBParser::MacroBodyContext::MacroBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::MacroBodyContext::BEGIN() {
  return getToken(MIBParser::BEGIN, 0);
}

tree::TerminalNode* MIBParser::MacroBodyContext::END() {
  return getToken(MIBParser::END, 0);
}

std::vector<MIBParser::MacroBodyElementContext *> MIBParser::MacroBodyContext::macroBodyElement() {
  return getRuleContexts<MIBParser::MacroBodyElementContext>();
}

MIBParser::MacroBodyElementContext* MIBParser::MacroBodyContext::macroBodyElement(size_t i) {
  return getRuleContext<MIBParser::MacroBodyElementContext>(i);
}

MIBParser::ModuleReferenceContext* MIBParser::MacroBodyContext::moduleReference() {
  return getRuleContext<MIBParser::ModuleReferenceContext>(0);
}

MIBParser::MacroReferenceContext* MIBParser::MacroBodyContext::macroReference() {
  return getRuleContext<MIBParser::MacroReferenceContext>(0);
}


size_t MIBParser::MacroBodyContext::getRuleIndex() const {
  return MIBParser::RuleMacroBody;
}

void MIBParser::MacroBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroBody(this);
}

void MIBParser::MacroBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroBody(this);
}

MIBParser::MacroBodyContext* MIBParser::macroBody() {
  MacroBodyContext *_localctx = _tracker.createInstance<MacroBodyContext>(_ctx, getState());
  enterRule(_localctx, 30, MIBParser::RuleMacroBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(353);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::BEGIN: {
        enterOuterAlt(_localctx, 1);
        setState(342);
        match(MIBParser::BEGIN);
        setState(346);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 2322168641785988) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 67)) & 1649284350019) != 0)) {
          setState(343);
          macroBodyElement();
          setState(348);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(349);
        match(MIBParser::END);
        break;
      }

      case MIBParser::IDENTIFIER_STRING: {
        enterOuterAlt(_localctx, 2);
        setState(350);
        moduleReference();
        setState(351);
        macroReference();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MacroBodyElementContext ------------------------------------------------------------------

MIBParser::MacroBodyElementContext::MacroBodyElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::LEFT_PAREN() {
  return getToken(MIBParser::LEFT_PAREN, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::RIGHT_PAREN() {
  return getToken(MIBParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::VERTICAL_BAR() {
  return getToken(MIBParser::VERTICAL_BAR, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::DEFINITION() {
  return getToken(MIBParser::DEFINITION, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::INTEGER() {
  return getToken(MIBParser::INTEGER, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::REAL() {
  return getToken(MIBParser::REAL, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::BOOLEAN() {
  return getToken(MIBParser::BOOLEAN, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::NULL_() {
  return getToken(MIBParser::NULL_, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::BIT() {
  return getToken(MIBParser::BIT, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::OCTET() {
  return getToken(MIBParser::OCTET, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::STRING() {
  return getToken(MIBParser::STRING, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::OBJECT() {
  return getToken(MIBParser::OBJECT, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::IDENTIFIER() {
  return getToken(MIBParser::IDENTIFIER, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

tree::TerminalNode* MIBParser::MacroBodyElementContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::MacroBodyElementContext::getRuleIndex() const {
  return MIBParser::RuleMacroBodyElement;
}

void MIBParser::MacroBodyElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMacroBodyElement(this);
}

void MIBParser::MacroBodyElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMacroBodyElement(this);
}

MIBParser::MacroBodyElementContext* MIBParser::macroBodyElement() {
  MacroBodyElementContext *_localctx = _tracker.createInstance<MacroBodyElementContext>(_ctx, getState());
  enterRule(_localctx, 32, MIBParser::RuleMacroBodyElement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(355);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 2322168641785988) != 0) || ((((_la - 67) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 67)) & 1649284350019) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeAssignmentContext ------------------------------------------------------------------

MIBParser::TypeAssignmentContext::TypeAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::TypeAssignmentContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

tree::TerminalNode* MIBParser::TypeAssignmentContext::DEFINITION() {
  return getToken(MIBParser::DEFINITION, 0);
}

MIBParser::TypeContext* MIBParser::TypeAssignmentContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}


size_t MIBParser::TypeAssignmentContext::getRuleIndex() const {
  return MIBParser::RuleTypeAssignment;
}

void MIBParser::TypeAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeAssignment(this);
}

void MIBParser::TypeAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeAssignment(this);
}

MIBParser::TypeAssignmentContext* MIBParser::typeAssignment() {
  TypeAssignmentContext *_localctx = _tracker.createInstance<TypeAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 34, MIBParser::RuleTypeAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(357);
    match(MIBParser::IDENTIFIER_STRING);
    setState(358);
    match(MIBParser::DEFINITION);
    setState(359);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeContext ------------------------------------------------------------------

MIBParser::TypeContext::TypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::BuiltinTypeContext* MIBParser::TypeContext::builtinType() {
  return getRuleContext<MIBParser::BuiltinTypeContext>(0);
}

MIBParser::DefinedTypeContext* MIBParser::TypeContext::definedType() {
  return getRuleContext<MIBParser::DefinedTypeContext>(0);
}

MIBParser::DefinedMacroTypeContext* MIBParser::TypeContext::definedMacroType() {
  return getRuleContext<MIBParser::DefinedMacroTypeContext>(0);
}


size_t MIBParser::TypeContext::getRuleIndex() const {
  return MIBParser::RuleType;
}

void MIBParser::TypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType(this);
}

void MIBParser::TypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType(this);
}

MIBParser::TypeContext* MIBParser::type() {
  TypeContext *_localctx = _tracker.createInstance<TypeContext>(_ctx, getState());
  enterRule(_localctx, 36, MIBParser::RuleType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(364);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(361);
      builtinType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(362);
      definedType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(363);
      definedMacroType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefinedTypeContext ------------------------------------------------------------------

MIBParser::DefinedTypeContext::DefinedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::DefinedTypeContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::ModuleReferenceContext* MIBParser::DefinedTypeContext::moduleReference() {
  return getRuleContext<MIBParser::ModuleReferenceContext>(0);
}

MIBParser::ValueOrConstraintListContext* MIBParser::DefinedTypeContext::valueOrConstraintList() {
  return getRuleContext<MIBParser::ValueOrConstraintListContext>(0);
}


size_t MIBParser::DefinedTypeContext::getRuleIndex() const {
  return MIBParser::RuleDefinedType;
}

void MIBParser::DefinedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefinedType(this);
}

void MIBParser::DefinedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefinedType(this);
}

MIBParser::DefinedTypeContext* MIBParser::definedType() {
  DefinedTypeContext *_localctx = _tracker.createInstance<DefinedTypeContext>(_ctx, getState());
  enterRule(_localctx, 38, MIBParser::RuleDefinedType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(367);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
    case 1: {
      setState(366);
      moduleReference();
      break;
    }

    default:
      break;
    }
    setState(369);
    match(MIBParser::IDENTIFIER_STRING);
    setState(371);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LEFT_BRACE

    || _la == MIBParser::LEFT_PAREN) {
      setState(370);
      valueOrConstraintList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BuiltinTypeContext ------------------------------------------------------------------

MIBParser::BuiltinTypeContext::BuiltinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::NullTypeContext* MIBParser::BuiltinTypeContext::nullType() {
  return getRuleContext<MIBParser::NullTypeContext>(0);
}

MIBParser::BooleanTypeContext* MIBParser::BuiltinTypeContext::booleanType() {
  return getRuleContext<MIBParser::BooleanTypeContext>(0);
}

MIBParser::RealTypeContext* MIBParser::BuiltinTypeContext::realType() {
  return getRuleContext<MIBParser::RealTypeContext>(0);
}

MIBParser::IntegerTypeContext* MIBParser::BuiltinTypeContext::integerType() {
  return getRuleContext<MIBParser::IntegerTypeContext>(0);
}

MIBParser::ObjectIdentifierTypeContext* MIBParser::BuiltinTypeContext::objectIdentifierType() {
  return getRuleContext<MIBParser::ObjectIdentifierTypeContext>(0);
}

MIBParser::StringTypeContext* MIBParser::BuiltinTypeContext::stringType() {
  return getRuleContext<MIBParser::StringTypeContext>(0);
}

MIBParser::BitStringTypeContext* MIBParser::BuiltinTypeContext::bitStringType() {
  return getRuleContext<MIBParser::BitStringTypeContext>(0);
}

MIBParser::BitsTypeContext* MIBParser::BuiltinTypeContext::bitsType() {
  return getRuleContext<MIBParser::BitsTypeContext>(0);
}

MIBParser::SequenceTypeContext* MIBParser::BuiltinTypeContext::sequenceType() {
  return getRuleContext<MIBParser::SequenceTypeContext>(0);
}

MIBParser::SequenceOfTypeContext* MIBParser::BuiltinTypeContext::sequenceOfType() {
  return getRuleContext<MIBParser::SequenceOfTypeContext>(0);
}

MIBParser::SetTypeContext* MIBParser::BuiltinTypeContext::setType() {
  return getRuleContext<MIBParser::SetTypeContext>(0);
}

MIBParser::SetOfTypeContext* MIBParser::BuiltinTypeContext::setOfType() {
  return getRuleContext<MIBParser::SetOfTypeContext>(0);
}

MIBParser::ChoiceTypeContext* MIBParser::BuiltinTypeContext::choiceType() {
  return getRuleContext<MIBParser::ChoiceTypeContext>(0);
}

MIBParser::EnumeratedTypeContext* MIBParser::BuiltinTypeContext::enumeratedType() {
  return getRuleContext<MIBParser::EnumeratedTypeContext>(0);
}

MIBParser::SelectionTypeContext* MIBParser::BuiltinTypeContext::selectionType() {
  return getRuleContext<MIBParser::SelectionTypeContext>(0);
}

MIBParser::TaggedTypeContext* MIBParser::BuiltinTypeContext::taggedType() {
  return getRuleContext<MIBParser::TaggedTypeContext>(0);
}

MIBParser::AnyTypeContext* MIBParser::BuiltinTypeContext::anyType() {
  return getRuleContext<MIBParser::AnyTypeContext>(0);
}


size_t MIBParser::BuiltinTypeContext::getRuleIndex() const {
  return MIBParser::RuleBuiltinType;
}

void MIBParser::BuiltinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBuiltinType(this);
}

void MIBParser::BuiltinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBuiltinType(this);
}

MIBParser::BuiltinTypeContext* MIBParser::builtinType() {
  BuiltinTypeContext *_localctx = _tracker.createInstance<BuiltinTypeContext>(_ctx, getState());
  enterRule(_localctx, 40, MIBParser::RuleBuiltinType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(390);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 20, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(373);
      nullType();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(374);
      booleanType();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(375);
      realType();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(376);
      integerType();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(377);
      objectIdentifierType();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(378);
      stringType();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(379);
      bitStringType();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(380);
      bitsType();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(381);
      sequenceType();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(382);
      sequenceOfType();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(383);
      setType();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(384);
      setOfType();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(385);
      choiceType();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(386);
      enumeratedType();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(387);
      selectionType();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(388);
      taggedType();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(389);
      anyType();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullTypeContext ------------------------------------------------------------------

MIBParser::NullTypeContext::NullTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NullTypeContext::NULL_() {
  return getToken(MIBParser::NULL_, 0);
}


size_t MIBParser::NullTypeContext::getRuleIndex() const {
  return MIBParser::RuleNullType;
}

void MIBParser::NullTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullType(this);
}

void MIBParser::NullTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullType(this);
}

MIBParser::NullTypeContext* MIBParser::nullType() {
  NullTypeContext *_localctx = _tracker.createInstance<NullTypeContext>(_ctx, getState());
  enterRule(_localctx, 42, MIBParser::RuleNullType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(392);
    match(MIBParser::NULL_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanTypeContext ------------------------------------------------------------------

MIBParser::BooleanTypeContext::BooleanTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::BooleanTypeContext::BOOLEAN() {
  return getToken(MIBParser::BOOLEAN, 0);
}


size_t MIBParser::BooleanTypeContext::getRuleIndex() const {
  return MIBParser::RuleBooleanType;
}

void MIBParser::BooleanTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanType(this);
}

void MIBParser::BooleanTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanType(this);
}

MIBParser::BooleanTypeContext* MIBParser::booleanType() {
  BooleanTypeContext *_localctx = _tracker.createInstance<BooleanTypeContext>(_ctx, getState());
  enterRule(_localctx, 44, MIBParser::RuleBooleanType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(394);
    match(MIBParser::BOOLEAN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RealTypeContext ------------------------------------------------------------------

MIBParser::RealTypeContext::RealTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::RealTypeContext::REAL() {
  return getToken(MIBParser::REAL, 0);
}


size_t MIBParser::RealTypeContext::getRuleIndex() const {
  return MIBParser::RuleRealType;
}

void MIBParser::RealTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRealType(this);
}

void MIBParser::RealTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRealType(this);
}

MIBParser::RealTypeContext* MIBParser::realType() {
  RealTypeContext *_localctx = _tracker.createInstance<RealTypeContext>(_ctx, getState());
  enterRule(_localctx, 46, MIBParser::RuleRealType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(396);
    match(MIBParser::REAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccessLevelContext ------------------------------------------------------------------

MIBParser::AccessLevelContext::AccessLevelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::AccessLevelContext::READ_ONLY() {
  return getToken(MIBParser::READ_ONLY, 0);
}

tree::TerminalNode* MIBParser::AccessLevelContext::READ_WRITE() {
  return getToken(MIBParser::READ_WRITE, 0);
}

tree::TerminalNode* MIBParser::AccessLevelContext::READ_CREATE() {
  return getToken(MIBParser::READ_CREATE, 0);
}

tree::TerminalNode* MIBParser::AccessLevelContext::NOT_ACCESSIBLE() {
  return getToken(MIBParser::NOT_ACCESSIBLE, 0);
}

tree::TerminalNode* MIBParser::AccessLevelContext::ACCESSIBLE_FOR_NOTIFY() {
  return getToken(MIBParser::ACCESSIBLE_FOR_NOTIFY, 0);
}


size_t MIBParser::AccessLevelContext::getRuleIndex() const {
  return MIBParser::RuleAccessLevel;
}

void MIBParser::AccessLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccessLevel(this);
}

void MIBParser::AccessLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccessLevel(this);
}

MIBParser::AccessLevelContext* MIBParser::accessLevel() {
  AccessLevelContext *_localctx = _tracker.createInstance<AccessLevelContext>(_ctx, getState());
  enterRule(_localctx, 48, MIBParser::RuleAccessLevel);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(398);
    _la = _input->LA(1);
    if (!(_la == MIBParser::ACCESSIBLE_FOR_NOTIFY

    || _la == MIBParser::NOT_ACCESSIBLE || ((((_la - 81) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 81)) & 7) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntegerTypeContext ------------------------------------------------------------------

MIBParser::IntegerTypeContext::IntegerTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::IntegerTypeContext::INTEGER() {
  return getToken(MIBParser::INTEGER, 0);
}

MIBParser::ValueOrConstraintListContext* MIBParser::IntegerTypeContext::valueOrConstraintList() {
  return getRuleContext<MIBParser::ValueOrConstraintListContext>(0);
}


size_t MIBParser::IntegerTypeContext::getRuleIndex() const {
  return MIBParser::RuleIntegerType;
}

void MIBParser::IntegerTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntegerType(this);
}

void MIBParser::IntegerTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntegerType(this);
}

MIBParser::IntegerTypeContext* MIBParser::integerType() {
  IntegerTypeContext *_localctx = _tracker.createInstance<IntegerTypeContext>(_ctx, getState());
  enterRule(_localctx, 50, MIBParser::RuleIntegerType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(400);
    match(MIBParser::INTEGER);
    setState(402);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LEFT_BRACE

    || _la == MIBParser::LEFT_PAREN) {
      setState(401);
      valueOrConstraintList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectIdentifierTypeContext ------------------------------------------------------------------

MIBParser::ObjectIdentifierTypeContext::ObjectIdentifierTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ObjectIdentifierTypeContext::OBJECT() {
  return getToken(MIBParser::OBJECT, 0);
}

tree::TerminalNode* MIBParser::ObjectIdentifierTypeContext::IDENTIFIER() {
  return getToken(MIBParser::IDENTIFIER, 0);
}


size_t MIBParser::ObjectIdentifierTypeContext::getRuleIndex() const {
  return MIBParser::RuleObjectIdentifierType;
}

void MIBParser::ObjectIdentifierTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectIdentifierType(this);
}

void MIBParser::ObjectIdentifierTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectIdentifierType(this);
}

MIBParser::ObjectIdentifierTypeContext* MIBParser::objectIdentifierType() {
  ObjectIdentifierTypeContext *_localctx = _tracker.createInstance<ObjectIdentifierTypeContext>(_ctx, getState());
  enterRule(_localctx, 52, MIBParser::RuleObjectIdentifierType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(404);
    match(MIBParser::OBJECT);
    setState(405);
    match(MIBParser::IDENTIFIER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringTypeContext ------------------------------------------------------------------

MIBParser::StringTypeContext::StringTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::StringTypeContext::OCTET() {
  return getToken(MIBParser::OCTET, 0);
}

tree::TerminalNode* MIBParser::StringTypeContext::STRING() {
  return getToken(MIBParser::STRING, 0);
}

MIBParser::ConstraintListContext* MIBParser::StringTypeContext::constraintList() {
  return getRuleContext<MIBParser::ConstraintListContext>(0);
}


size_t MIBParser::StringTypeContext::getRuleIndex() const {
  return MIBParser::RuleStringType;
}

void MIBParser::StringTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringType(this);
}

void MIBParser::StringTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringType(this);
}

MIBParser::StringTypeContext* MIBParser::stringType() {
  StringTypeContext *_localctx = _tracker.createInstance<StringTypeContext>(_ctx, getState());
  enterRule(_localctx, 54, MIBParser::RuleStringType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(407);
    match(MIBParser::OCTET);
    setState(408);
    match(MIBParser::STRING);
    setState(410);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LEFT_PAREN) {
      setState(409);
      constraintList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitStringTypeContext ------------------------------------------------------------------

MIBParser::BitStringTypeContext::BitStringTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::BitStringTypeContext::BIT() {
  return getToken(MIBParser::BIT, 0);
}

tree::TerminalNode* MIBParser::BitStringTypeContext::STRING() {
  return getToken(MIBParser::STRING, 0);
}

MIBParser::ValueOrConstraintListContext* MIBParser::BitStringTypeContext::valueOrConstraintList() {
  return getRuleContext<MIBParser::ValueOrConstraintListContext>(0);
}


size_t MIBParser::BitStringTypeContext::getRuleIndex() const {
  return MIBParser::RuleBitStringType;
}

void MIBParser::BitStringTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitStringType(this);
}

void MIBParser::BitStringTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitStringType(this);
}

MIBParser::BitStringTypeContext* MIBParser::bitStringType() {
  BitStringTypeContext *_localctx = _tracker.createInstance<BitStringTypeContext>(_ctx, getState());
  enterRule(_localctx, 56, MIBParser::RuleBitStringType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(412);
    match(MIBParser::BIT);
    setState(413);
    match(MIBParser::STRING);
    setState(415);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LEFT_BRACE

    || _la == MIBParser::LEFT_PAREN) {
      setState(414);
      valueOrConstraintList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitsTypeContext ------------------------------------------------------------------

MIBParser::BitsTypeContext::BitsTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::BitsTypeContext::BITS() {
  return getToken(MIBParser::BITS, 0);
}

MIBParser::ValueOrConstraintListContext* MIBParser::BitsTypeContext::valueOrConstraintList() {
  return getRuleContext<MIBParser::ValueOrConstraintListContext>(0);
}


size_t MIBParser::BitsTypeContext::getRuleIndex() const {
  return MIBParser::RuleBitsType;
}

void MIBParser::BitsTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitsType(this);
}

void MIBParser::BitsTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitsType(this);
}

MIBParser::BitsTypeContext* MIBParser::bitsType() {
  BitsTypeContext *_localctx = _tracker.createInstance<BitsTypeContext>(_ctx, getState());
  enterRule(_localctx, 58, MIBParser::RuleBitsType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(417);
    match(MIBParser::BITS);
    setState(419);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LEFT_BRACE

    || _la == MIBParser::LEFT_PAREN) {
      setState(418);
      valueOrConstraintList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SequenceContentContext ------------------------------------------------------------------

MIBParser::SequenceContentContext::SequenceContentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SequenceContentContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

tree::TerminalNode* MIBParser::SequenceContentContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}

MIBParser::ElementTypeListContext* MIBParser::SequenceContentContext::elementTypeList() {
  return getRuleContext<MIBParser::ElementTypeListContext>(0);
}


size_t MIBParser::SequenceContentContext::getRuleIndex() const {
  return MIBParser::RuleSequenceContent;
}

void MIBParser::SequenceContentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequenceContent(this);
}

void MIBParser::SequenceContentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequenceContent(this);
}

MIBParser::SequenceContentContext* MIBParser::sequenceContent() {
  SequenceContentContext *_localctx = _tracker.createInstance<SequenceContentContext>(_ctx, getState());
  enterRule(_localctx, 60, MIBParser::RuleSequenceContent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(421);
    match(MIBParser::LEFT_BRACE);
    setState(423);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6919781928427585600) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 8802561688315) != 0)) {
      setState(422);
      elementTypeList();
    }
    setState(425);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SequenceTypeContext ------------------------------------------------------------------

MIBParser::SequenceTypeContext::SequenceTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SequenceTypeContext::SEQUENCE() {
  return getToken(MIBParser::SEQUENCE, 0);
}

MIBParser::SequenceContentContext* MIBParser::SequenceTypeContext::sequenceContent() {
  return getRuleContext<MIBParser::SequenceContentContext>(0);
}


size_t MIBParser::SequenceTypeContext::getRuleIndex() const {
  return MIBParser::RuleSequenceType;
}

void MIBParser::SequenceTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequenceType(this);
}

void MIBParser::SequenceTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequenceType(this);
}

MIBParser::SequenceTypeContext* MIBParser::sequenceType() {
  SequenceTypeContext *_localctx = _tracker.createInstance<SequenceTypeContext>(_ctx, getState());
  enterRule(_localctx, 62, MIBParser::RuleSequenceType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(427);
    match(MIBParser::SEQUENCE);
    setState(428);
    sequenceContent();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SequenceOfTypeContext ------------------------------------------------------------------

MIBParser::SequenceOfTypeContext::SequenceOfTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SequenceOfTypeContext::SEQUENCE() {
  return getToken(MIBParser::SEQUENCE, 0);
}

tree::TerminalNode* MIBParser::SequenceOfTypeContext::OF() {
  return getToken(MIBParser::OF, 0);
}

MIBParser::TypeContext* MIBParser::SequenceOfTypeContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}

MIBParser::ConstraintListContext* MIBParser::SequenceOfTypeContext::constraintList() {
  return getRuleContext<MIBParser::ConstraintListContext>(0);
}


size_t MIBParser::SequenceOfTypeContext::getRuleIndex() const {
  return MIBParser::RuleSequenceOfType;
}

void MIBParser::SequenceOfTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSequenceOfType(this);
}

void MIBParser::SequenceOfTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSequenceOfType(this);
}

MIBParser::SequenceOfTypeContext* MIBParser::sequenceOfType() {
  SequenceOfTypeContext *_localctx = _tracker.createInstance<SequenceOfTypeContext>(_ctx, getState());
  enterRule(_localctx, 64, MIBParser::RuleSequenceOfType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(430);
    match(MIBParser::SEQUENCE);
    setState(432);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LEFT_PAREN) {
      setState(431);
      constraintList();
    }
    setState(434);
    match(MIBParser::OF);
    setState(435);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetTypeContext ------------------------------------------------------------------

MIBParser::SetTypeContext::SetTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SetTypeContext::SET() {
  return getToken(MIBParser::SET, 0);
}

tree::TerminalNode* MIBParser::SetTypeContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

tree::TerminalNode* MIBParser::SetTypeContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}

MIBParser::ElementTypeListContext* MIBParser::SetTypeContext::elementTypeList() {
  return getRuleContext<MIBParser::ElementTypeListContext>(0);
}


size_t MIBParser::SetTypeContext::getRuleIndex() const {
  return MIBParser::RuleSetType;
}

void MIBParser::SetTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetType(this);
}

void MIBParser::SetTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetType(this);
}

MIBParser::SetTypeContext* MIBParser::setType() {
  SetTypeContext *_localctx = _tracker.createInstance<SetTypeContext>(_ctx, getState());
  enterRule(_localctx, 66, MIBParser::RuleSetType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(437);
    match(MIBParser::SET);
    setState(438);
    match(MIBParser::LEFT_BRACE);
    setState(440);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6919781928427585600) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 8802561688315) != 0)) {
      setState(439);
      elementTypeList();
    }
    setState(442);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetOfTypeContext ------------------------------------------------------------------

MIBParser::SetOfTypeContext::SetOfTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SetOfTypeContext::SET() {
  return getToken(MIBParser::SET, 0);
}

tree::TerminalNode* MIBParser::SetOfTypeContext::OF() {
  return getToken(MIBParser::OF, 0);
}

MIBParser::TypeContext* MIBParser::SetOfTypeContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}

MIBParser::SizeConstraintContext* MIBParser::SetOfTypeContext::sizeConstraint() {
  return getRuleContext<MIBParser::SizeConstraintContext>(0);
}


size_t MIBParser::SetOfTypeContext::getRuleIndex() const {
  return MIBParser::RuleSetOfType;
}

void MIBParser::SetOfTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetOfType(this);
}

void MIBParser::SetOfTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetOfType(this);
}

MIBParser::SetOfTypeContext* MIBParser::setOfType() {
  SetOfTypeContext *_localctx = _tracker.createInstance<SetOfTypeContext>(_ctx, getState());
  enterRule(_localctx, 68, MIBParser::RuleSetOfType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(444);
    match(MIBParser::SET);
    setState(446);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::SIZE) {
      setState(445);
      sizeConstraint();
    }
    setState(448);
    match(MIBParser::OF);
    setState(449);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChoiceTypeContext ------------------------------------------------------------------

MIBParser::ChoiceTypeContext::ChoiceTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ChoiceTypeContext::CHOICE() {
  return getToken(MIBParser::CHOICE, 0);
}

tree::TerminalNode* MIBParser::ChoiceTypeContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

MIBParser::ElementTypeListContext* MIBParser::ChoiceTypeContext::elementTypeList() {
  return getRuleContext<MIBParser::ElementTypeListContext>(0);
}

tree::TerminalNode* MIBParser::ChoiceTypeContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}


size_t MIBParser::ChoiceTypeContext::getRuleIndex() const {
  return MIBParser::RuleChoiceType;
}

void MIBParser::ChoiceTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChoiceType(this);
}

void MIBParser::ChoiceTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChoiceType(this);
}

MIBParser::ChoiceTypeContext* MIBParser::choiceType() {
  ChoiceTypeContext *_localctx = _tracker.createInstance<ChoiceTypeContext>(_ctx, getState());
  enterRule(_localctx, 70, MIBParser::RuleChoiceType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(451);
    match(MIBParser::CHOICE);
    setState(452);
    match(MIBParser::LEFT_BRACE);
    setState(453);
    elementTypeList();
    setState(454);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumeratedTypeContext ------------------------------------------------------------------

MIBParser::EnumeratedTypeContext::EnumeratedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::EnumeratedTypeContext::ENUMERATED() {
  return getToken(MIBParser::ENUMERATED, 0);
}

MIBParser::NamedNumberListContext* MIBParser::EnumeratedTypeContext::namedNumberList() {
  return getRuleContext<MIBParser::NamedNumberListContext>(0);
}


size_t MIBParser::EnumeratedTypeContext::getRuleIndex() const {
  return MIBParser::RuleEnumeratedType;
}

void MIBParser::EnumeratedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEnumeratedType(this);
}

void MIBParser::EnumeratedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEnumeratedType(this);
}

MIBParser::EnumeratedTypeContext* MIBParser::enumeratedType() {
  EnumeratedTypeContext *_localctx = _tracker.createInstance<EnumeratedTypeContext>(_ctx, getState());
  enterRule(_localctx, 72, MIBParser::RuleEnumeratedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(456);
    match(MIBParser::ENUMERATED);
    setState(457);
    namedNumberList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectionTypeContext ------------------------------------------------------------------

MIBParser::SelectionTypeContext::SelectionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SelectionTypeContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

tree::TerminalNode* MIBParser::SelectionTypeContext::LESS_THAN() {
  return getToken(MIBParser::LESS_THAN, 0);
}

MIBParser::TypeContext* MIBParser::SelectionTypeContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}


size_t MIBParser::SelectionTypeContext::getRuleIndex() const {
  return MIBParser::RuleSelectionType;
}

void MIBParser::SelectionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectionType(this);
}

void MIBParser::SelectionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectionType(this);
}

MIBParser::SelectionTypeContext* MIBParser::selectionType() {
  SelectionTypeContext *_localctx = _tracker.createInstance<SelectionTypeContext>(_ctx, getState());
  enterRule(_localctx, 74, MIBParser::RuleSelectionType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(459);
    match(MIBParser::IDENTIFIER_STRING);
    setState(460);
    match(MIBParser::LESS_THAN);
    setState(461);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TaggedTypeContext ------------------------------------------------------------------

MIBParser::TaggedTypeContext::TaggedTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::TagContext* MIBParser::TaggedTypeContext::tag() {
  return getRuleContext<MIBParser::TagContext>(0);
}

MIBParser::ExplicitOrImplicitTagContext* MIBParser::TaggedTypeContext::explicitOrImplicitTag() {
  return getRuleContext<MIBParser::ExplicitOrImplicitTagContext>(0);
}

MIBParser::TypeContext* MIBParser::TaggedTypeContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}


size_t MIBParser::TaggedTypeContext::getRuleIndex() const {
  return MIBParser::RuleTaggedType;
}

void MIBParser::TaggedTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTaggedType(this);
}

void MIBParser::TaggedTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTaggedType(this);
}

MIBParser::TaggedTypeContext* MIBParser::taggedType() {
  TaggedTypeContext *_localctx = _tracker.createInstance<TaggedTypeContext>(_ctx, getState());
  enterRule(_localctx, 76, MIBParser::RuleTaggedType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(463);
    tag();
    setState(464);
    explicitOrImplicitTag();
    setState(465);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TagContext ------------------------------------------------------------------

MIBParser::TagContext::TagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::TagContext::LEFT_BRACKET() {
  return getToken(MIBParser::LEFT_BRACKET, 0);
}

tree::TerminalNode* MIBParser::TagContext::NUMBER_STRING() {
  return getToken(MIBParser::NUMBER_STRING, 0);
}

tree::TerminalNode* MIBParser::TagContext::RIGHT_BRACKET() {
  return getToken(MIBParser::RIGHT_BRACKET, 0);
}

MIBParser::Class_Context* MIBParser::TagContext::class_() {
  return getRuleContext<MIBParser::Class_Context>(0);
}


size_t MIBParser::TagContext::getRuleIndex() const {
  return MIBParser::RuleTag;
}

void MIBParser::TagContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTag(this);
}

void MIBParser::TagContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTag(this);
}

MIBParser::TagContext* MIBParser::tag() {
  TagContext *_localctx = _tracker.createInstance<TagContext>(_ctx, getState());
  enterRule(_localctx, 78, MIBParser::RuleTag);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(467);
    match(MIBParser::LEFT_BRACKET);
    setState(469);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::APPLICATION || _la == MIBParser::PRIVATE

    || _la == MIBParser::UNIVERSAL) {
      setState(468);
      class_();
    }
    setState(471);
    match(MIBParser::NUMBER_STRING);
    setState(472);
    match(MIBParser::RIGHT_BRACKET);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Class_Context ------------------------------------------------------------------

MIBParser::Class_Context::Class_Context(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::Class_Context::UNIVERSAL() {
  return getToken(MIBParser::UNIVERSAL, 0);
}

tree::TerminalNode* MIBParser::Class_Context::APPLICATION() {
  return getToken(MIBParser::APPLICATION, 0);
}

tree::TerminalNode* MIBParser::Class_Context::PRIVATE() {
  return getToken(MIBParser::PRIVATE, 0);
}


size_t MIBParser::Class_Context::getRuleIndex() const {
  return MIBParser::RuleClass_;
}

void MIBParser::Class_Context::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterClass_(this);
}

void MIBParser::Class_Context::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitClass_(this);
}

MIBParser::Class_Context* MIBParser::class_() {
  Class_Context *_localctx = _tracker.createInstance<Class_Context>(_ctx, getState());
  enterRule(_localctx, 80, MIBParser::RuleClass_);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(474);
    _la = _input->LA(1);
    if (!(_la == MIBParser::APPLICATION || _la == MIBParser::PRIVATE

    || _la == MIBParser::UNIVERSAL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplicitOrImplicitTagContext ------------------------------------------------------------------

MIBParser::ExplicitOrImplicitTagContext::ExplicitOrImplicitTagContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ExplicitOrImplicitTagContext::EXPLICIT() {
  return getToken(MIBParser::EXPLICIT, 0);
}

tree::TerminalNode* MIBParser::ExplicitOrImplicitTagContext::IMPLICIT() {
  return getToken(MIBParser::IMPLICIT, 0);
}


size_t MIBParser::ExplicitOrImplicitTagContext::getRuleIndex() const {
  return MIBParser::RuleExplicitOrImplicitTag;
}

void MIBParser::ExplicitOrImplicitTagContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplicitOrImplicitTag(this);
}

void MIBParser::ExplicitOrImplicitTagContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplicitOrImplicitTag(this);
}

MIBParser::ExplicitOrImplicitTagContext* MIBParser::explicitOrImplicitTag() {
  ExplicitOrImplicitTagContext *_localctx = _tracker.createInstance<ExplicitOrImplicitTagContext>(_ctx, getState());
  enterRule(_localctx, 82, MIBParser::RuleExplicitOrImplicitTag);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(476);
    _la = _input->LA(1);
    if (!(_la == MIBParser::EXPLICIT

    || _la == MIBParser::IMPLICIT)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AnyTypeContext ------------------------------------------------------------------

MIBParser::AnyTypeContext::AnyTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::AnyTypeContext::ANY() {
  return getToken(MIBParser::ANY, 0);
}

tree::TerminalNode* MIBParser::AnyTypeContext::DEFINED() {
  return getToken(MIBParser::DEFINED, 0);
}

tree::TerminalNode* MIBParser::AnyTypeContext::BY() {
  return getToken(MIBParser::BY, 0);
}

tree::TerminalNode* MIBParser::AnyTypeContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}


size_t MIBParser::AnyTypeContext::getRuleIndex() const {
  return MIBParser::RuleAnyType;
}

void MIBParser::AnyTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnyType(this);
}

void MIBParser::AnyTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnyType(this);
}

MIBParser::AnyTypeContext* MIBParser::anyType() {
  AnyTypeContext *_localctx = _tracker.createInstance<AnyTypeContext>(_ctx, getState());
  enterRule(_localctx, 84, MIBParser::RuleAnyType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(478);
    match(MIBParser::ANY);
    setState(482);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::DEFINED) {
      setState(479);
      match(MIBParser::DEFINED);
      setState(480);
      match(MIBParser::BY);
      setState(481);
      match(MIBParser::IDENTIFIER_STRING);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementTypeListContext ------------------------------------------------------------------

MIBParser::ElementTypeListContext::ElementTypeListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MIBParser::ElementTypeContext *> MIBParser::ElementTypeListContext::elementType() {
  return getRuleContexts<MIBParser::ElementTypeContext>();
}

MIBParser::ElementTypeContext* MIBParser::ElementTypeListContext::elementType(size_t i) {
  return getRuleContext<MIBParser::ElementTypeContext>(i);
}

std::vector<tree::TerminalNode *> MIBParser::ElementTypeListContext::COMMA() {
  return getTokens(MIBParser::COMMA);
}

tree::TerminalNode* MIBParser::ElementTypeListContext::COMMA(size_t i) {
  return getToken(MIBParser::COMMA, i);
}


size_t MIBParser::ElementTypeListContext::getRuleIndex() const {
  return MIBParser::RuleElementTypeList;
}

void MIBParser::ElementTypeListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElementTypeList(this);
}

void MIBParser::ElementTypeListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElementTypeList(this);
}

MIBParser::ElementTypeListContext* MIBParser::elementTypeList() {
  ElementTypeListContext *_localctx = _tracker.createInstance<ElementTypeListContext>(_ctx, getState());
  enterRule(_localctx, 86, MIBParser::RuleElementTypeList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(484);
    elementType();
    setState(489);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(485);
        match(MIBParser::COMMA);
        setState(486);
        elementType(); 
      }
      setState(491);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElementTypeContext ------------------------------------------------------------------

MIBParser::ElementTypeContext::ElementTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::TypeContext* MIBParser::ElementTypeContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}

tree::TerminalNode* MIBParser::ElementTypeContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::OptionalOrDefaultElementContext* MIBParser::ElementTypeContext::optionalOrDefaultElement() {
  return getRuleContext<MIBParser::OptionalOrDefaultElementContext>(0);
}

tree::TerminalNode* MIBParser::ElementTypeContext::COMPONENTS() {
  return getToken(MIBParser::COMPONENTS, 0);
}

tree::TerminalNode* MIBParser::ElementTypeContext::OF() {
  return getToken(MIBParser::OF, 0);
}


size_t MIBParser::ElementTypeContext::getRuleIndex() const {
  return MIBParser::RuleElementType;
}

void MIBParser::ElementTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElementType(this);
}

void MIBParser::ElementTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElementType(this);
}

MIBParser::ElementTypeContext* MIBParser::elementType() {
  ElementTypeContext *_localctx = _tracker.createInstance<ElementTypeContext>(_ctx, getState());
  enterRule(_localctx, 88, MIBParser::RuleElementType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(505);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(493);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
      case 1: {
        setState(492);
        match(MIBParser::IDENTIFIER_STRING);
        break;
      }

      default:
        break;
      }
      setState(495);
      type();
      setState(497);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx)) {
      case 1: {
        setState(496);
        optionalOrDefaultElement();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(500);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MIBParser::IDENTIFIER_STRING) {
        setState(499);
        match(MIBParser::IDENTIFIER_STRING);
      }
      setState(502);
      match(MIBParser::COMPONENTS);
      setState(503);
      match(MIBParser::OF);
      setState(504);
      type();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionalOrDefaultElementContext ------------------------------------------------------------------

MIBParser::OptionalOrDefaultElementContext::OptionalOrDefaultElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::OptionalOrDefaultElementContext::OPTIONAL() {
  return getToken(MIBParser::OPTIONAL, 0);
}

tree::TerminalNode* MIBParser::OptionalOrDefaultElementContext::DEFAULT() {
  return getToken(MIBParser::DEFAULT, 0);
}

MIBParser::ValueContext* MIBParser::OptionalOrDefaultElementContext::value() {
  return getRuleContext<MIBParser::ValueContext>(0);
}

tree::TerminalNode* MIBParser::OptionalOrDefaultElementContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}


size_t MIBParser::OptionalOrDefaultElementContext::getRuleIndex() const {
  return MIBParser::RuleOptionalOrDefaultElement;
}

void MIBParser::OptionalOrDefaultElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionalOrDefaultElement(this);
}

void MIBParser::OptionalOrDefaultElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionalOrDefaultElement(this);
}

MIBParser::OptionalOrDefaultElementContext* MIBParser::optionalOrDefaultElement() {
  OptionalOrDefaultElementContext *_localctx = _tracker.createInstance<OptionalOrDefaultElementContext>(_ctx, getState());
  enterRule(_localctx, 90, MIBParser::RuleOptionalOrDefaultElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(513);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::OPTIONAL: {
        enterOuterAlt(_localctx, 1);
        setState(507);
        match(MIBParser::OPTIONAL);
        break;
      }

      case MIBParser::DEFAULT: {
        enterOuterAlt(_localctx, 2);
        setState(508);
        match(MIBParser::DEFAULT);
        setState(510);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx)) {
        case 1: {
          setState(509);
          match(MIBParser::IDENTIFIER_STRING);
          break;
        }

        default:
          break;
        }
        setState(512);
        value();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueOrConstraintListContext ------------------------------------------------------------------

MIBParser::ValueOrConstraintListContext::ValueOrConstraintListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::NamedNumberListContext* MIBParser::ValueOrConstraintListContext::namedNumberList() {
  return getRuleContext<MIBParser::NamedNumberListContext>(0);
}

MIBParser::ConstraintListContext* MIBParser::ValueOrConstraintListContext::constraintList() {
  return getRuleContext<MIBParser::ConstraintListContext>(0);
}


size_t MIBParser::ValueOrConstraintListContext::getRuleIndex() const {
  return MIBParser::RuleValueOrConstraintList;
}

void MIBParser::ValueOrConstraintListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueOrConstraintList(this);
}

void MIBParser::ValueOrConstraintListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueOrConstraintList(this);
}

MIBParser::ValueOrConstraintListContext* MIBParser::valueOrConstraintList() {
  ValueOrConstraintListContext *_localctx = _tracker.createInstance<ValueOrConstraintListContext>(_ctx, getState());
  enterRule(_localctx, 92, MIBParser::RuleValueOrConstraintList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(517);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::LEFT_BRACE: {
        enterOuterAlt(_localctx, 1);
        setState(515);
        namedNumberList();
        break;
      }

      case MIBParser::LEFT_PAREN: {
        enterOuterAlt(_localctx, 2);
        setState(516);
        constraintList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedNumberListContext ------------------------------------------------------------------

MIBParser::NamedNumberListContext::NamedNumberListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NamedNumberListContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

std::vector<MIBParser::NamedNumberContext *> MIBParser::NamedNumberListContext::namedNumber() {
  return getRuleContexts<MIBParser::NamedNumberContext>();
}

MIBParser::NamedNumberContext* MIBParser::NamedNumberListContext::namedNumber(size_t i) {
  return getRuleContext<MIBParser::NamedNumberContext>(i);
}

tree::TerminalNode* MIBParser::NamedNumberListContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}

std::vector<tree::TerminalNode *> MIBParser::NamedNumberListContext::COMMA() {
  return getTokens(MIBParser::COMMA);
}

tree::TerminalNode* MIBParser::NamedNumberListContext::COMMA(size_t i) {
  return getToken(MIBParser::COMMA, i);
}


size_t MIBParser::NamedNumberListContext::getRuleIndex() const {
  return MIBParser::RuleNamedNumberList;
}

void MIBParser::NamedNumberListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedNumberList(this);
}

void MIBParser::NamedNumberListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedNumberList(this);
}

MIBParser::NamedNumberListContext* MIBParser::namedNumberList() {
  NamedNumberListContext *_localctx = _tracker.createInstance<NamedNumberListContext>(_ctx, getState());
  enterRule(_localctx, 94, MIBParser::RuleNamedNumberList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(519);
    match(MIBParser::LEFT_BRACE);
    setState(520);
    namedNumber();
    setState(525);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MIBParser::COMMA) {
      setState(521);
      match(MIBParser::COMMA);
      setState(522);
      namedNumber();
      setState(527);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(528);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NamedNumberContext ------------------------------------------------------------------

MIBParser::NamedNumberContext::NamedNumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NamedNumberContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

tree::TerminalNode* MIBParser::NamedNumberContext::LEFT_PAREN() {
  return getToken(MIBParser::LEFT_PAREN, 0);
}

MIBParser::NumberContext* MIBParser::NamedNumberContext::number() {
  return getRuleContext<MIBParser::NumberContext>(0);
}

tree::TerminalNode* MIBParser::NamedNumberContext::RIGHT_PAREN() {
  return getToken(MIBParser::RIGHT_PAREN, 0);
}


size_t MIBParser::NamedNumberContext::getRuleIndex() const {
  return MIBParser::RuleNamedNumber;
}

void MIBParser::NamedNumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNamedNumber(this);
}

void MIBParser::NamedNumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNamedNumber(this);
}

MIBParser::NamedNumberContext* MIBParser::namedNumber() {
  NamedNumberContext *_localctx = _tracker.createInstance<NamedNumberContext>(_ctx, getState());
  enterRule(_localctx, 96, MIBParser::RuleNamedNumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(530);
    match(MIBParser::IDENTIFIER_STRING);
    setState(531);
    match(MIBParser::LEFT_PAREN);
    setState(532);
    number();
    setState(533);
    match(MIBParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberContext ------------------------------------------------------------------

MIBParser::NumberContext::NumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NumberContext::NUMBER_STRING() {
  return getToken(MIBParser::NUMBER_STRING, 0);
}

MIBParser::BinaryValueContext* MIBParser::NumberContext::binaryValue() {
  return getRuleContext<MIBParser::BinaryValueContext>(0);
}

MIBParser::HexadecimalValueContext* MIBParser::NumberContext::hexadecimalValue() {
  return getRuleContext<MIBParser::HexadecimalValueContext>(0);
}

MIBParser::DefinedValueContext* MIBParser::NumberContext::definedValue() {
  return getRuleContext<MIBParser::DefinedValueContext>(0);
}


size_t MIBParser::NumberContext::getRuleIndex() const {
  return MIBParser::RuleNumber;
}

void MIBParser::NumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumber(this);
}

void MIBParser::NumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumber(this);
}

MIBParser::NumberContext* MIBParser::number() {
  NumberContext *_localctx = _tracker.createInstance<NumberContext>(_ctx, getState());
  enterRule(_localctx, 98, MIBParser::RuleNumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(539);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(535);
      match(MIBParser::NUMBER_STRING);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(536);
      binaryValue();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(537);
      hexadecimalValue();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(538);
      definedValue();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintListContext ------------------------------------------------------------------

MIBParser::ConstraintListContext::ConstraintListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ConstraintListContext::LEFT_PAREN() {
  return getToken(MIBParser::LEFT_PAREN, 0);
}

std::vector<MIBParser::ConstraintContext *> MIBParser::ConstraintListContext::constraint() {
  return getRuleContexts<MIBParser::ConstraintContext>();
}

MIBParser::ConstraintContext* MIBParser::ConstraintListContext::constraint(size_t i) {
  return getRuleContext<MIBParser::ConstraintContext>(i);
}

tree::TerminalNode* MIBParser::ConstraintListContext::RIGHT_PAREN() {
  return getToken(MIBParser::RIGHT_PAREN, 0);
}

std::vector<tree::TerminalNode *> MIBParser::ConstraintListContext::VERTICAL_BAR() {
  return getTokens(MIBParser::VERTICAL_BAR);
}

tree::TerminalNode* MIBParser::ConstraintListContext::VERTICAL_BAR(size_t i) {
  return getToken(MIBParser::VERTICAL_BAR, i);
}


size_t MIBParser::ConstraintListContext::getRuleIndex() const {
  return MIBParser::RuleConstraintList;
}

void MIBParser::ConstraintListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintList(this);
}

void MIBParser::ConstraintListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintList(this);
}

MIBParser::ConstraintListContext* MIBParser::constraintList() {
  ConstraintListContext *_localctx = _tracker.createInstance<ConstraintListContext>(_ctx, getState());
  enterRule(_localctx, 100, MIBParser::RuleConstraintList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(541);
    match(MIBParser::LEFT_PAREN);
    setState(542);
    constraint();
    setState(547);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MIBParser::VERTICAL_BAR) {
      setState(543);
      match(MIBParser::VERTICAL_BAR);
      setState(544);
      constraint();
      setState(549);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(550);
    match(MIBParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintContext ------------------------------------------------------------------

MIBParser::ConstraintContext::ConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::ValueConstraintContext* MIBParser::ConstraintContext::valueConstraint() {
  return getRuleContext<MIBParser::ValueConstraintContext>(0);
}

MIBParser::SizeConstraintContext* MIBParser::ConstraintContext::sizeConstraint() {
  return getRuleContext<MIBParser::SizeConstraintContext>(0);
}

MIBParser::AlphabetConstraintContext* MIBParser::ConstraintContext::alphabetConstraint() {
  return getRuleContext<MIBParser::AlphabetConstraintContext>(0);
}

MIBParser::ContainedTypeConstraintContext* MIBParser::ConstraintContext::containedTypeConstraint() {
  return getRuleContext<MIBParser::ContainedTypeConstraintContext>(0);
}

MIBParser::InnerTypeConstraintContext* MIBParser::ConstraintContext::innerTypeConstraint() {
  return getRuleContext<MIBParser::InnerTypeConstraintContext>(0);
}


size_t MIBParser::ConstraintContext::getRuleIndex() const {
  return MIBParser::RuleConstraint;
}

void MIBParser::ConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraint(this);
}

void MIBParser::ConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraint(this);
}

MIBParser::ConstraintContext* MIBParser::constraint() {
  ConstraintContext *_localctx = _tracker.createInstance<ConstraintContext>(_ctx, getState());
  enterRule(_localctx, 102, MIBParser::RuleConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(557);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::LEFT_BRACE:
      case MIBParser::MINUS:
      case MIBParser::FALSE:
      case MIBParser::MIN:
      case MIBParser::MINUS_INFINITY:
      case MIBParser::NULL_:
      case MIBParser::PLUS_INFINITY:
      case MIBParser::TRUE:
      case MIBParser::BINARY_STRING:
      case MIBParser::HEXADECIMAL_STRING:
      case MIBParser::QUOTED_STRING:
      case MIBParser::IDENTIFIER_STRING:
      case MIBParser::INTEGER_STRING:
      case MIBParser::NUMBER_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(552);
        valueConstraint();
        break;
      }

      case MIBParser::SIZE: {
        enterOuterAlt(_localctx, 2);
        setState(553);
        sizeConstraint();
        break;
      }

      case MIBParser::FROM: {
        enterOuterAlt(_localctx, 3);
        setState(554);
        alphabetConstraint();
        break;
      }

      case MIBParser::INCLUDES: {
        enterOuterAlt(_localctx, 4);
        setState(555);
        containedTypeConstraint();
        break;
      }

      case MIBParser::WITH: {
        enterOuterAlt(_localctx, 5);
        setState(556);
        innerTypeConstraint();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueConstraintListContext ------------------------------------------------------------------

MIBParser::ValueConstraintListContext::ValueConstraintListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ValueConstraintListContext::LEFT_PAREN() {
  return getToken(MIBParser::LEFT_PAREN, 0);
}

std::vector<MIBParser::ValueConstraintContext *> MIBParser::ValueConstraintListContext::valueConstraint() {
  return getRuleContexts<MIBParser::ValueConstraintContext>();
}

MIBParser::ValueConstraintContext* MIBParser::ValueConstraintListContext::valueConstraint(size_t i) {
  return getRuleContext<MIBParser::ValueConstraintContext>(i);
}

tree::TerminalNode* MIBParser::ValueConstraintListContext::RIGHT_PAREN() {
  return getToken(MIBParser::RIGHT_PAREN, 0);
}

std::vector<tree::TerminalNode *> MIBParser::ValueConstraintListContext::VERTICAL_BAR() {
  return getTokens(MIBParser::VERTICAL_BAR);
}

tree::TerminalNode* MIBParser::ValueConstraintListContext::VERTICAL_BAR(size_t i) {
  return getToken(MIBParser::VERTICAL_BAR, i);
}


size_t MIBParser::ValueConstraintListContext::getRuleIndex() const {
  return MIBParser::RuleValueConstraintList;
}

void MIBParser::ValueConstraintListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueConstraintList(this);
}

void MIBParser::ValueConstraintListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueConstraintList(this);
}

MIBParser::ValueConstraintListContext* MIBParser::valueConstraintList() {
  ValueConstraintListContext *_localctx = _tracker.createInstance<ValueConstraintListContext>(_ctx, getState());
  enterRule(_localctx, 104, MIBParser::RuleValueConstraintList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(559);
    match(MIBParser::LEFT_PAREN);
    setState(560);
    valueConstraint();
    setState(565);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MIBParser::VERTICAL_BAR) {
      setState(561);
      match(MIBParser::VERTICAL_BAR);
      setState(562);
      valueConstraint();
      setState(567);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(568);
    match(MIBParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueConstraintContext ------------------------------------------------------------------

MIBParser::ValueConstraintContext::ValueConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::LowerEndPointContext* MIBParser::ValueConstraintContext::lowerEndPoint() {
  return getRuleContext<MIBParser::LowerEndPointContext>(0);
}

MIBParser::ValueRangeContext* MIBParser::ValueConstraintContext::valueRange() {
  return getRuleContext<MIBParser::ValueRangeContext>(0);
}


size_t MIBParser::ValueConstraintContext::getRuleIndex() const {
  return MIBParser::RuleValueConstraint;
}

void MIBParser::ValueConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueConstraint(this);
}

void MIBParser::ValueConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueConstraint(this);
}

MIBParser::ValueConstraintContext* MIBParser::valueConstraint() {
  ValueConstraintContext *_localctx = _tracker.createInstance<ValueConstraintContext>(_ctx, getState());
  enterRule(_localctx, 106, MIBParser::RuleValueConstraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(570);
    lowerEndPoint();
    setState(572);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::DOUBLE_DOT

    || _la == MIBParser::LESS_THAN) {
      setState(571);
      valueRange();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueRangeContext ------------------------------------------------------------------

MIBParser::ValueRangeContext::ValueRangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ValueRangeContext::DOUBLE_DOT() {
  return getToken(MIBParser::DOUBLE_DOT, 0);
}

MIBParser::UpperEndPointContext* MIBParser::ValueRangeContext::upperEndPoint() {
  return getRuleContext<MIBParser::UpperEndPointContext>(0);
}

std::vector<tree::TerminalNode *> MIBParser::ValueRangeContext::LESS_THAN() {
  return getTokens(MIBParser::LESS_THAN);
}

tree::TerminalNode* MIBParser::ValueRangeContext::LESS_THAN(size_t i) {
  return getToken(MIBParser::LESS_THAN, i);
}


size_t MIBParser::ValueRangeContext::getRuleIndex() const {
  return MIBParser::RuleValueRange;
}

void MIBParser::ValueRangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueRange(this);
}

void MIBParser::ValueRangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueRange(this);
}

MIBParser::ValueRangeContext* MIBParser::valueRange() {
  ValueRangeContext *_localctx = _tracker.createInstance<ValueRangeContext>(_ctx, getState());
  enterRule(_localctx, 108, MIBParser::RuleValueRange);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(575);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LESS_THAN) {
      setState(574);
      match(MIBParser::LESS_THAN);
    }
    setState(577);
    match(MIBParser::DOUBLE_DOT);
    setState(579);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::LESS_THAN) {
      setState(578);
      match(MIBParser::LESS_THAN);
    }
    setState(581);
    upperEndPoint();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LowerEndPointContext ------------------------------------------------------------------

MIBParser::LowerEndPointContext::LowerEndPointContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::ValueContext* MIBParser::LowerEndPointContext::value() {
  return getRuleContext<MIBParser::ValueContext>(0);
}

tree::TerminalNode* MIBParser::LowerEndPointContext::MIN() {
  return getToken(MIBParser::MIN, 0);
}


size_t MIBParser::LowerEndPointContext::getRuleIndex() const {
  return MIBParser::RuleLowerEndPoint;
}

void MIBParser::LowerEndPointContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLowerEndPoint(this);
}

void MIBParser::LowerEndPointContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLowerEndPoint(this);
}

MIBParser::LowerEndPointContext* MIBParser::lowerEndPoint() {
  LowerEndPointContext *_localctx = _tracker.createInstance<LowerEndPointContext>(_ctx, getState());
  enterRule(_localctx, 110, MIBParser::RuleLowerEndPoint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(585);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::LEFT_BRACE:
      case MIBParser::MINUS:
      case MIBParser::FALSE:
      case MIBParser::MINUS_INFINITY:
      case MIBParser::NULL_:
      case MIBParser::PLUS_INFINITY:
      case MIBParser::TRUE:
      case MIBParser::BINARY_STRING:
      case MIBParser::HEXADECIMAL_STRING:
      case MIBParser::QUOTED_STRING:
      case MIBParser::IDENTIFIER_STRING:
      case MIBParser::INTEGER_STRING:
      case MIBParser::NUMBER_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(583);
        value();
        break;
      }

      case MIBParser::MIN: {
        enterOuterAlt(_localctx, 2);
        setState(584);
        match(MIBParser::MIN);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpperEndPointContext ------------------------------------------------------------------

MIBParser::UpperEndPointContext::UpperEndPointContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::ValueContext* MIBParser::UpperEndPointContext::value() {
  return getRuleContext<MIBParser::ValueContext>(0);
}

tree::TerminalNode* MIBParser::UpperEndPointContext::MAX() {
  return getToken(MIBParser::MAX, 0);
}


size_t MIBParser::UpperEndPointContext::getRuleIndex() const {
  return MIBParser::RuleUpperEndPoint;
}

void MIBParser::UpperEndPointContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpperEndPoint(this);
}

void MIBParser::UpperEndPointContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpperEndPoint(this);
}

MIBParser::UpperEndPointContext* MIBParser::upperEndPoint() {
  UpperEndPointContext *_localctx = _tracker.createInstance<UpperEndPointContext>(_ctx, getState());
  enterRule(_localctx, 112, MIBParser::RuleUpperEndPoint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(589);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::LEFT_BRACE:
      case MIBParser::MINUS:
      case MIBParser::FALSE:
      case MIBParser::MINUS_INFINITY:
      case MIBParser::NULL_:
      case MIBParser::PLUS_INFINITY:
      case MIBParser::TRUE:
      case MIBParser::BINARY_STRING:
      case MIBParser::HEXADECIMAL_STRING:
      case MIBParser::QUOTED_STRING:
      case MIBParser::IDENTIFIER_STRING:
      case MIBParser::INTEGER_STRING:
      case MIBParser::NUMBER_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(587);
        value();
        break;
      }

      case MIBParser::MAX: {
        enterOuterAlt(_localctx, 2);
        setState(588);
        match(MIBParser::MAX);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SizeConstraintContext ------------------------------------------------------------------

MIBParser::SizeConstraintContext::SizeConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SizeConstraintContext::SIZE() {
  return getToken(MIBParser::SIZE, 0);
}

MIBParser::ValueConstraintListContext* MIBParser::SizeConstraintContext::valueConstraintList() {
  return getRuleContext<MIBParser::ValueConstraintListContext>(0);
}


size_t MIBParser::SizeConstraintContext::getRuleIndex() const {
  return MIBParser::RuleSizeConstraint;
}

void MIBParser::SizeConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSizeConstraint(this);
}

void MIBParser::SizeConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSizeConstraint(this);
}

MIBParser::SizeConstraintContext* MIBParser::sizeConstraint() {
  SizeConstraintContext *_localctx = _tracker.createInstance<SizeConstraintContext>(_ctx, getState());
  enterRule(_localctx, 114, MIBParser::RuleSizeConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(591);
    match(MIBParser::SIZE);
    setState(592);
    valueConstraintList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlphabetConstraintContext ------------------------------------------------------------------

MIBParser::AlphabetConstraintContext::AlphabetConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::AlphabetConstraintContext::FROM() {
  return getToken(MIBParser::FROM, 0);
}

MIBParser::ValueConstraintListContext* MIBParser::AlphabetConstraintContext::valueConstraintList() {
  return getRuleContext<MIBParser::ValueConstraintListContext>(0);
}


size_t MIBParser::AlphabetConstraintContext::getRuleIndex() const {
  return MIBParser::RuleAlphabetConstraint;
}

void MIBParser::AlphabetConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlphabetConstraint(this);
}

void MIBParser::AlphabetConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlphabetConstraint(this);
}

MIBParser::AlphabetConstraintContext* MIBParser::alphabetConstraint() {
  AlphabetConstraintContext *_localctx = _tracker.createInstance<AlphabetConstraintContext>(_ctx, getState());
  enterRule(_localctx, 116, MIBParser::RuleAlphabetConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(594);
    match(MIBParser::FROM);
    setState(595);
    valueConstraintList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ContainedTypeConstraintContext ------------------------------------------------------------------

MIBParser::ContainedTypeConstraintContext::ContainedTypeConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ContainedTypeConstraintContext::INCLUDES() {
  return getToken(MIBParser::INCLUDES, 0);
}

MIBParser::TypeContext* MIBParser::ContainedTypeConstraintContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}


size_t MIBParser::ContainedTypeConstraintContext::getRuleIndex() const {
  return MIBParser::RuleContainedTypeConstraint;
}

void MIBParser::ContainedTypeConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterContainedTypeConstraint(this);
}

void MIBParser::ContainedTypeConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitContainedTypeConstraint(this);
}

MIBParser::ContainedTypeConstraintContext* MIBParser::containedTypeConstraint() {
  ContainedTypeConstraintContext *_localctx = _tracker.createInstance<ContainedTypeConstraintContext>(_ctx, getState());
  enterRule(_localctx, 118, MIBParser::RuleContainedTypeConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(597);
    match(MIBParser::INCLUDES);
    setState(598);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InnerTypeConstraintContext ------------------------------------------------------------------

MIBParser::InnerTypeConstraintContext::InnerTypeConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::InnerTypeConstraintContext::WITH() {
  return getToken(MIBParser::WITH, 0);
}

tree::TerminalNode* MIBParser::InnerTypeConstraintContext::COMPONENT() {
  return getToken(MIBParser::COMPONENT, 0);
}

MIBParser::ValueOrConstraintListContext* MIBParser::InnerTypeConstraintContext::valueOrConstraintList() {
  return getRuleContext<MIBParser::ValueOrConstraintListContext>(0);
}

tree::TerminalNode* MIBParser::InnerTypeConstraintContext::COMPONENTS() {
  return getToken(MIBParser::COMPONENTS, 0);
}

MIBParser::ComponentsListContext* MIBParser::InnerTypeConstraintContext::componentsList() {
  return getRuleContext<MIBParser::ComponentsListContext>(0);
}


size_t MIBParser::InnerTypeConstraintContext::getRuleIndex() const {
  return MIBParser::RuleInnerTypeConstraint;
}

void MIBParser::InnerTypeConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInnerTypeConstraint(this);
}

void MIBParser::InnerTypeConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInnerTypeConstraint(this);
}

MIBParser::InnerTypeConstraintContext* MIBParser::innerTypeConstraint() {
  InnerTypeConstraintContext *_localctx = _tracker.createInstance<InnerTypeConstraintContext>(_ctx, getState());
  enterRule(_localctx, 120, MIBParser::RuleInnerTypeConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(606);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(600);
      match(MIBParser::WITH);
      setState(601);
      match(MIBParser::COMPONENT);
      setState(602);
      valueOrConstraintList();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(603);
      match(MIBParser::WITH);
      setState(604);
      match(MIBParser::COMPONENTS);
      setState(605);
      componentsList();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentsListContext ------------------------------------------------------------------

MIBParser::ComponentsListContext::ComponentsListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ComponentsListContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

tree::TerminalNode* MIBParser::ComponentsListContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}

MIBParser::ComponentConstraintContext* MIBParser::ComponentsListContext::componentConstraint() {
  return getRuleContext<MIBParser::ComponentConstraintContext>(0);
}

tree::TerminalNode* MIBParser::ComponentsListContext::TRIPLE_DOT() {
  return getToken(MIBParser::TRIPLE_DOT, 0);
}

std::vector<MIBParser::ComponentsListTailContext *> MIBParser::ComponentsListContext::componentsListTail() {
  return getRuleContexts<MIBParser::ComponentsListTailContext>();
}

MIBParser::ComponentsListTailContext* MIBParser::ComponentsListContext::componentsListTail(size_t i) {
  return getRuleContext<MIBParser::ComponentsListTailContext>(i);
}


size_t MIBParser::ComponentsListContext::getRuleIndex() const {
  return MIBParser::RuleComponentsList;
}

void MIBParser::ComponentsListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponentsList(this);
}

void MIBParser::ComponentsListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponentsList(this);
}

MIBParser::ComponentsListContext* MIBParser::componentsList() {
  ComponentsListContext *_localctx = _tracker.createInstance<ComponentsListContext>(_ctx, getState());
  enterRule(_localctx, 122, MIBParser::RuleComponentsList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(608);
    match(MIBParser::LEFT_BRACE);
    setState(622);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::LEFT_BRACE:
      case MIBParser::LEFT_PAREN:
      case MIBParser::ABSENT:
      case MIBParser::OPTIONAL:
      case MIBParser::PRESENT:
      case MIBParser::IDENTIFIER_STRING: {
        setState(609);
        componentConstraint();
        setState(613);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MIBParser::COMMA) {
          setState(610);
          componentsListTail();
          setState(615);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MIBParser::TRIPLE_DOT: {
        setState(616);
        match(MIBParser::TRIPLE_DOT);
        setState(618); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(617);
          componentsListTail();
          setState(620); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == MIBParser::COMMA);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(624);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentsListTailContext ------------------------------------------------------------------

MIBParser::ComponentsListTailContext::ComponentsListTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ComponentsListTailContext::COMMA() {
  return getToken(MIBParser::COMMA, 0);
}

MIBParser::ComponentConstraintContext* MIBParser::ComponentsListTailContext::componentConstraint() {
  return getRuleContext<MIBParser::ComponentConstraintContext>(0);
}


size_t MIBParser::ComponentsListTailContext::getRuleIndex() const {
  return MIBParser::RuleComponentsListTail;
}

void MIBParser::ComponentsListTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponentsListTail(this);
}

void MIBParser::ComponentsListTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponentsListTail(this);
}

MIBParser::ComponentsListTailContext* MIBParser::componentsListTail() {
  ComponentsListTailContext *_localctx = _tracker.createInstance<ComponentsListTailContext>(_ctx, getState());
  enterRule(_localctx, 124, MIBParser::RuleComponentsListTail);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(626);
    match(MIBParser::COMMA);
    setState(628);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 65696) != 0) || ((((_la - 75) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 75)) & 4294967305) != 0)) {
      setState(627);
      componentConstraint();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentConstraintContext ------------------------------------------------------------------

MIBParser::ComponentConstraintContext::ComponentConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ComponentConstraintContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::ComponentValuePresenceContext* MIBParser::ComponentConstraintContext::componentValuePresence() {
  return getRuleContext<MIBParser::ComponentValuePresenceContext>(0);
}


size_t MIBParser::ComponentConstraintContext::getRuleIndex() const {
  return MIBParser::RuleComponentConstraint;
}

void MIBParser::ComponentConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponentConstraint(this);
}

void MIBParser::ComponentConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponentConstraint(this);
}

MIBParser::ComponentConstraintContext* MIBParser::componentConstraint() {
  ComponentConstraintContext *_localctx = _tracker.createInstance<ComponentConstraintContext>(_ctx, getState());
  enterRule(_localctx, 126, MIBParser::RuleComponentConstraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(635);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::IDENTIFIER_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(630);
        match(MIBParser::IDENTIFIER_STRING);
        setState(632);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if ((((_la & ~ 0x3fULL) == 0) &&
          ((1ULL << _la) & 65696) != 0) || _la == MIBParser::OPTIONAL

        || _la == MIBParser::PRESENT) {
          setState(631);
          componentValuePresence();
        }
        break;
      }

      case MIBParser::LEFT_BRACE:
      case MIBParser::LEFT_PAREN:
      case MIBParser::ABSENT:
      case MIBParser::OPTIONAL:
      case MIBParser::PRESENT: {
        enterOuterAlt(_localctx, 2);
        setState(634);
        componentValuePresence();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentValuePresenceContext ------------------------------------------------------------------

MIBParser::ComponentValuePresenceContext::ComponentValuePresenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::ValueOrConstraintListContext* MIBParser::ComponentValuePresenceContext::valueOrConstraintList() {
  return getRuleContext<MIBParser::ValueOrConstraintListContext>(0);
}

MIBParser::ComponentPresenceContext* MIBParser::ComponentValuePresenceContext::componentPresence() {
  return getRuleContext<MIBParser::ComponentPresenceContext>(0);
}


size_t MIBParser::ComponentValuePresenceContext::getRuleIndex() const {
  return MIBParser::RuleComponentValuePresence;
}

void MIBParser::ComponentValuePresenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponentValuePresence(this);
}

void MIBParser::ComponentValuePresenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponentValuePresence(this);
}

MIBParser::ComponentValuePresenceContext* MIBParser::componentValuePresence() {
  ComponentValuePresenceContext *_localctx = _tracker.createInstance<ComponentValuePresenceContext>(_ctx, getState());
  enterRule(_localctx, 128, MIBParser::RuleComponentValuePresence);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(642);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::LEFT_BRACE:
      case MIBParser::LEFT_PAREN: {
        enterOuterAlt(_localctx, 1);
        setState(637);
        valueOrConstraintList();
        setState(639);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 16) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 16)) & 5188146770730811393) != 0)) {
          setState(638);
          componentPresence();
        }
        break;
      }

      case MIBParser::ABSENT:
      case MIBParser::OPTIONAL:
      case MIBParser::PRESENT: {
        enterOuterAlt(_localctx, 2);
        setState(641);
        componentPresence();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentPresenceContext ------------------------------------------------------------------

MIBParser::ComponentPresenceContext::ComponentPresenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ComponentPresenceContext::PRESENT() {
  return getToken(MIBParser::PRESENT, 0);
}

tree::TerminalNode* MIBParser::ComponentPresenceContext::ABSENT() {
  return getToken(MIBParser::ABSENT, 0);
}

tree::TerminalNode* MIBParser::ComponentPresenceContext::OPTIONAL() {
  return getToken(MIBParser::OPTIONAL, 0);
}


size_t MIBParser::ComponentPresenceContext::getRuleIndex() const {
  return MIBParser::RuleComponentPresence;
}

void MIBParser::ComponentPresenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponentPresence(this);
}

void MIBParser::ComponentPresenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponentPresence(this);
}

MIBParser::ComponentPresenceContext* MIBParser::componentPresence() {
  ComponentPresenceContext *_localctx = _tracker.createInstance<ComponentPresenceContext>(_ctx, getState());
  enterRule(_localctx, 130, MIBParser::RuleComponentPresence);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(644);
    _la = _input->LA(1);
    if (!(((((_la - 16) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 16)) & 5188146770730811393) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueAssignmentContext ------------------------------------------------------------------

MIBParser::ValueAssignmentContext::ValueAssignmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::ValueAssignmentContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::TypeContext* MIBParser::ValueAssignmentContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}

tree::TerminalNode* MIBParser::ValueAssignmentContext::DEFINITION() {
  return getToken(MIBParser::DEFINITION, 0);
}

MIBParser::ValueContext* MIBParser::ValueAssignmentContext::value() {
  return getRuleContext<MIBParser::ValueContext>(0);
}


size_t MIBParser::ValueAssignmentContext::getRuleIndex() const {
  return MIBParser::RuleValueAssignment;
}

void MIBParser::ValueAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueAssignment(this);
}

void MIBParser::ValueAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueAssignment(this);
}

MIBParser::ValueAssignmentContext* MIBParser::valueAssignment() {
  ValueAssignmentContext *_localctx = _tracker.createInstance<ValueAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 132, MIBParser::RuleValueAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(646);
    match(MIBParser::IDENTIFIER_STRING);
    setState(647);
    type();
    setState(648);
    match(MIBParser::DEFINITION);
    setState(649);
    value();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueContext ------------------------------------------------------------------

MIBParser::ValueContext::ValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::BuiltinValueContext* MIBParser::ValueContext::builtinValue() {
  return getRuleContext<MIBParser::BuiltinValueContext>(0);
}

MIBParser::DefinedValueContext* MIBParser::ValueContext::definedValue() {
  return getRuleContext<MIBParser::DefinedValueContext>(0);
}


size_t MIBParser::ValueContext::getRuleIndex() const {
  return MIBParser::RuleValue;
}

void MIBParser::ValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValue(this);
}

void MIBParser::ValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValue(this);
}

MIBParser::ValueContext* MIBParser::value() {
  ValueContext *_localctx = _tracker.createInstance<ValueContext>(_ctx, getState());
  enterRule(_localctx, 134, MIBParser::RuleValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(653);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(651);
      builtinValue();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(652);
      definedValue();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefinedValueContext ------------------------------------------------------------------

MIBParser::DefinedValueContext::DefinedValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::DefinedValueContext::INTEGER_STRING() {
  return getToken(MIBParser::INTEGER_STRING, 0);
}

tree::TerminalNode* MIBParser::DefinedValueContext::BINARY_STRING() {
  return getToken(MIBParser::BINARY_STRING, 0);
}

tree::TerminalNode* MIBParser::DefinedValueContext::HEXADECIMAL_STRING() {
  return getToken(MIBParser::HEXADECIMAL_STRING, 0);
}

tree::TerminalNode* MIBParser::DefinedValueContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::ModuleReferenceContext* MIBParser::DefinedValueContext::moduleReference() {
  return getRuleContext<MIBParser::ModuleReferenceContext>(0);
}


size_t MIBParser::DefinedValueContext::getRuleIndex() const {
  return MIBParser::RuleDefinedValue;
}

void MIBParser::DefinedValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefinedValue(this);
}

void MIBParser::DefinedValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefinedValue(this);
}

MIBParser::DefinedValueContext* MIBParser::definedValue() {
  DefinedValueContext *_localctx = _tracker.createInstance<DefinedValueContext>(_ctx, getState());
  enterRule(_localctx, 136, MIBParser::RuleDefinedValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(662);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::INTEGER_STRING: {
        enterOuterAlt(_localctx, 1);
        setState(655);
        match(MIBParser::INTEGER_STRING);
        break;
      }

      case MIBParser::BINARY_STRING: {
        enterOuterAlt(_localctx, 2);
        setState(656);
        match(MIBParser::BINARY_STRING);
        break;
      }

      case MIBParser::HEXADECIMAL_STRING: {
        enterOuterAlt(_localctx, 3);
        setState(657);
        match(MIBParser::HEXADECIMAL_STRING);
        break;
      }

      case MIBParser::IDENTIFIER_STRING: {
        enterOuterAlt(_localctx, 4);
        setState(659);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
        case 1: {
          setState(658);
          moduleReference();
          break;
        }

        default:
          break;
        }
        setState(661);
        match(MIBParser::IDENTIFIER_STRING);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BuiltinValueContext ------------------------------------------------------------------

MIBParser::BuiltinValueContext::BuiltinValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::NullValueContext* MIBParser::BuiltinValueContext::nullValue() {
  return getRuleContext<MIBParser::NullValueContext>(0);
}

MIBParser::BooleanValueContext* MIBParser::BuiltinValueContext::booleanValue() {
  return getRuleContext<MIBParser::BooleanValueContext>(0);
}

MIBParser::SpecialRealValueContext* MIBParser::BuiltinValueContext::specialRealValue() {
  return getRuleContext<MIBParser::SpecialRealValueContext>(0);
}

MIBParser::NumberValueContext* MIBParser::BuiltinValueContext::numberValue() {
  return getRuleContext<MIBParser::NumberValueContext>(0);
}

MIBParser::BinaryValueContext* MIBParser::BuiltinValueContext::binaryValue() {
  return getRuleContext<MIBParser::BinaryValueContext>(0);
}

MIBParser::HexadecimalValueContext* MIBParser::BuiltinValueContext::hexadecimalValue() {
  return getRuleContext<MIBParser::HexadecimalValueContext>(0);
}

MIBParser::StringValueContext* MIBParser::BuiltinValueContext::stringValue() {
  return getRuleContext<MIBParser::StringValueContext>(0);
}

MIBParser::BitOrObjectIdentifierValueContext* MIBParser::BuiltinValueContext::bitOrObjectIdentifierValue() {
  return getRuleContext<MIBParser::BitOrObjectIdentifierValueContext>(0);
}


size_t MIBParser::BuiltinValueContext::getRuleIndex() const {
  return MIBParser::RuleBuiltinValue;
}

void MIBParser::BuiltinValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBuiltinValue(this);
}

void MIBParser::BuiltinValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBuiltinValue(this);
}

MIBParser::BuiltinValueContext* MIBParser::builtinValue() {
  BuiltinValueContext *_localctx = _tracker.createInstance<BuiltinValueContext>(_ctx, getState());
  enterRule(_localctx, 138, MIBParser::RuleBuiltinValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(672);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::NULL_: {
        enterOuterAlt(_localctx, 1);
        setState(664);
        nullValue();
        break;
      }

      case MIBParser::FALSE:
      case MIBParser::TRUE: {
        enterOuterAlt(_localctx, 2);
        setState(665);
        booleanValue();
        break;
      }

      case MIBParser::MINUS_INFINITY:
      case MIBParser::PLUS_INFINITY: {
        enterOuterAlt(_localctx, 3);
        setState(666);
        specialRealValue();
        break;
      }

      case MIBParser::MINUS:
      case MIBParser::NUMBER_STRING: {
        enterOuterAlt(_localctx, 4);
        setState(667);
        numberValue();
        break;
      }

      case MIBParser::BINARY_STRING: {
        enterOuterAlt(_localctx, 5);
        setState(668);
        binaryValue();
        break;
      }

      case MIBParser::HEXADECIMAL_STRING: {
        enterOuterAlt(_localctx, 6);
        setState(669);
        hexadecimalValue();
        break;
      }

      case MIBParser::QUOTED_STRING: {
        enterOuterAlt(_localctx, 7);
        setState(670);
        stringValue();
        break;
      }

      case MIBParser::LEFT_BRACE: {
        enterOuterAlt(_localctx, 8);
        setState(671);
        bitOrObjectIdentifierValue();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullValueContext ------------------------------------------------------------------

MIBParser::NullValueContext::NullValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NullValueContext::NULL_() {
  return getToken(MIBParser::NULL_, 0);
}


size_t MIBParser::NullValueContext::getRuleIndex() const {
  return MIBParser::RuleNullValue;
}

void MIBParser::NullValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullValue(this);
}

void MIBParser::NullValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullValue(this);
}

MIBParser::NullValueContext* MIBParser::nullValue() {
  NullValueContext *_localctx = _tracker.createInstance<NullValueContext>(_ctx, getState());
  enterRule(_localctx, 140, MIBParser::RuleNullValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(674);
    match(MIBParser::NULL_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BooleanValueContext ------------------------------------------------------------------

MIBParser::BooleanValueContext::BooleanValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::BooleanValueContext::TRUE() {
  return getToken(MIBParser::TRUE, 0);
}

tree::TerminalNode* MIBParser::BooleanValueContext::FALSE() {
  return getToken(MIBParser::FALSE, 0);
}


size_t MIBParser::BooleanValueContext::getRuleIndex() const {
  return MIBParser::RuleBooleanValue;
}

void MIBParser::BooleanValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBooleanValue(this);
}

void MIBParser::BooleanValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBooleanValue(this);
}

MIBParser::BooleanValueContext* MIBParser::booleanValue() {
  BooleanValueContext *_localctx = _tracker.createInstance<BooleanValueContext>(_ctx, getState());
  enterRule(_localctx, 142, MIBParser::RuleBooleanValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(676);
    _la = _input->LA(1);
    if (!(_la == MIBParser::FALSE

    || _la == MIBParser::TRUE)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpecialRealValueContext ------------------------------------------------------------------

MIBParser::SpecialRealValueContext::SpecialRealValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SpecialRealValueContext::PLUS_INFINITY() {
  return getToken(MIBParser::PLUS_INFINITY, 0);
}

tree::TerminalNode* MIBParser::SpecialRealValueContext::MINUS_INFINITY() {
  return getToken(MIBParser::MINUS_INFINITY, 0);
}


size_t MIBParser::SpecialRealValueContext::getRuleIndex() const {
  return MIBParser::RuleSpecialRealValue;
}

void MIBParser::SpecialRealValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpecialRealValue(this);
}

void MIBParser::SpecialRealValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpecialRealValue(this);
}

MIBParser::SpecialRealValueContext* MIBParser::specialRealValue() {
  SpecialRealValueContext *_localctx = _tracker.createInstance<SpecialRealValueContext>(_ctx, getState());
  enterRule(_localctx, 144, MIBParser::RuleSpecialRealValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(678);
    _la = _input->LA(1);
    if (!(_la == MIBParser::MINUS_INFINITY

    || _la == MIBParser::PLUS_INFINITY)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumberValueContext ------------------------------------------------------------------

MIBParser::NumberValueContext::NumberValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NumberValueContext::NUMBER_STRING() {
  return getToken(MIBParser::NUMBER_STRING, 0);
}

tree::TerminalNode* MIBParser::NumberValueContext::MINUS() {
  return getToken(MIBParser::MINUS, 0);
}


size_t MIBParser::NumberValueContext::getRuleIndex() const {
  return MIBParser::RuleNumberValue;
}

void MIBParser::NumberValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumberValue(this);
}

void MIBParser::NumberValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumberValue(this);
}

MIBParser::NumberValueContext* MIBParser::numberValue() {
  NumberValueContext *_localctx = _tracker.createInstance<NumberValueContext>(_ctx, getState());
  enterRule(_localctx, 146, MIBParser::RuleNumberValue);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(681);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::MINUS) {
      setState(680);
      match(MIBParser::MINUS);
    }
    setState(683);
    match(MIBParser::NUMBER_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BinaryValueContext ------------------------------------------------------------------

MIBParser::BinaryValueContext::BinaryValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::BinaryValueContext::BINARY_STRING() {
  return getToken(MIBParser::BINARY_STRING, 0);
}


size_t MIBParser::BinaryValueContext::getRuleIndex() const {
  return MIBParser::RuleBinaryValue;
}

void MIBParser::BinaryValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBinaryValue(this);
}

void MIBParser::BinaryValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBinaryValue(this);
}

MIBParser::BinaryValueContext* MIBParser::binaryValue() {
  BinaryValueContext *_localctx = _tracker.createInstance<BinaryValueContext>(_ctx, getState());
  enterRule(_localctx, 148, MIBParser::RuleBinaryValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(685);
    match(MIBParser::BINARY_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HexadecimalValueContext ------------------------------------------------------------------

MIBParser::HexadecimalValueContext::HexadecimalValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::HexadecimalValueContext::HEXADECIMAL_STRING() {
  return getToken(MIBParser::HEXADECIMAL_STRING, 0);
}


size_t MIBParser::HexadecimalValueContext::getRuleIndex() const {
  return MIBParser::RuleHexadecimalValue;
}

void MIBParser::HexadecimalValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHexadecimalValue(this);
}

void MIBParser::HexadecimalValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHexadecimalValue(this);
}

MIBParser::HexadecimalValueContext* MIBParser::hexadecimalValue() {
  HexadecimalValueContext *_localctx = _tracker.createInstance<HexadecimalValueContext>(_ctx, getState());
  enterRule(_localctx, 150, MIBParser::RuleHexadecimalValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(687);
    match(MIBParser::HEXADECIMAL_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringValueContext ------------------------------------------------------------------

MIBParser::StringValueContext::StringValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::StringValueContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::StringValueContext::getRuleIndex() const {
  return MIBParser::RuleStringValue;
}

void MIBParser::StringValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringValue(this);
}

void MIBParser::StringValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringValue(this);
}

MIBParser::StringValueContext* MIBParser::stringValue() {
  StringValueContext *_localctx = _tracker.createInstance<StringValueContext>(_ctx, getState());
  enterRule(_localctx, 152, MIBParser::RuleStringValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(689);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitOrObjectIdentifierValueContext ------------------------------------------------------------------

MIBParser::BitOrObjectIdentifierValueContext::BitOrObjectIdentifierValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::NameValueListContext* MIBParser::BitOrObjectIdentifierValueContext::nameValueList() {
  return getRuleContext<MIBParser::NameValueListContext>(0);
}


size_t MIBParser::BitOrObjectIdentifierValueContext::getRuleIndex() const {
  return MIBParser::RuleBitOrObjectIdentifierValue;
}

void MIBParser::BitOrObjectIdentifierValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitOrObjectIdentifierValue(this);
}

void MIBParser::BitOrObjectIdentifierValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitOrObjectIdentifierValue(this);
}

MIBParser::BitOrObjectIdentifierValueContext* MIBParser::bitOrObjectIdentifierValue() {
  BitOrObjectIdentifierValueContext *_localctx = _tracker.createInstance<BitOrObjectIdentifierValueContext>(_ctx, getState());
  enterRule(_localctx, 154, MIBParser::RuleBitOrObjectIdentifierValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(691);
    nameValueList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitValueContext ------------------------------------------------------------------

MIBParser::BitValueContext::BitValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::NameValueListContext* MIBParser::BitValueContext::nameValueList() {
  return getRuleContext<MIBParser::NameValueListContext>(0);
}


size_t MIBParser::BitValueContext::getRuleIndex() const {
  return MIBParser::RuleBitValue;
}

void MIBParser::BitValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitValue(this);
}

void MIBParser::BitValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitValue(this);
}

MIBParser::BitValueContext* MIBParser::bitValue() {
  BitValueContext *_localctx = _tracker.createInstance<BitValueContext>(_ctx, getState());
  enterRule(_localctx, 156, MIBParser::RuleBitValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(693);
    nameValueList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ObjectIdentifierValueContext ------------------------------------------------------------------

MIBParser::ObjectIdentifierValueContext::ObjectIdentifierValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::NameValueListContext* MIBParser::ObjectIdentifierValueContext::nameValueList() {
  return getRuleContext<MIBParser::NameValueListContext>(0);
}


size_t MIBParser::ObjectIdentifierValueContext::getRuleIndex() const {
  return MIBParser::RuleObjectIdentifierValue;
}

void MIBParser::ObjectIdentifierValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterObjectIdentifierValue(this);
}

void MIBParser::ObjectIdentifierValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitObjectIdentifierValue(this);
}

MIBParser::ObjectIdentifierValueContext* MIBParser::objectIdentifierValue() {
  ObjectIdentifierValueContext *_localctx = _tracker.createInstance<ObjectIdentifierValueContext>(_ctx, getState());
  enterRule(_localctx, 158, MIBParser::RuleObjectIdentifierValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(695);
    nameValueList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameValueListContext ------------------------------------------------------------------

MIBParser::NameValueListContext::NameValueListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NameValueListContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

tree::TerminalNode* MIBParser::NameValueListContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}

std::vector<MIBParser::NameValueComponentContext *> MIBParser::NameValueListContext::nameValueComponent() {
  return getRuleContexts<MIBParser::NameValueComponentContext>();
}

MIBParser::NameValueComponentContext* MIBParser::NameValueListContext::nameValueComponent(size_t i) {
  return getRuleContext<MIBParser::NameValueComponentContext>(i);
}


size_t MIBParser::NameValueListContext::getRuleIndex() const {
  return MIBParser::RuleNameValueList;
}

void MIBParser::NameValueListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNameValueList(this);
}

void MIBParser::NameValueListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNameValueList(this);
}

MIBParser::NameValueListContext* MIBParser::nameValueList() {
  NameValueListContext *_localctx = _tracker.createInstance<NameValueListContext>(_ctx, getState());
  enterRule(_localctx, 160, MIBParser::RuleNameValueList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(697);
    match(MIBParser::LEFT_BRACE);
    setState(701);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MIBParser::COMMA || _la == MIBParser::IDENTIFIER_STRING

    || _la == MIBParser::NUMBER_STRING) {
      setState(698);
      nameValueComponent();
      setState(703);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(704);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameValueComponentContext ------------------------------------------------------------------

MIBParser::NameValueComponentContext::NameValueComponentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::NameOrNumberContext* MIBParser::NameValueComponentContext::nameOrNumber() {
  return getRuleContext<MIBParser::NameOrNumberContext>(0);
}

tree::TerminalNode* MIBParser::NameValueComponentContext::COMMA() {
  return getToken(MIBParser::COMMA, 0);
}


size_t MIBParser::NameValueComponentContext::getRuleIndex() const {
  return MIBParser::RuleNameValueComponent;
}

void MIBParser::NameValueComponentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNameValueComponent(this);
}

void MIBParser::NameValueComponentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNameValueComponent(this);
}

MIBParser::NameValueComponentContext* MIBParser::nameValueComponent() {
  NameValueComponentContext *_localctx = _tracker.createInstance<NameValueComponentContext>(_ctx, getState());
  enterRule(_localctx, 162, MIBParser::RuleNameValueComponent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(707);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::COMMA) {
      setState(706);
      match(MIBParser::COMMA);
    }
    setState(709);
    nameOrNumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameOrNumberContext ------------------------------------------------------------------

MIBParser::NameOrNumberContext::NameOrNumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NameOrNumberContext::NUMBER_STRING() {
  return getToken(MIBParser::NUMBER_STRING, 0);
}

tree::TerminalNode* MIBParser::NameOrNumberContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::NameAndNumberContext* MIBParser::NameOrNumberContext::nameAndNumber() {
  return getRuleContext<MIBParser::NameAndNumberContext>(0);
}


size_t MIBParser::NameOrNumberContext::getRuleIndex() const {
  return MIBParser::RuleNameOrNumber;
}

void MIBParser::NameOrNumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNameOrNumber(this);
}

void MIBParser::NameOrNumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNameOrNumber(this);
}

MIBParser::NameOrNumberContext* MIBParser::nameOrNumber() {
  NameOrNumberContext *_localctx = _tracker.createInstance<NameOrNumberContext>(_ctx, getState());
  enterRule(_localctx, 164, MIBParser::RuleNameOrNumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(714);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(711);
      match(MIBParser::NUMBER_STRING);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(712);
      match(MIBParser::IDENTIFIER_STRING);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(713);
      nameAndNumber();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameAndNumberContext ------------------------------------------------------------------

MIBParser::NameAndNumberContext::NameAndNumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::NameAndNumberContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

tree::TerminalNode* MIBParser::NameAndNumberContext::LEFT_PAREN() {
  return getToken(MIBParser::LEFT_PAREN, 0);
}

tree::TerminalNode* MIBParser::NameAndNumberContext::RIGHT_PAREN() {
  return getToken(MIBParser::RIGHT_PAREN, 0);
}

tree::TerminalNode* MIBParser::NameAndNumberContext::NUMBER_STRING() {
  return getToken(MIBParser::NUMBER_STRING, 0);
}

MIBParser::DefinedValueContext* MIBParser::NameAndNumberContext::definedValue() {
  return getRuleContext<MIBParser::DefinedValueContext>(0);
}


size_t MIBParser::NameAndNumberContext::getRuleIndex() const {
  return MIBParser::RuleNameAndNumber;
}

void MIBParser::NameAndNumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNameAndNumber(this);
}

void MIBParser::NameAndNumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNameAndNumber(this);
}

MIBParser::NameAndNumberContext* MIBParser::nameAndNumber() {
  NameAndNumberContext *_localctx = _tracker.createInstance<NameAndNumberContext>(_ctx, getState());
  enterRule(_localctx, 166, MIBParser::RuleNameAndNumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(716);
    match(MIBParser::IDENTIFIER_STRING);
    setState(717);
    match(MIBParser::LEFT_PAREN);
    setState(720);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::NUMBER_STRING: {
        setState(718);
        match(MIBParser::NUMBER_STRING);
        break;
      }

      case MIBParser::BINARY_STRING:
      case MIBParser::HEXADECIMAL_STRING:
      case MIBParser::IDENTIFIER_STRING:
      case MIBParser::INTEGER_STRING: {
        setState(719);
        definedValue();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(722);
    match(MIBParser::RIGHT_PAREN);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefinedMacroTypeContext ------------------------------------------------------------------

MIBParser::DefinedMacroTypeContext::DefinedMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::SnmpModuleIdentityMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpModuleIdentityMacroType() {
  return getRuleContext<MIBParser::SnmpModuleIdentityMacroTypeContext>(0);
}

MIBParser::SnmpObjectIdentityMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpObjectIdentityMacroType() {
  return getRuleContext<MIBParser::SnmpObjectIdentityMacroTypeContext>(0);
}

MIBParser::SnmpObjectTypeMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpObjectTypeMacroType() {
  return getRuleContext<MIBParser::SnmpObjectTypeMacroTypeContext>(0);
}

MIBParser::SnmpNotificationTypeMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpNotificationTypeMacroType() {
  return getRuleContext<MIBParser::SnmpNotificationTypeMacroTypeContext>(0);
}

MIBParser::SnmpTrapTypeMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpTrapTypeMacroType() {
  return getRuleContext<MIBParser::SnmpTrapTypeMacroTypeContext>(0);
}

MIBParser::SnmpTextualConventionMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpTextualConventionMacroType() {
  return getRuleContext<MIBParser::SnmpTextualConventionMacroTypeContext>(0);
}

MIBParser::SnmpObjectGroupMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpObjectGroupMacroType() {
  return getRuleContext<MIBParser::SnmpObjectGroupMacroTypeContext>(0);
}

MIBParser::SnmpNotificationGroupMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpNotificationGroupMacroType() {
  return getRuleContext<MIBParser::SnmpNotificationGroupMacroTypeContext>(0);
}

MIBParser::SnmpModuleComplianceMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpModuleComplianceMacroType() {
  return getRuleContext<MIBParser::SnmpModuleComplianceMacroTypeContext>(0);
}

MIBParser::SnmpAgentCapabilitiesMacroTypeContext* MIBParser::DefinedMacroTypeContext::snmpAgentCapabilitiesMacroType() {
  return getRuleContext<MIBParser::SnmpAgentCapabilitiesMacroTypeContext>(0);
}


size_t MIBParser::DefinedMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleDefinedMacroType;
}

void MIBParser::DefinedMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefinedMacroType(this);
}

void MIBParser::DefinedMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefinedMacroType(this);
}

MIBParser::DefinedMacroTypeContext* MIBParser::definedMacroType() {
  DefinedMacroTypeContext *_localctx = _tracker.createInstance<DefinedMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 168, MIBParser::RuleDefinedMacroType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(734);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::MODULE_IDENTITY: {
        enterOuterAlt(_localctx, 1);
        setState(724);
        snmpModuleIdentityMacroType();
        break;
      }

      case MIBParser::OBJECT_IDENTITY: {
        enterOuterAlt(_localctx, 2);
        setState(725);
        snmpObjectIdentityMacroType();
        break;
      }

      case MIBParser::OBJECT_TYPE: {
        enterOuterAlt(_localctx, 3);
        setState(726);
        snmpObjectTypeMacroType();
        break;
      }

      case MIBParser::NOTIFICATION_TYPE: {
        enterOuterAlt(_localctx, 4);
        setState(727);
        snmpNotificationTypeMacroType();
        break;
      }

      case MIBParser::TRAP_TYPE: {
        enterOuterAlt(_localctx, 5);
        setState(728);
        snmpTrapTypeMacroType();
        break;
      }

      case MIBParser::TEXTUAL_CONVENTION: {
        enterOuterAlt(_localctx, 6);
        setState(729);
        snmpTextualConventionMacroType();
        break;
      }

      case MIBParser::OBJECT_GROUP: {
        enterOuterAlt(_localctx, 7);
        setState(730);
        snmpObjectGroupMacroType();
        break;
      }

      case MIBParser::NOTIFICATION_GROUP: {
        enterOuterAlt(_localctx, 8);
        setState(731);
        snmpNotificationGroupMacroType();
        break;
      }

      case MIBParser::MODULE_COMPLIANCE: {
        enterOuterAlt(_localctx, 9);
        setState(732);
        snmpModuleComplianceMacroType();
        break;
      }

      case MIBParser::AGENT_CAPABILITIES: {
        enterOuterAlt(_localctx, 10);
        setState(733);
        snmpAgentCapabilitiesMacroType();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefinedMacroNameContext ------------------------------------------------------------------

MIBParser::DefinedMacroNameContext::DefinedMacroNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::MODULE_IDENTITY() {
  return getToken(MIBParser::MODULE_IDENTITY, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::OBJECT_IDENTITY() {
  return getToken(MIBParser::OBJECT_IDENTITY, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::OBJECT_TYPE() {
  return getToken(MIBParser::OBJECT_TYPE, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::NOTIFICATION_TYPE() {
  return getToken(MIBParser::NOTIFICATION_TYPE, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::TRAP_TYPE() {
  return getToken(MIBParser::TRAP_TYPE, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::TEXTUAL_CONVENTION() {
  return getToken(MIBParser::TEXTUAL_CONVENTION, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::OBJECT_GROUP() {
  return getToken(MIBParser::OBJECT_GROUP, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::NOTIFICATION_GROUP() {
  return getToken(MIBParser::NOTIFICATION_GROUP, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::MODULE_COMPLIANCE() {
  return getToken(MIBParser::MODULE_COMPLIANCE, 0);
}

tree::TerminalNode* MIBParser::DefinedMacroNameContext::AGENT_CAPABILITIES() {
  return getToken(MIBParser::AGENT_CAPABILITIES, 0);
}


size_t MIBParser::DefinedMacroNameContext::getRuleIndex() const {
  return MIBParser::RuleDefinedMacroName;
}

void MIBParser::DefinedMacroNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefinedMacroName(this);
}

void MIBParser::DefinedMacroNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefinedMacroName(this);
}

MIBParser::DefinedMacroNameContext* MIBParser::definedMacroName() {
  DefinedMacroNameContext *_localctx = _tracker.createInstance<DefinedMacroNameContext>(_ctx, getState());
  enterRule(_localctx, 170, MIBParser::RuleDefinedMacroName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(736);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 6917529027641606144) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & 6442451171) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpStatusDescrReferPartContext ------------------------------------------------------------------

MIBParser::SnmpStatusDescrReferPartContext::SnmpStatusDescrReferPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::SnmpStatusPartContext* MIBParser::SnmpStatusDescrReferPartContext::snmpStatusPart() {
  return getRuleContext<MIBParser::SnmpStatusPartContext>(0);
}

MIBParser::SnmpDescrPartContext* MIBParser::SnmpStatusDescrReferPartContext::snmpDescrPart() {
  return getRuleContext<MIBParser::SnmpDescrPartContext>(0);
}

MIBParser::SnmpReferPartContext* MIBParser::SnmpStatusDescrReferPartContext::snmpReferPart() {
  return getRuleContext<MIBParser::SnmpReferPartContext>(0);
}


size_t MIBParser::SnmpStatusDescrReferPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpStatusDescrReferPart;
}

void MIBParser::SnmpStatusDescrReferPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpStatusDescrReferPart(this);
}

void MIBParser::SnmpStatusDescrReferPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpStatusDescrReferPart(this);
}

MIBParser::SnmpStatusDescrReferPartContext* MIBParser::snmpStatusDescrReferPart() {
  SnmpStatusDescrReferPartContext *_localctx = _tracker.createInstance<SnmpStatusDescrReferPartContext>(_ctx, getState());
  enterRule(_localctx, 172, MIBParser::RuleSnmpStatusDescrReferPart);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(738);
    snmpStatusPart();
    setState(740);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 68, _ctx)) {
    case 1: {
      setState(739);
      snmpDescrPart();
      break;
    }

    default:
      break;
    }
    setState(743);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::REFERENCE) {
      setState(742);
      snmpReferPart();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpModuleIdentityMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpModuleIdentityMacroTypeContext::SnmpModuleIdentityMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpModuleIdentityMacroTypeContext::MODULE_IDENTITY() {
  return getToken(MIBParser::MODULE_IDENTITY, 0);
}

MIBParser::SnmpUpdatePartContext* MIBParser::SnmpModuleIdentityMacroTypeContext::snmpUpdatePart() {
  return getRuleContext<MIBParser::SnmpUpdatePartContext>(0);
}

MIBParser::SnmpOrganizationPartContext* MIBParser::SnmpModuleIdentityMacroTypeContext::snmpOrganizationPart() {
  return getRuleContext<MIBParser::SnmpOrganizationPartContext>(0);
}

MIBParser::SnmpContactPartContext* MIBParser::SnmpModuleIdentityMacroTypeContext::snmpContactPart() {
  return getRuleContext<MIBParser::SnmpContactPartContext>(0);
}

MIBParser::SnmpDescrPartContext* MIBParser::SnmpModuleIdentityMacroTypeContext::snmpDescrPart() {
  return getRuleContext<MIBParser::SnmpDescrPartContext>(0);
}

std::vector<MIBParser::SnmpRevisionPartContext *> MIBParser::SnmpModuleIdentityMacroTypeContext::snmpRevisionPart() {
  return getRuleContexts<MIBParser::SnmpRevisionPartContext>();
}

MIBParser::SnmpRevisionPartContext* MIBParser::SnmpModuleIdentityMacroTypeContext::snmpRevisionPart(size_t i) {
  return getRuleContext<MIBParser::SnmpRevisionPartContext>(i);
}


size_t MIBParser::SnmpModuleIdentityMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpModuleIdentityMacroType;
}

void MIBParser::SnmpModuleIdentityMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpModuleIdentityMacroType(this);
}

void MIBParser::SnmpModuleIdentityMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpModuleIdentityMacroType(this);
}

MIBParser::SnmpModuleIdentityMacroTypeContext* MIBParser::snmpModuleIdentityMacroType() {
  SnmpModuleIdentityMacroTypeContext *_localctx = _tracker.createInstance<SnmpModuleIdentityMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 174, MIBParser::RuleSnmpModuleIdentityMacroType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(745);
    match(MIBParser::MODULE_IDENTITY);
    setState(746);
    snmpUpdatePart();
    setState(747);
    snmpOrganizationPart();
    setState(748);
    snmpContactPart();
    setState(749);
    snmpDescrPart();
    setState(753);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MIBParser::REVISION) {
      setState(750);
      snmpRevisionPart();
      setState(755);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpObjectIdentityMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpObjectIdentityMacroTypeContext::SnmpObjectIdentityMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpObjectIdentityMacroTypeContext::OBJECT_IDENTITY() {
  return getToken(MIBParser::OBJECT_IDENTITY, 0);
}

MIBParser::SnmpStatusDescrReferPartContext* MIBParser::SnmpObjectIdentityMacroTypeContext::snmpStatusDescrReferPart() {
  return getRuleContext<MIBParser::SnmpStatusDescrReferPartContext>(0);
}


size_t MIBParser::SnmpObjectIdentityMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpObjectIdentityMacroType;
}

void MIBParser::SnmpObjectIdentityMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpObjectIdentityMacroType(this);
}

void MIBParser::SnmpObjectIdentityMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpObjectIdentityMacroType(this);
}

MIBParser::SnmpObjectIdentityMacroTypeContext* MIBParser::snmpObjectIdentityMacroType() {
  SnmpObjectIdentityMacroTypeContext *_localctx = _tracker.createInstance<SnmpObjectIdentityMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 176, MIBParser::RuleSnmpObjectIdentityMacroType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(756);
    match(MIBParser::OBJECT_IDENTITY);
    setState(757);
    snmpStatusDescrReferPart();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpObjectTypeMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpObjectTypeMacroTypeContext::SnmpObjectTypeMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpObjectTypeMacroTypeContext::OBJECT_TYPE() {
  return getToken(MIBParser::OBJECT_TYPE, 0);
}

MIBParser::SnmpSyntaxPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpSyntaxPart() {
  return getRuleContext<MIBParser::SnmpSyntaxPartContext>(0);
}

MIBParser::SnmpMaxAccessPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpMaxAccessPart() {
  return getRuleContext<MIBParser::SnmpMaxAccessPartContext>(0);
}

MIBParser::SnmpStatusDescrReferPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpStatusDescrReferPart() {
  return getRuleContext<MIBParser::SnmpStatusDescrReferPartContext>(0);
}

MIBParser::SnmpUnitsPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpUnitsPart() {
  return getRuleContext<MIBParser::SnmpUnitsPartContext>(0);
}

MIBParser::SnmpAccessPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpAccessPart() {
  return getRuleContext<MIBParser::SnmpAccessPartContext>(0);
}

MIBParser::SnmpIndexPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpIndexPart() {
  return getRuleContext<MIBParser::SnmpIndexPartContext>(0);
}

MIBParser::SnmpAugmentsPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpAugmentsPart() {
  return getRuleContext<MIBParser::SnmpAugmentsPartContext>(0);
}

MIBParser::SnmpDefValPartContext* MIBParser::SnmpObjectTypeMacroTypeContext::snmpDefValPart() {
  return getRuleContext<MIBParser::SnmpDefValPartContext>(0);
}


size_t MIBParser::SnmpObjectTypeMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpObjectTypeMacroType;
}

void MIBParser::SnmpObjectTypeMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpObjectTypeMacroType(this);
}

void MIBParser::SnmpObjectTypeMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpObjectTypeMacroType(this);
}

MIBParser::SnmpObjectTypeMacroTypeContext* MIBParser::snmpObjectTypeMacroType() {
  SnmpObjectTypeMacroTypeContext *_localctx = _tracker.createInstance<SnmpObjectTypeMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 178, MIBParser::RuleSnmpObjectTypeMacroType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(759);
    match(MIBParser::OBJECT_TYPE);
    setState(760);
    snmpSyntaxPart();
    setState(762);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::UNITS) {
      setState(761);
      snmpUnitsPart();
    }
    setState(765);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::ACCESS) {
      setState(764);
      snmpAccessPart();
    }
    setState(767);
    snmpMaxAccessPart();
    setState(768);
    snmpStatusDescrReferPart();
    setState(770);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
    case 1: {
      setState(769);
      snmpIndexPart();
      break;
    }

    default:
      break;
    }
    setState(773);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx)) {
    case 1: {
      setState(772);
      snmpAugmentsPart();
      break;
    }

    default:
      break;
    }
    setState(776);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
    case 1: {
      setState(775);
      snmpDefValPart();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpNotificationTypeMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpNotificationTypeMacroTypeContext::SnmpNotificationTypeMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpNotificationTypeMacroTypeContext::NOTIFICATION_TYPE() {
  return getToken(MIBParser::NOTIFICATION_TYPE, 0);
}

MIBParser::SnmpStatusDescrReferPartContext* MIBParser::SnmpNotificationTypeMacroTypeContext::snmpStatusDescrReferPart() {
  return getRuleContext<MIBParser::SnmpStatusDescrReferPartContext>(0);
}

MIBParser::SnmpObjectsPartContext* MIBParser::SnmpNotificationTypeMacroTypeContext::snmpObjectsPart() {
  return getRuleContext<MIBParser::SnmpObjectsPartContext>(0);
}


size_t MIBParser::SnmpNotificationTypeMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpNotificationTypeMacroType;
}

void MIBParser::SnmpNotificationTypeMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpNotificationTypeMacroType(this);
}

void MIBParser::SnmpNotificationTypeMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpNotificationTypeMacroType(this);
}

MIBParser::SnmpNotificationTypeMacroTypeContext* MIBParser::snmpNotificationTypeMacroType() {
  SnmpNotificationTypeMacroTypeContext *_localctx = _tracker.createInstance<SnmpNotificationTypeMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 180, MIBParser::RuleSnmpNotificationTypeMacroType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(778);
    match(MIBParser::NOTIFICATION_TYPE);
    setState(780);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::OBJECTS) {
      setState(779);
      snmpObjectsPart();
    }
    setState(782);
    snmpStatusDescrReferPart();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpTrapTypeMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpTrapTypeMacroTypeContext::SnmpTrapTypeMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpTrapTypeMacroTypeContext::TRAP_TYPE() {
  return getToken(MIBParser::TRAP_TYPE, 0);
}

MIBParser::SnmpEnterprisePartContext* MIBParser::SnmpTrapTypeMacroTypeContext::snmpEnterprisePart() {
  return getRuleContext<MIBParser::SnmpEnterprisePartContext>(0);
}

MIBParser::SnmpDescrPartContext* MIBParser::SnmpTrapTypeMacroTypeContext::snmpDescrPart() {
  return getRuleContext<MIBParser::SnmpDescrPartContext>(0);
}

MIBParser::SnmpVarPartContext* MIBParser::SnmpTrapTypeMacroTypeContext::snmpVarPart() {
  return getRuleContext<MIBParser::SnmpVarPartContext>(0);
}

MIBParser::SnmpReferPartContext* MIBParser::SnmpTrapTypeMacroTypeContext::snmpReferPart() {
  return getRuleContext<MIBParser::SnmpReferPartContext>(0);
}


size_t MIBParser::SnmpTrapTypeMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpTrapTypeMacroType;
}

void MIBParser::SnmpTrapTypeMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpTrapTypeMacroType(this);
}

void MIBParser::SnmpTrapTypeMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpTrapTypeMacroType(this);
}

MIBParser::SnmpTrapTypeMacroTypeContext* MIBParser::snmpTrapTypeMacroType() {
  SnmpTrapTypeMacroTypeContext *_localctx = _tracker.createInstance<SnmpTrapTypeMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 182, MIBParser::RuleSnmpTrapTypeMacroType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(784);
    match(MIBParser::TRAP_TYPE);
    setState(785);
    snmpEnterprisePart();
    setState(787);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::VARIABLES) {
      setState(786);
      snmpVarPart();
    }
    setState(789);
    snmpDescrPart();
    setState(791);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::REFERENCE) {
      setState(790);
      snmpReferPart();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpTextualConventionMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpTextualConventionMacroTypeContext::SnmpTextualConventionMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpTextualConventionMacroTypeContext::TEXTUAL_CONVENTION() {
  return getToken(MIBParser::TEXTUAL_CONVENTION, 0);
}

MIBParser::SnmpStatusDescrReferPartContext* MIBParser::SnmpTextualConventionMacroTypeContext::snmpStatusDescrReferPart() {
  return getRuleContext<MIBParser::SnmpStatusDescrReferPartContext>(0);
}

MIBParser::SnmpSyntaxPartContext* MIBParser::SnmpTextualConventionMacroTypeContext::snmpSyntaxPart() {
  return getRuleContext<MIBParser::SnmpSyntaxPartContext>(0);
}

MIBParser::SnmpDisplayPartContext* MIBParser::SnmpTextualConventionMacroTypeContext::snmpDisplayPart() {
  return getRuleContext<MIBParser::SnmpDisplayPartContext>(0);
}


size_t MIBParser::SnmpTextualConventionMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpTextualConventionMacroType;
}

void MIBParser::SnmpTextualConventionMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpTextualConventionMacroType(this);
}

void MIBParser::SnmpTextualConventionMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpTextualConventionMacroType(this);
}

MIBParser::SnmpTextualConventionMacroTypeContext* MIBParser::snmpTextualConventionMacroType() {
  SnmpTextualConventionMacroTypeContext *_localctx = _tracker.createInstance<SnmpTextualConventionMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 184, MIBParser::RuleSnmpTextualConventionMacroType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(793);
    match(MIBParser::TEXTUAL_CONVENTION);
    setState(795);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::DISPLAY_HINT) {
      setState(794);
      snmpDisplayPart();
    }
    setState(797);
    snmpStatusDescrReferPart();
    setState(798);
    snmpSyntaxPart();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpObjectGroupMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpObjectGroupMacroTypeContext::SnmpObjectGroupMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpObjectGroupMacroTypeContext::OBJECT_GROUP() {
  return getToken(MIBParser::OBJECT_GROUP, 0);
}

MIBParser::SnmpObjectsPartContext* MIBParser::SnmpObjectGroupMacroTypeContext::snmpObjectsPart() {
  return getRuleContext<MIBParser::SnmpObjectsPartContext>(0);
}

MIBParser::SnmpStatusDescrReferPartContext* MIBParser::SnmpObjectGroupMacroTypeContext::snmpStatusDescrReferPart() {
  return getRuleContext<MIBParser::SnmpStatusDescrReferPartContext>(0);
}


size_t MIBParser::SnmpObjectGroupMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpObjectGroupMacroType;
}

void MIBParser::SnmpObjectGroupMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpObjectGroupMacroType(this);
}

void MIBParser::SnmpObjectGroupMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpObjectGroupMacroType(this);
}

MIBParser::SnmpObjectGroupMacroTypeContext* MIBParser::snmpObjectGroupMacroType() {
  SnmpObjectGroupMacroTypeContext *_localctx = _tracker.createInstance<SnmpObjectGroupMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 186, MIBParser::RuleSnmpObjectGroupMacroType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(800);
    match(MIBParser::OBJECT_GROUP);
    setState(801);
    snmpObjectsPart();
    setState(802);
    snmpStatusDescrReferPart();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpNotificationGroupMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpNotificationGroupMacroTypeContext::SnmpNotificationGroupMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpNotificationGroupMacroTypeContext::NOTIFICATION_GROUP() {
  return getToken(MIBParser::NOTIFICATION_GROUP, 0);
}

MIBParser::SnmpNotificationPartContext* MIBParser::SnmpNotificationGroupMacroTypeContext::snmpNotificationPart() {
  return getRuleContext<MIBParser::SnmpNotificationPartContext>(0);
}

MIBParser::SnmpStatusPartContext* MIBParser::SnmpNotificationGroupMacroTypeContext::snmpStatusPart() {
  return getRuleContext<MIBParser::SnmpStatusPartContext>(0);
}

MIBParser::SnmpDescrPartContext* MIBParser::SnmpNotificationGroupMacroTypeContext::snmpDescrPart() {
  return getRuleContext<MIBParser::SnmpDescrPartContext>(0);
}

MIBParser::SnmpSyntaxPartContext* MIBParser::SnmpNotificationGroupMacroTypeContext::snmpSyntaxPart() {
  return getRuleContext<MIBParser::SnmpSyntaxPartContext>(0);
}

MIBParser::SnmpMaxAccessPartContext* MIBParser::SnmpNotificationGroupMacroTypeContext::snmpMaxAccessPart() {
  return getRuleContext<MIBParser::SnmpMaxAccessPartContext>(0);
}


size_t MIBParser::SnmpNotificationGroupMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpNotificationGroupMacroType;
}

void MIBParser::SnmpNotificationGroupMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpNotificationGroupMacroType(this);
}

void MIBParser::SnmpNotificationGroupMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpNotificationGroupMacroType(this);
}

MIBParser::SnmpNotificationGroupMacroTypeContext* MIBParser::snmpNotificationGroupMacroType() {
  SnmpNotificationGroupMacroTypeContext *_localctx = _tracker.createInstance<SnmpNotificationGroupMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 188, MIBParser::RuleSnmpNotificationGroupMacroType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(804);
    match(MIBParser::NOTIFICATION_GROUP);
    setState(805);
    snmpNotificationPart();
    setState(807);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::SYNTAX) {
      setState(806);
      snmpSyntaxPart();
    }
    setState(810);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::MAX_ACCESS) {
      setState(809);
      snmpMaxAccessPart();
    }
    setState(812);
    snmpStatusPart();
    setState(813);
    snmpDescrPart();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpModuleComplianceMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpModuleComplianceMacroTypeContext::SnmpModuleComplianceMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpModuleComplianceMacroTypeContext::MODULE_COMPLIANCE() {
  return getToken(MIBParser::MODULE_COMPLIANCE, 0);
}

MIBParser::SnmpStatusDescrReferPartContext* MIBParser::SnmpModuleComplianceMacroTypeContext::snmpStatusDescrReferPart() {
  return getRuleContext<MIBParser::SnmpStatusDescrReferPartContext>(0);
}

MIBParser::SnmpModulesPartContext* MIBParser::SnmpModuleComplianceMacroTypeContext::snmpModulesPart() {
  return getRuleContext<MIBParser::SnmpModulesPartContext>(0);
}

std::vector<MIBParser::SnmpGroupPartContext *> MIBParser::SnmpModuleComplianceMacroTypeContext::snmpGroupPart() {
  return getRuleContexts<MIBParser::SnmpGroupPartContext>();
}

MIBParser::SnmpGroupPartContext* MIBParser::SnmpModuleComplianceMacroTypeContext::snmpGroupPart(size_t i) {
  return getRuleContext<MIBParser::SnmpGroupPartContext>(i);
}

tree::TerminalNode* MIBParser::SnmpModuleComplianceMacroTypeContext::MODULE() {
  return getToken(MIBParser::MODULE, 0);
}

MIBParser::SnmpMandatoryGroupsPartContext* MIBParser::SnmpModuleComplianceMacroTypeContext::snmpMandatoryGroupsPart() {
  return getRuleContext<MIBParser::SnmpMandatoryGroupsPartContext>(0);
}


size_t MIBParser::SnmpModuleComplianceMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpModuleComplianceMacroType;
}

void MIBParser::SnmpModuleComplianceMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpModuleComplianceMacroType(this);
}

void MIBParser::SnmpModuleComplianceMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpModuleComplianceMacroType(this);
}

MIBParser::SnmpModuleComplianceMacroTypeContext* MIBParser::snmpModuleComplianceMacroType() {
  SnmpModuleComplianceMacroTypeContext *_localctx = _tracker.createInstance<SnmpModuleComplianceMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 190, MIBParser::RuleSnmpModuleComplianceMacroType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(815);
    match(MIBParser::MODULE_COMPLIANCE);
    setState(816);
    snmpStatusDescrReferPart();
    setState(820);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MIBParser::GROUP) {
      setState(817);
      snmpGroupPart();
      setState(822);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(826);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::MODULE: {
        setState(823);
        match(MIBParser::MODULE);
        setState(824);
        snmpMandatoryGroupsPart();
        break;
      }

      case MIBParser::MODULES: {
        setState(825);
        snmpModulesPart();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpAgentCapabilitiesMacroTypeContext ------------------------------------------------------------------

MIBParser::SnmpAgentCapabilitiesMacroTypeContext::SnmpAgentCapabilitiesMacroTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpAgentCapabilitiesMacroTypeContext::AGENT_CAPABILITIES() {
  return getToken(MIBParser::AGENT_CAPABILITIES, 0);
}

MIBParser::SnmpProductPartContext* MIBParser::SnmpAgentCapabilitiesMacroTypeContext::snmpProductPart() {
  return getRuleContext<MIBParser::SnmpProductPartContext>(0);
}

MIBParser::SnmpStatusDescrReferPartContext* MIBParser::SnmpAgentCapabilitiesMacroTypeContext::snmpStatusDescrReferPart() {
  return getRuleContext<MIBParser::SnmpStatusDescrReferPartContext>(0);
}

std::vector<MIBParser::SnmpSupportPartContext *> MIBParser::SnmpAgentCapabilitiesMacroTypeContext::snmpSupportPart() {
  return getRuleContexts<MIBParser::SnmpSupportPartContext>();
}

MIBParser::SnmpSupportPartContext* MIBParser::SnmpAgentCapabilitiesMacroTypeContext::snmpSupportPart(size_t i) {
  return getRuleContext<MIBParser::SnmpSupportPartContext>(i);
}


size_t MIBParser::SnmpAgentCapabilitiesMacroTypeContext::getRuleIndex() const {
  return MIBParser::RuleSnmpAgentCapabilitiesMacroType;
}

void MIBParser::SnmpAgentCapabilitiesMacroTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpAgentCapabilitiesMacroType(this);
}

void MIBParser::SnmpAgentCapabilitiesMacroTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpAgentCapabilitiesMacroType(this);
}

MIBParser::SnmpAgentCapabilitiesMacroTypeContext* MIBParser::snmpAgentCapabilitiesMacroType() {
  SnmpAgentCapabilitiesMacroTypeContext *_localctx = _tracker.createInstance<SnmpAgentCapabilitiesMacroTypeContext>(_ctx, getState());
  enterRule(_localctx, 192, MIBParser::RuleSnmpAgentCapabilitiesMacroType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(828);
    match(MIBParser::AGENT_CAPABILITIES);
    setState(829);
    snmpProductPart();
    setState(830);
    snmpStatusDescrReferPart();
    setState(834);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(831);
        snmpSupportPart(); 
      }
      setState(836);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpSupportPartContext ------------------------------------------------------------------

MIBParser::SnmpSupportPartContext::SnmpSupportPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpSupportPartContext::SUPPORTS() {
  return getToken(MIBParser::SUPPORTS, 0);
}

MIBParser::ModuleIdentifierContext* MIBParser::SnmpSupportPartContext::moduleIdentifier() {
  return getRuleContext<MIBParser::ModuleIdentifierContext>(0);
}

MIBParser::SnmpInclusionPartContext* MIBParser::SnmpSupportPartContext::snmpInclusionPart() {
  return getRuleContext<MIBParser::SnmpInclusionPartContext>(0);
}

MIBParser::SnmpVariationPartContext* MIBParser::SnmpSupportPartContext::snmpVariationPart() {
  return getRuleContext<MIBParser::SnmpVariationPartContext>(0);
}


size_t MIBParser::SnmpSupportPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpSupportPart;
}

void MIBParser::SnmpSupportPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpSupportPart(this);
}

void MIBParser::SnmpSupportPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpSupportPart(this);
}

MIBParser::SnmpSupportPartContext* MIBParser::snmpSupportPart() {
  SnmpSupportPartContext *_localctx = _tracker.createInstance<SnmpSupportPartContext>(_ctx, getState());
  enterRule(_localctx, 194, MIBParser::RuleSnmpSupportPart);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(837);
    match(MIBParser::SUPPORTS);
    setState(838);
    moduleIdentifier();
    setState(839);
    snmpInclusionPart();
    setState(841);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::VARIATION) {
      setState(840);
      snmpVariationPart();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpInclusionPartContext ------------------------------------------------------------------

MIBParser::SnmpInclusionPartContext::SnmpInclusionPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpInclusionPartContext::INCLUDES() {
  return getToken(MIBParser::INCLUDES, 0);
}

MIBParser::SymbolListContext* MIBParser::SnmpInclusionPartContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}


size_t MIBParser::SnmpInclusionPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpInclusionPart;
}

void MIBParser::SnmpInclusionPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpInclusionPart(this);
}

void MIBParser::SnmpInclusionPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpInclusionPart(this);
}

MIBParser::SnmpInclusionPartContext* MIBParser::snmpInclusionPart() {
  SnmpInclusionPartContext *_localctx = _tracker.createInstance<SnmpInclusionPartContext>(_ctx, getState());
  enterRule(_localctx, 196, MIBParser::RuleSnmpInclusionPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(843);
    match(MIBParser::INCLUDES);
    setState(844);
    symbolList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpVariationPartContext ------------------------------------------------------------------

MIBParser::SnmpVariationPartContext::SnmpVariationPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpVariationPartContext::VARIATION() {
  return getToken(MIBParser::VARIATION, 0);
}

tree::TerminalNode* MIBParser::SnmpVariationPartContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::SnmpSyntaxPartContext* MIBParser::SnmpVariationPartContext::snmpSyntaxPart() {
  return getRuleContext<MIBParser::SnmpSyntaxPartContext>(0);
}

MIBParser::SnmpAccessPartContext* MIBParser::SnmpVariationPartContext::snmpAccessPart() {
  return getRuleContext<MIBParser::SnmpAccessPartContext>(0);
}

MIBParser::SnmpWritePartContext* MIBParser::SnmpVariationPartContext::snmpWritePart() {
  return getRuleContext<MIBParser::SnmpWritePartContext>(0);
}

MIBParser::SnmpDefValPartContext* MIBParser::SnmpVariationPartContext::snmpDefValPart() {
  return getRuleContext<MIBParser::SnmpDefValPartContext>(0);
}


size_t MIBParser::SnmpVariationPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpVariationPart;
}

void MIBParser::SnmpVariationPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpVariationPart(this);
}

void MIBParser::SnmpVariationPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpVariationPart(this);
}

MIBParser::SnmpVariationPartContext* MIBParser::snmpVariationPart() {
  SnmpVariationPartContext *_localctx = _tracker.createInstance<SnmpVariationPartContext>(_ctx, getState());
  enterRule(_localctx, 198, MIBParser::RuleSnmpVariationPart);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(846);
    match(MIBParser::VARIATION);
    setState(847);
    match(MIBParser::IDENTIFIER_STRING);
    setState(856);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::SYNTAX: {
        setState(848);
        snmpSyntaxPart();
        break;
      }

      case MIBParser::ACCESS:
      case MIBParser::WRITE_SYNTAX: {
        setState(850);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MIBParser::WRITE_SYNTAX) {
          setState(849);
          snmpWritePart();
        }
        setState(852);
        snmpAccessPart();
        setState(854);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
        case 1: {
          setState(853);
          snmpDefValPart();
          break;
        }

        default:
          break;
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpGroupPartContext ------------------------------------------------------------------

MIBParser::SnmpGroupPartContext::SnmpGroupPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpGroupPartContext::GROUP() {
  return getToken(MIBParser::GROUP, 0);
}

tree::TerminalNode* MIBParser::SnmpGroupPartContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}

MIBParser::SnmpDescrPartContext* MIBParser::SnmpGroupPartContext::snmpDescrPart() {
  return getRuleContext<MIBParser::SnmpDescrPartContext>(0);
}

MIBParser::SnmpReferPartContext* MIBParser::SnmpGroupPartContext::snmpReferPart() {
  return getRuleContext<MIBParser::SnmpReferPartContext>(0);
}


size_t MIBParser::SnmpGroupPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpGroupPart;
}

void MIBParser::SnmpGroupPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpGroupPart(this);
}

void MIBParser::SnmpGroupPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpGroupPart(this);
}

MIBParser::SnmpGroupPartContext* MIBParser::snmpGroupPart() {
  SnmpGroupPartContext *_localctx = _tracker.createInstance<SnmpGroupPartContext>(_ctx, getState());
  enterRule(_localctx, 200, MIBParser::RuleSnmpGroupPart);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(858);
    match(MIBParser::GROUP);
    setState(859);
    match(MIBParser::IDENTIFIER_STRING);
    setState(860);
    snmpDescrPart();
    setState(862);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MIBParser::REFERENCE) {
      setState(861);
      snmpReferPart();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpAccessPartContext ------------------------------------------------------------------

MIBParser::SnmpAccessPartContext::SnmpAccessPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpAccessPartContext::ACCESS() {
  return getToken(MIBParser::ACCESS, 0);
}

tree::TerminalNode* MIBParser::SnmpAccessPartContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}


size_t MIBParser::SnmpAccessPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpAccessPart;
}

void MIBParser::SnmpAccessPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpAccessPart(this);
}

void MIBParser::SnmpAccessPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpAccessPart(this);
}

MIBParser::SnmpAccessPartContext* MIBParser::snmpAccessPart() {
  SnmpAccessPartContext *_localctx = _tracker.createInstance<SnmpAccessPartContext>(_ctx, getState());
  enterRule(_localctx, 202, MIBParser::RuleSnmpAccessPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(864);
    match(MIBParser::ACCESS);
    setState(865);
    match(MIBParser::IDENTIFIER_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpAugmentsPartContext ------------------------------------------------------------------

MIBParser::SnmpAugmentsPartContext::SnmpAugmentsPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpAugmentsPartContext::AUGMENTS() {
  return getToken(MIBParser::AUGMENTS, 0);
}

tree::TerminalNode* MIBParser::SnmpAugmentsPartContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

MIBParser::SymbolListContext* MIBParser::SnmpAugmentsPartContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}

tree::TerminalNode* MIBParser::SnmpAugmentsPartContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}


size_t MIBParser::SnmpAugmentsPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpAugmentsPart;
}

void MIBParser::SnmpAugmentsPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpAugmentsPart(this);
}

void MIBParser::SnmpAugmentsPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpAugmentsPart(this);
}

MIBParser::SnmpAugmentsPartContext* MIBParser::snmpAugmentsPart() {
  SnmpAugmentsPartContext *_localctx = _tracker.createInstance<SnmpAugmentsPartContext>(_ctx, getState());
  enterRule(_localctx, 204, MIBParser::RuleSnmpAugmentsPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(867);
    match(MIBParser::AUGMENTS);
    setState(868);
    match(MIBParser::LEFT_BRACE);
    setState(869);
    symbolList();
    setState(870);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpContactPartContext ------------------------------------------------------------------

MIBParser::SnmpContactPartContext::SnmpContactPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpContactPartContext::CONTACT_INFO() {
  return getToken(MIBParser::CONTACT_INFO, 0);
}

tree::TerminalNode* MIBParser::SnmpContactPartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpContactPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpContactPart;
}

void MIBParser::SnmpContactPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpContactPart(this);
}

void MIBParser::SnmpContactPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpContactPart(this);
}

MIBParser::SnmpContactPartContext* MIBParser::snmpContactPart() {
  SnmpContactPartContext *_localctx = _tracker.createInstance<SnmpContactPartContext>(_ctx, getState());
  enterRule(_localctx, 206, MIBParser::RuleSnmpContactPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(872);
    match(MIBParser::CONTACT_INFO);
    setState(873);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpDefValPartContext ------------------------------------------------------------------

MIBParser::SnmpDefValPartContext::SnmpDefValPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpDefValPartContext::DEFVAL() {
  return getToken(MIBParser::DEFVAL, 0);
}

tree::TerminalNode* MIBParser::SnmpDefValPartContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

MIBParser::ValueContext* MIBParser::SnmpDefValPartContext::value() {
  return getRuleContext<MIBParser::ValueContext>(0);
}

tree::TerminalNode* MIBParser::SnmpDefValPartContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}


size_t MIBParser::SnmpDefValPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpDefValPart;
}

void MIBParser::SnmpDefValPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpDefValPart(this);
}

void MIBParser::SnmpDefValPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpDefValPart(this);
}

MIBParser::SnmpDefValPartContext* MIBParser::snmpDefValPart() {
  SnmpDefValPartContext *_localctx = _tracker.createInstance<SnmpDefValPartContext>(_ctx, getState());
  enterRule(_localctx, 208, MIBParser::RuleSnmpDefValPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(875);
    match(MIBParser::DEFVAL);
    setState(876);
    match(MIBParser::LEFT_BRACE);
    setState(877);
    value();
    setState(878);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpDescrPartContext ------------------------------------------------------------------

MIBParser::SnmpDescrPartContext::SnmpDescrPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpDescrPartContext::DESCRIPTION() {
  return getToken(MIBParser::DESCRIPTION, 0);
}

tree::TerminalNode* MIBParser::SnmpDescrPartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpDescrPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpDescrPart;
}

void MIBParser::SnmpDescrPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpDescrPart(this);
}

void MIBParser::SnmpDescrPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpDescrPart(this);
}

MIBParser::SnmpDescrPartContext* MIBParser::snmpDescrPart() {
  SnmpDescrPartContext *_localctx = _tracker.createInstance<SnmpDescrPartContext>(_ctx, getState());
  enterRule(_localctx, 210, MIBParser::RuleSnmpDescrPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(880);
    match(MIBParser::DESCRIPTION);
    setState(881);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpDisplayPartContext ------------------------------------------------------------------

MIBParser::SnmpDisplayPartContext::SnmpDisplayPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpDisplayPartContext::DISPLAY_HINT() {
  return getToken(MIBParser::DISPLAY_HINT, 0);
}

tree::TerminalNode* MIBParser::SnmpDisplayPartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpDisplayPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpDisplayPart;
}

void MIBParser::SnmpDisplayPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpDisplayPart(this);
}

void MIBParser::SnmpDisplayPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpDisplayPart(this);
}

MIBParser::SnmpDisplayPartContext* MIBParser::snmpDisplayPart() {
  SnmpDisplayPartContext *_localctx = _tracker.createInstance<SnmpDisplayPartContext>(_ctx, getState());
  enterRule(_localctx, 212, MIBParser::RuleSnmpDisplayPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(883);
    match(MIBParser::DISPLAY_HINT);
    setState(884);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpEnterprisePartContext ------------------------------------------------------------------

MIBParser::SnmpEnterprisePartContext::SnmpEnterprisePartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpEnterprisePartContext::ENTERPRISE() {
  return getToken(MIBParser::ENTERPRISE, 0);
}

MIBParser::ElementTypeListContext* MIBParser::SnmpEnterprisePartContext::elementTypeList() {
  return getRuleContext<MIBParser::ElementTypeListContext>(0);
}


size_t MIBParser::SnmpEnterprisePartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpEnterprisePart;
}

void MIBParser::SnmpEnterprisePartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpEnterprisePart(this);
}

void MIBParser::SnmpEnterprisePartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpEnterprisePart(this);
}

MIBParser::SnmpEnterprisePartContext* MIBParser::snmpEnterprisePart() {
  SnmpEnterprisePartContext *_localctx = _tracker.createInstance<SnmpEnterprisePartContext>(_ctx, getState());
  enterRule(_localctx, 214, MIBParser::RuleSnmpEnterprisePart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(886);
    match(MIBParser::ENTERPRISE);
    setState(887);
    elementTypeList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpIndexPartContext ------------------------------------------------------------------

MIBParser::SnmpIndexPartContext::SnmpIndexPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpIndexPartContext::INDEX() {
  return getToken(MIBParser::INDEX, 0);
}

MIBParser::SequenceContentContext* MIBParser::SnmpIndexPartContext::sequenceContent() {
  return getRuleContext<MIBParser::SequenceContentContext>(0);
}

MIBParser::ElementTypeListContext* MIBParser::SnmpIndexPartContext::elementTypeList() {
  return getRuleContext<MIBParser::ElementTypeListContext>(0);
}


size_t MIBParser::SnmpIndexPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpIndexPart;
}

void MIBParser::SnmpIndexPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpIndexPart(this);
}

void MIBParser::SnmpIndexPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpIndexPart(this);
}

MIBParser::SnmpIndexPartContext* MIBParser::snmpIndexPart() {
  SnmpIndexPartContext *_localctx = _tracker.createInstance<SnmpIndexPartContext>(_ctx, getState());
  enterRule(_localctx, 216, MIBParser::RuleSnmpIndexPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(892);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MIBParser::INDEX: {
        enterOuterAlt(_localctx, 1);
        setState(889);
        match(MIBParser::INDEX);
        setState(890);
        sequenceContent();
        break;
      }

      case MIBParser::LEFT_BRACKET:
      case MIBParser::AGENT_CAPABILITIES:
      case MIBParser::ANY:
      case MIBParser::BIT:
      case MIBParser::BITS:
      case MIBParser::BOOLEAN:
      case MIBParser::CHOICE:
      case MIBParser::COMPONENTS:
      case MIBParser::ENUMERATED:
      case MIBParser::INTEGER:
      case MIBParser::MODULE_COMPLIANCE:
      case MIBParser::MODULE_IDENTITY:
      case MIBParser::NOTIFICATION_GROUP:
      case MIBParser::NOTIFICATION_TYPE:
      case MIBParser::NULL_:
      case MIBParser::OBJECT:
      case MIBParser::OBJECT_GROUP:
      case MIBParser::OBJECT_IDENTITY:
      case MIBParser::OBJECT_TYPE:
      case MIBParser::OCTET:
      case MIBParser::REAL:
      case MIBParser::SEQUENCE:
      case MIBParser::SET:
      case MIBParser::TEXTUAL_CONVENTION:
      case MIBParser::TRAP_TYPE:
      case MIBParser::IDENTIFIER_STRING: {
        enterOuterAlt(_localctx, 2);
        setState(891);
        elementTypeList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpMaxAccessPartContext ------------------------------------------------------------------

MIBParser::SnmpMaxAccessPartContext::SnmpMaxAccessPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpMaxAccessPartContext::MAX_ACCESS() {
  return getToken(MIBParser::MAX_ACCESS, 0);
}

MIBParser::AccessLevelContext* MIBParser::SnmpMaxAccessPartContext::accessLevel() {
  return getRuleContext<MIBParser::AccessLevelContext>(0);
}


size_t MIBParser::SnmpMaxAccessPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpMaxAccessPart;
}

void MIBParser::SnmpMaxAccessPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpMaxAccessPart(this);
}

void MIBParser::SnmpMaxAccessPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpMaxAccessPart(this);
}

MIBParser::SnmpMaxAccessPartContext* MIBParser::snmpMaxAccessPart() {
  SnmpMaxAccessPartContext *_localctx = _tracker.createInstance<SnmpMaxAccessPartContext>(_ctx, getState());
  enterRule(_localctx, 218, MIBParser::RuleSnmpMaxAccessPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(894);
    match(MIBParser::MAX_ACCESS);
    setState(895);
    accessLevel();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpMandatoryGroupsPartContext ------------------------------------------------------------------

MIBParser::SnmpMandatoryGroupsPartContext::SnmpMandatoryGroupsPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpMandatoryGroupsPartContext::MANDATORY_GROUPS() {
  return getToken(MIBParser::MANDATORY_GROUPS, 0);
}

tree::TerminalNode* MIBParser::SnmpMandatoryGroupsPartContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

MIBParser::SymbolListContext* MIBParser::SnmpMandatoryGroupsPartContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}

tree::TerminalNode* MIBParser::SnmpMandatoryGroupsPartContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}


size_t MIBParser::SnmpMandatoryGroupsPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpMandatoryGroupsPart;
}

void MIBParser::SnmpMandatoryGroupsPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpMandatoryGroupsPart(this);
}

void MIBParser::SnmpMandatoryGroupsPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpMandatoryGroupsPart(this);
}

MIBParser::SnmpMandatoryGroupsPartContext* MIBParser::snmpMandatoryGroupsPart() {
  SnmpMandatoryGroupsPartContext *_localctx = _tracker.createInstance<SnmpMandatoryGroupsPartContext>(_ctx, getState());
  enterRule(_localctx, 220, MIBParser::RuleSnmpMandatoryGroupsPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(897);
    match(MIBParser::MANDATORY_GROUPS);
    setState(898);
    match(MIBParser::LEFT_BRACE);
    setState(899);
    symbolList();
    setState(900);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpMibGroupsPartContext ------------------------------------------------------------------

MIBParser::SnmpMibGroupsPartContext::SnmpMibGroupsPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpMibGroupsPartContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

MIBParser::SymbolListContext* MIBParser::SnmpMibGroupsPartContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}

tree::TerminalNode* MIBParser::SnmpMibGroupsPartContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}


size_t MIBParser::SnmpMibGroupsPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpMibGroupsPart;
}

void MIBParser::SnmpMibGroupsPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpMibGroupsPart(this);
}

void MIBParser::SnmpMibGroupsPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpMibGroupsPart(this);
}

MIBParser::SnmpMibGroupsPartContext* MIBParser::snmpMibGroupsPart() {
  SnmpMibGroupsPartContext *_localctx = _tracker.createInstance<SnmpMibGroupsPartContext>(_ctx, getState());
  enterRule(_localctx, 222, MIBParser::RuleSnmpMibGroupsPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(902);
    match(MIBParser::LEFT_BRACE);
    setState(903);
    symbolList();
    setState(904);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpMibCompliancePartContext ------------------------------------------------------------------

MIBParser::SnmpMibCompliancePartContext::SnmpMibCompliancePartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MIBParser::ModuleReferenceContext* MIBParser::SnmpMibCompliancePartContext::moduleReference() {
  return getRuleContext<MIBParser::ModuleReferenceContext>(0);
}

MIBParser::SnmpMibGroupsPartContext* MIBParser::SnmpMibCompliancePartContext::snmpMibGroupsPart() {
  return getRuleContext<MIBParser::SnmpMibGroupsPartContext>(0);
}


size_t MIBParser::SnmpMibCompliancePartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpMibCompliancePart;
}

void MIBParser::SnmpMibCompliancePartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpMibCompliancePart(this);
}

void MIBParser::SnmpMibCompliancePartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpMibCompliancePart(this);
}

MIBParser::SnmpMibCompliancePartContext* MIBParser::snmpMibCompliancePart() {
  SnmpMibCompliancePartContext *_localctx = _tracker.createInstance<SnmpMibCompliancePartContext>(_ctx, getState());
  enterRule(_localctx, 224, MIBParser::RuleSnmpMibCompliancePart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(906);
    moduleReference();
    setState(907);
    snmpMibGroupsPart();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpModulesPartContext ------------------------------------------------------------------

MIBParser::SnmpModulesPartContext::SnmpModulesPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpModulesPartContext::MODULES() {
  return getToken(MIBParser::MODULES, 0);
}

tree::TerminalNode* MIBParser::SnmpModulesPartContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

std::vector<MIBParser::SnmpMibCompliancePartContext *> MIBParser::SnmpModulesPartContext::snmpMibCompliancePart() {
  return getRuleContexts<MIBParser::SnmpMibCompliancePartContext>();
}

MIBParser::SnmpMibCompliancePartContext* MIBParser::SnmpModulesPartContext::snmpMibCompliancePart(size_t i) {
  return getRuleContext<MIBParser::SnmpMibCompliancePartContext>(i);
}

tree::TerminalNode* MIBParser::SnmpModulesPartContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}

std::vector<tree::TerminalNode *> MIBParser::SnmpModulesPartContext::COMMA() {
  return getTokens(MIBParser::COMMA);
}

tree::TerminalNode* MIBParser::SnmpModulesPartContext::COMMA(size_t i) {
  return getToken(MIBParser::COMMA, i);
}


size_t MIBParser::SnmpModulesPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpModulesPart;
}

void MIBParser::SnmpModulesPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpModulesPart(this);
}

void MIBParser::SnmpModulesPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpModulesPart(this);
}

MIBParser::SnmpModulesPartContext* MIBParser::snmpModulesPart() {
  SnmpModulesPartContext *_localctx = _tracker.createInstance<SnmpModulesPartContext>(_ctx, getState());
  enterRule(_localctx, 226, MIBParser::RuleSnmpModulesPart);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(909);
    match(MIBParser::MODULES);
    setState(910);
    match(MIBParser::LEFT_BRACE);
    setState(911);
    snmpMibCompliancePart();
    setState(916);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MIBParser::COMMA) {
      setState(912);
      match(MIBParser::COMMA);
      setState(913);
      snmpMibCompliancePart();
      setState(918);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(919);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpNotificationPartContext ------------------------------------------------------------------

MIBParser::SnmpNotificationPartContext::SnmpNotificationPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpNotificationPartContext::NOTIFICATIONS() {
  return getToken(MIBParser::NOTIFICATIONS, 0);
}

tree::TerminalNode* MIBParser::SnmpNotificationPartContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

MIBParser::SymbolListContext* MIBParser::SnmpNotificationPartContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}

tree::TerminalNode* MIBParser::SnmpNotificationPartContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}


size_t MIBParser::SnmpNotificationPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpNotificationPart;
}

void MIBParser::SnmpNotificationPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpNotificationPart(this);
}

void MIBParser::SnmpNotificationPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpNotificationPart(this);
}

MIBParser::SnmpNotificationPartContext* MIBParser::snmpNotificationPart() {
  SnmpNotificationPartContext *_localctx = _tracker.createInstance<SnmpNotificationPartContext>(_ctx, getState());
  enterRule(_localctx, 228, MIBParser::RuleSnmpNotificationPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(921);
    match(MIBParser::NOTIFICATIONS);
    setState(922);
    match(MIBParser::LEFT_BRACE);
    setState(923);
    symbolList();
    setState(924);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpObjectsPartContext ------------------------------------------------------------------

MIBParser::SnmpObjectsPartContext::SnmpObjectsPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpObjectsPartContext::OBJECTS() {
  return getToken(MIBParser::OBJECTS, 0);
}

tree::TerminalNode* MIBParser::SnmpObjectsPartContext::LEFT_BRACE() {
  return getToken(MIBParser::LEFT_BRACE, 0);
}

MIBParser::SymbolListContext* MIBParser::SnmpObjectsPartContext::symbolList() {
  return getRuleContext<MIBParser::SymbolListContext>(0);
}

tree::TerminalNode* MIBParser::SnmpObjectsPartContext::RIGHT_BRACE() {
  return getToken(MIBParser::RIGHT_BRACE, 0);
}


size_t MIBParser::SnmpObjectsPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpObjectsPart;
}

void MIBParser::SnmpObjectsPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpObjectsPart(this);
}

void MIBParser::SnmpObjectsPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpObjectsPart(this);
}

MIBParser::SnmpObjectsPartContext* MIBParser::snmpObjectsPart() {
  SnmpObjectsPartContext *_localctx = _tracker.createInstance<SnmpObjectsPartContext>(_ctx, getState());
  enterRule(_localctx, 230, MIBParser::RuleSnmpObjectsPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(926);
    match(MIBParser::OBJECTS);
    setState(927);
    match(MIBParser::LEFT_BRACE);
    setState(928);
    symbolList();
    setState(929);
    match(MIBParser::RIGHT_BRACE);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpOrganizationPartContext ------------------------------------------------------------------

MIBParser::SnmpOrganizationPartContext::SnmpOrganizationPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpOrganizationPartContext::ORGANIZATION() {
  return getToken(MIBParser::ORGANIZATION, 0);
}

tree::TerminalNode* MIBParser::SnmpOrganizationPartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpOrganizationPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpOrganizationPart;
}

void MIBParser::SnmpOrganizationPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpOrganizationPart(this);
}

void MIBParser::SnmpOrganizationPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpOrganizationPart(this);
}

MIBParser::SnmpOrganizationPartContext* MIBParser::snmpOrganizationPart() {
  SnmpOrganizationPartContext *_localctx = _tracker.createInstance<SnmpOrganizationPartContext>(_ctx, getState());
  enterRule(_localctx, 232, MIBParser::RuleSnmpOrganizationPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(931);
    match(MIBParser::ORGANIZATION);
    setState(932);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpProductPartContext ------------------------------------------------------------------

MIBParser::SnmpProductPartContext::SnmpProductPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpProductPartContext::PRODUCT_RELEASE() {
  return getToken(MIBParser::PRODUCT_RELEASE, 0);
}

tree::TerminalNode* MIBParser::SnmpProductPartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpProductPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpProductPart;
}

void MIBParser::SnmpProductPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpProductPart(this);
}

void MIBParser::SnmpProductPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpProductPart(this);
}

MIBParser::SnmpProductPartContext* MIBParser::snmpProductPart() {
  SnmpProductPartContext *_localctx = _tracker.createInstance<SnmpProductPartContext>(_ctx, getState());
  enterRule(_localctx, 234, MIBParser::RuleSnmpProductPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(934);
    match(MIBParser::PRODUCT_RELEASE);
    setState(935);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpReferPartContext ------------------------------------------------------------------

MIBParser::SnmpReferPartContext::SnmpReferPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpReferPartContext::REFERENCE() {
  return getToken(MIBParser::REFERENCE, 0);
}

tree::TerminalNode* MIBParser::SnmpReferPartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpReferPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpReferPart;
}

void MIBParser::SnmpReferPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpReferPart(this);
}

void MIBParser::SnmpReferPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpReferPart(this);
}

MIBParser::SnmpReferPartContext* MIBParser::snmpReferPart() {
  SnmpReferPartContext *_localctx = _tracker.createInstance<SnmpReferPartContext>(_ctx, getState());
  enterRule(_localctx, 236, MIBParser::RuleSnmpReferPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(937);
    match(MIBParser::REFERENCE);
    setState(938);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpRevisionPartContext ------------------------------------------------------------------

MIBParser::SnmpRevisionPartContext::SnmpRevisionPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpRevisionPartContext::REVISION() {
  return getToken(MIBParser::REVISION, 0);
}

std::vector<tree::TerminalNode *> MIBParser::SnmpRevisionPartContext::QUOTED_STRING() {
  return getTokens(MIBParser::QUOTED_STRING);
}

tree::TerminalNode* MIBParser::SnmpRevisionPartContext::QUOTED_STRING(size_t i) {
  return getToken(MIBParser::QUOTED_STRING, i);
}

tree::TerminalNode* MIBParser::SnmpRevisionPartContext::DESCRIPTION() {
  return getToken(MIBParser::DESCRIPTION, 0);
}


size_t MIBParser::SnmpRevisionPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpRevisionPart;
}

void MIBParser::SnmpRevisionPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpRevisionPart(this);
}

void MIBParser::SnmpRevisionPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpRevisionPart(this);
}

MIBParser::SnmpRevisionPartContext* MIBParser::snmpRevisionPart() {
  SnmpRevisionPartContext *_localctx = _tracker.createInstance<SnmpRevisionPartContext>(_ctx, getState());
  enterRule(_localctx, 238, MIBParser::RuleSnmpRevisionPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(940);
    match(MIBParser::REVISION);
    setState(941);
    match(MIBParser::QUOTED_STRING);
    setState(942);
    match(MIBParser::DESCRIPTION);
    setState(943);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpStatusPartContext ------------------------------------------------------------------

MIBParser::SnmpStatusPartContext::SnmpStatusPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpStatusPartContext::STATUS() {
  return getToken(MIBParser::STATUS, 0);
}

tree::TerminalNode* MIBParser::SnmpStatusPartContext::IDENTIFIER_STRING() {
  return getToken(MIBParser::IDENTIFIER_STRING, 0);
}


size_t MIBParser::SnmpStatusPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpStatusPart;
}

void MIBParser::SnmpStatusPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpStatusPart(this);
}

void MIBParser::SnmpStatusPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpStatusPart(this);
}

MIBParser::SnmpStatusPartContext* MIBParser::snmpStatusPart() {
  SnmpStatusPartContext *_localctx = _tracker.createInstance<SnmpStatusPartContext>(_ctx, getState());
  enterRule(_localctx, 240, MIBParser::RuleSnmpStatusPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(945);
    match(MIBParser::STATUS);
    setState(946);
    match(MIBParser::IDENTIFIER_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpSyntaxPartContext ------------------------------------------------------------------

MIBParser::SnmpSyntaxPartContext::SnmpSyntaxPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpSyntaxPartContext::SYNTAX() {
  return getToken(MIBParser::SYNTAX, 0);
}

MIBParser::TypeContext* MIBParser::SnmpSyntaxPartContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}


size_t MIBParser::SnmpSyntaxPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpSyntaxPart;
}

void MIBParser::SnmpSyntaxPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpSyntaxPart(this);
}

void MIBParser::SnmpSyntaxPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpSyntaxPart(this);
}

MIBParser::SnmpSyntaxPartContext* MIBParser::snmpSyntaxPart() {
  SnmpSyntaxPartContext *_localctx = _tracker.createInstance<SnmpSyntaxPartContext>(_ctx, getState());
  enterRule(_localctx, 242, MIBParser::RuleSnmpSyntaxPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(948);
    match(MIBParser::SYNTAX);
    setState(949);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpUnitsPartContext ------------------------------------------------------------------

MIBParser::SnmpUnitsPartContext::SnmpUnitsPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpUnitsPartContext::UNITS() {
  return getToken(MIBParser::UNITS, 0);
}

tree::TerminalNode* MIBParser::SnmpUnitsPartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpUnitsPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpUnitsPart;
}

void MIBParser::SnmpUnitsPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpUnitsPart(this);
}

void MIBParser::SnmpUnitsPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpUnitsPart(this);
}

MIBParser::SnmpUnitsPartContext* MIBParser::snmpUnitsPart() {
  SnmpUnitsPartContext *_localctx = _tracker.createInstance<SnmpUnitsPartContext>(_ctx, getState());
  enterRule(_localctx, 244, MIBParser::RuleSnmpUnitsPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(951);
    match(MIBParser::UNITS);
    setState(952);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpUpdatePartContext ------------------------------------------------------------------

MIBParser::SnmpUpdatePartContext::SnmpUpdatePartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpUpdatePartContext::LAST_UPDATED() {
  return getToken(MIBParser::LAST_UPDATED, 0);
}

tree::TerminalNode* MIBParser::SnmpUpdatePartContext::QUOTED_STRING() {
  return getToken(MIBParser::QUOTED_STRING, 0);
}


size_t MIBParser::SnmpUpdatePartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpUpdatePart;
}

void MIBParser::SnmpUpdatePartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpUpdatePart(this);
}

void MIBParser::SnmpUpdatePartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpUpdatePart(this);
}

MIBParser::SnmpUpdatePartContext* MIBParser::snmpUpdatePart() {
  SnmpUpdatePartContext *_localctx = _tracker.createInstance<SnmpUpdatePartContext>(_ctx, getState());
  enterRule(_localctx, 246, MIBParser::RuleSnmpUpdatePart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(954);
    match(MIBParser::LAST_UPDATED);
    setState(955);
    match(MIBParser::QUOTED_STRING);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpVarPartContext ------------------------------------------------------------------

MIBParser::SnmpVarPartContext::SnmpVarPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpVarPartContext::VARIABLES() {
  return getToken(MIBParser::VARIABLES, 0);
}

MIBParser::ElementTypeListContext* MIBParser::SnmpVarPartContext::elementTypeList() {
  return getRuleContext<MIBParser::ElementTypeListContext>(0);
}


size_t MIBParser::SnmpVarPartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpVarPart;
}

void MIBParser::SnmpVarPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpVarPart(this);
}

void MIBParser::SnmpVarPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpVarPart(this);
}

MIBParser::SnmpVarPartContext* MIBParser::snmpVarPart() {
  SnmpVarPartContext *_localctx = _tracker.createInstance<SnmpVarPartContext>(_ctx, getState());
  enterRule(_localctx, 248, MIBParser::RuleSnmpVarPart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(957);
    match(MIBParser::VARIABLES);
    setState(958);
    elementTypeList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SnmpWritePartContext ------------------------------------------------------------------

MIBParser::SnmpWritePartContext::SnmpWritePartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MIBParser::SnmpWritePartContext::WRITE_SYNTAX() {
  return getToken(MIBParser::WRITE_SYNTAX, 0);
}

MIBParser::TypeContext* MIBParser::SnmpWritePartContext::type() {
  return getRuleContext<MIBParser::TypeContext>(0);
}


size_t MIBParser::SnmpWritePartContext::getRuleIndex() const {
  return MIBParser::RuleSnmpWritePart;
}

void MIBParser::SnmpWritePartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSnmpWritePart(this);
}

void MIBParser::SnmpWritePartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MIBListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSnmpWritePart(this);
}

MIBParser::SnmpWritePartContext* MIBParser::snmpWritePart() {
  SnmpWritePartContext *_localctx = _tracker.createInstance<SnmpWritePartContext>(_ctx, getState());
  enterRule(_localctx, 250, MIBParser::RuleSnmpWritePart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(960);
    match(MIBParser::WRITE_SYNTAX);
    setState(961);
    type();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

void MIBParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  mibParserInitialize();
#else
  ::antlr4::internal::call_once(mibParserOnceFlag, mibParserInitialize);
#endif
}
